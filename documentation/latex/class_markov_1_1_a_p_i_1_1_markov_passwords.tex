\hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords}{}\doxysection{Markov\+::A\+PI\+::Markov\+Passwords Class Reference}
\label{class_markov_1_1_a_p_i_1_1_markov_passwords}\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}


\mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}} with char represented nodes.  




{\ttfamily \#include $<$markov\+Passwords.\+h$>$}



Inheritance diagram for Markov\+::A\+PI\+::Markov\+Passwords\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_markov_1_1_a_p_i_1_1_markov_passwords__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Markov\+::A\+PI\+::Markov\+Passwords\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_markov_1_1_a_p_i_1_1_markov_passwords__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a82a0edae676072c420fe74882d87a3cc}{Markov\+Passwords}} ()
\begin{DoxyCompactList}\small\item\em Initialize the markov model from Markov\+Model\+::\+Markov\+::\+Model. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ab7f0caaea1f96d4fdeea126f78d7081f}{Markov\+Passwords}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Initialize the markov model from Markov\+Model\+::\+Markov\+::\+Model, with an import file. \end{DoxyCompactList}\item 
std\+::ifstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac3fb665ee48937ca845d930e72e07917}{Open\+Dataset\+File}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open dataset file and return the ifstream pointer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2}{Train}} (const char $\ast$dataset\+File\+Name, char delimiter, int threads)
\begin{DoxyCompactList}\small\item\em Train the model with the dataset file. \end{DoxyCompactList}\item 
std\+::ofstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a4f4997da3a6cd3bd2717ce9759736660}{Save}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Export model to file. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39}{Generate}} (unsigned long int n, const char $\ast$wordlist\+File\+Name, int min\+Len=6, int max\+Len=12, int threads=20)
\begin{DoxyCompactList}\small\item\em Call \mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{Markov\+::\+Model\+::\+Random\+Walk}} n times, and collect output. \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{Random\+Walk}} (\mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{Markov\+::\+Random\+::\+Random\+Engine}} $\ast$random\+Engine, int min\+Setting, int max\+Setting, char $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Do a random walk on this model. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}{Adjust\+Edge}} (const char $\ast$payload, long int occurrence)
\begin{DoxyCompactList}\small\item\em Adjust the model with a single string. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}} (std\+::ifstream $\ast$)
\begin{DoxyCompactList}\small\item\em Import a file to construct the model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}{Import}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to import with filename, and call bool Model\+::\+Import with std\+::ifstream. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}} (std\+::ofstream $\ast$)
\begin{DoxyCompactList}\small\item\em Export a file of the model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}{Export}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to export with filename, and call bool Model\+::\+Export with std\+::ofstream. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ char $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}{Starter\+Node}} ()
\begin{DoxyCompactList}\small\item\em Return starter Node. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ char $>$ $\ast$ $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}{Edges}} ()
\begin{DoxyCompactList}\small\item\em Return a vector of all the edges in the model. \end{DoxyCompactList}\item 
std\+::map$<$ char, \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ char $>$ $\ast$ $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}{Nodes}} ()
\begin{DoxyCompactList}\small\item\em Return starter Node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e}{Train\+Thread}} (\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler}{Markov\+::\+A\+P\+I\+::\+Concurrency\+::\+Thread\+Shared\+List\+Handler}} $\ast$listhandler, char delimiter)
\begin{DoxyCompactList}\small\item\em A single thread invoked by the Train function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}{Generate\+Thread}} (std\+::mutex $\ast$output\+Lock, unsigned long int n, std\+::ofstream $\ast$wordlist, int min\+Len, int max\+Len)
\begin{DoxyCompactList}\small\item\em A single thread invoked by the Generate function. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::ifstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}{dataset\+File}}
\item 
std\+::ofstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_af5f012dcc495dbe769e663d6cb161d6a}{model\+Savefile}}
\item 
std\+::ofstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac05e60de64e866027410d4fa1cd03248}{output\+File}}
\item 
std\+::map$<$ char, \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ char $>$ $\ast$ $>$ \mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}
\begin{DoxyCompactList}\small\item\em Map Left\+Node is the Nodes Node\+Value Map Right\+Node is the node pointer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ char $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starter\+Node}}
\begin{DoxyCompactList}\small\item\em Starter Node of this model. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ char $>$ $\ast$ $>$ \mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}}
\begin{DoxyCompactList}\small\item\em A list of all edges in this model. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}} with char represented nodes. 

Includes wrappers for \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}} and additional helper functions to handle file I/O

This class is an extension of Markov\+::\+Model$<$char$>$, with higher level abstractions such as train and generate. 

Definition at line \mbox{\hyperlink{markov_passwords_8h_source_l00017}{17}} of file \mbox{\hyperlink{markov_passwords_8h_source}{markov\+Passwords.\+h}}.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_a82a0edae676072c420fe74882d87a3cc}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_a82a0edae676072c420fe74882d87a3cc}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!MarkovPasswords@{MarkovPasswords}}
\index{MarkovPasswords@{MarkovPasswords}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{MarkovPasswords()}{MarkovPasswords()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Markov\+Passwords (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Initialize the markov model from Markov\+Model\+::\+Markov\+::\+Model. 

Parent constructor. Has no extra functionality. 

Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00010}{10}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00010                                           : \mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}}()\{}
\DoxyCodeLine{00011     }
\DoxyCodeLine{00012     }
\DoxyCodeLine{00013 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_ab7f0caaea1f96d4fdeea126f78d7081f}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_ab7f0caaea1f96d4fdeea126f78d7081f}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!MarkovPasswords@{MarkovPasswords}}
\index{MarkovPasswords@{MarkovPasswords}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{MarkovPasswords()}{MarkovPasswords()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Markov\+Passwords (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Initialize the markov model from Markov\+Model\+::\+Markov\+::\+Model, with an import file. 

This function calls the \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Markov\+::\+Model\+::\+Import}} on the filename to construct the model. Same thing as creating and empty model, and calling \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Markov\+Passwords\+::\+Import}} on the filename.


\begin{DoxyParams}{Parameters}
{\em filename} & -\/ Filename to import\\
\hline
\end{DoxyParams}
{\bfseries{Example}} {\bfseries{Use\+:}} Construction via filename 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a82a0edae676072c420fe74882d87a3cc}{MarkovPasswords}} mp(\textcolor{stringliteral}{"test.mdl"});}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00015}{15}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00015                                                               \{}
\DoxyCodeLine{00016     }
\DoxyCodeLine{00017     std::ifstream* importFile;}
\DoxyCodeLine{00018 }
\DoxyCodeLine{00019     this-\/>\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(filename);}
\DoxyCodeLine{00020     }
\DoxyCodeLine{00021     \textcolor{comment}{//std::ifstream* newFile(filename);}}
\DoxyCodeLine{00022     }
\DoxyCodeLine{00023     \textcolor{comment}{//importFile = newFile; }}
\DoxyCodeLine{00024 }
\DoxyCodeLine{00025 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_8h_source_l00265}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Import()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_ab7f0caaea1f96d4fdeea126f78d7081f_cgraph}
\end{center}
\end{figure}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}\label{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!AdjustEdge@{AdjustEdge}}
\index{AdjustEdge@{AdjustEdge}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{AdjustEdge()}{AdjustEdge()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Adjust\+Edge (\begin{DoxyParamCaption}\item[{const char  $\ast$}]{payload,  }\item[{long int}]{occurrence }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Adjust the model with a single string. 

Start from the starter node, and for each character, Adjust\+Edge the edge Edge\+Weight from current node to the next, until N\+U\+LL character is reached.

Then, update the edge Edge\+Weight from current node, to the terminator node.

This function is used for training purposes, as it can be used for adjusting the model with each line of the corpus file.

{\bfseries{Example}} {\bfseries{Use\+:}} Create an empty model and train it with string\+: \char`\"{}testdata\char`\"{} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{\textcolor{keywordtype}{char} test[] = \textcolor{stringliteral}{"testdata"};}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.AdjustEdge(test, 15); }
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em string} & -\/ String that is passed from the training, and will be used to Adjust\+Edge the model with \\
\hline
{\em occurrence} & -\/ Occurrence of this string. \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{model_8h_source_l00322}{322}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00322                                                                                                  \{}
\DoxyCodeLine{00323     NodeStorageType p = payload[0];}
\DoxyCodeLine{00324     \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* curnode = this-\/>\mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starterNode}};}
\DoxyCodeLine{00325     \mbox{\hyperlink{class_markov_1_1_edge}{Markov::Edge<NodeStorageType>}}* e;}
\DoxyCodeLine{00326     \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{00327 }
\DoxyCodeLine{00328     \textcolor{keywordflow}{if} (p == 0) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00329     \textcolor{keywordflow}{while} (p != 0) \{}
\DoxyCodeLine{00330         e = curnode-\/>\mbox{\hyperlink{class_markov_1_1_node_ad836573fbdec1c6d7e72945f48ed081c}{FindEdge}}(p);}
\DoxyCodeLine{00331         \textcolor{keywordflow}{if} (e == NULL) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00332         e-\/>\mbox{\hyperlink{class_markov_1_1_edge_aa9d6cc6e631f1b515b4db604c96ad4ad}{AdjustEdge}}(occurrence);}
\DoxyCodeLine{00333         curnode = e-\/>\mbox{\hyperlink{class_markov_1_1_edge_a2e7d14e46631c85c84f6f8f1dd2949cd}{RightNode}}();}
\DoxyCodeLine{00334         p = payload[++i];}
\DoxyCodeLine{00335     \}}
\DoxyCodeLine{00336 }
\DoxyCodeLine{00337     e = curnode-\/>\mbox{\hyperlink{class_markov_1_1_node_ad836573fbdec1c6d7e72945f48ed081c}{FindEdge}}(\textcolor{stringliteral}{'\(\backslash\)xff'});}
\DoxyCodeLine{00338     e-\/>\mbox{\hyperlink{class_markov_1_1_edge_aa9d6cc6e631f1b515b4db604c96ad4ad}{AdjustEdge}}(occurrence);}
\DoxyCodeLine{00339     \textcolor{keywordflow}{return};}
\DoxyCodeLine{00340 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}\label{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!Edges@{Edges}}
\index{Edges@{Edges}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{Edges()}{Edges()}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$char $>$$\ast$$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Edges\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [inherited]}}



Return a vector of all the edges in the model. 

\begin{DoxyReturn}{Returns}
vector of edges 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_8h_source_l00172}{172}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00172 \{ \textcolor{keywordflow}{return} \&\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}};\}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}\label{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!Export@{Export}}
\index{Export@{Export}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Export (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Open a file to export with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Model\+::\+Export}} with std\+::ofstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Export file to filename 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.Export(\textcolor{stringliteral}{"test.mdl"});}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{model_8h_source_l00285}{285}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00285                                                               \{}
\DoxyCodeLine{00286     std::ofstream exportfile;}
\DoxyCodeLine{00287     exportfile.open(filename);}
\DoxyCodeLine{00288     \textcolor{keywordflow}{return} this-\/>\mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}}(\&exportfile);}
\DoxyCodeLine{00289 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}\label{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!Export@{Export}}
\index{Export@{Export}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Export (\begin{DoxyParamCaption}\item[{std\+::ofstream $\ast$}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Export a file of the model. 

File contains a list of edges. Format is\+: Left\+\_\+repr;Edge\+Weight;right\+\_\+repr. For more information on the format, check out the project wiki or github readme.

Iterate over this vertices, and their edges, and write them to file. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models.
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Export file to ofstream 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{std::ofstream file(\textcolor{stringliteral}{"test.mdl"});}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.Export(\&file);}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{model_8h_source_l00273}{273}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00273                                                         \{}
\DoxyCodeLine{00274     \mbox{\hyperlink{class_markov_1_1_edge}{Markov::Edge<NodeStorageType>}}* e;}
\DoxyCodeLine{00275     \textcolor{keywordflow}{for} (std::vector<int>::size\_type i = 0; i != this-\/>\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}}.size(); i++) \{}
\DoxyCodeLine{00276         e = this-\/>\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}}[i];}
\DoxyCodeLine{00277         \textcolor{comment}{//std::cout << e-\/>LeftNode()-\/>NodeValue() << "," << e-\/>EdgeWeight() << "," << e-\/>RightNode()-\/>NodeValue() << "\(\backslash\)n";}}
\DoxyCodeLine{00278         *\mbox{\hyperlink{namespacemodel__2gram_a2c21010331f2adf96f64d1e90d019e76}{f}} << e-\/>\mbox{\hyperlink{class_markov_1_1_edge_a3975b42a420de76e216d343dca059f88}{LeftNode}}()-\/>\mbox{\hyperlink{class_markov_1_1_node_ac7cce56376f2a00764f64a0194cbb498}{NodeValue}}() << \textcolor{stringliteral}{","} << e-\/>\mbox{\hyperlink{class_markov_1_1_edge_a2b1e5a6e6f81502cd8ac6b20ed38b677}{EdgeWeight}}() << \textcolor{stringliteral}{","} << e-\/>\mbox{\hyperlink{class_markov_1_1_edge_a2e7d14e46631c85c84f6f8f1dd2949cd}{RightNode}}()-\/>\mbox{\hyperlink{class_markov_1_1_node_ac7cce56376f2a00764f64a0194cbb498}{NodeValue}}() << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{00279     \}}
\DoxyCodeLine{00280 }
\DoxyCodeLine{00281     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00282 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!Generate@{Generate}}
\index{Generate@{Generate}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{Generate()}{Generate()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Generate (\begin{DoxyParamCaption}\item[{unsigned long int}]{n,  }\item[{const char $\ast$}]{wordlist\+File\+Name,  }\item[{int}]{min\+Len = {\ttfamily 6},  }\item[{int}]{max\+Len = {\ttfamily 12},  }\item[{int}]{threads = {\ttfamily 20} }\end{DoxyParamCaption})}



Call \mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{Markov\+::\+Model\+::\+Random\+Walk}} n times, and collect output. 

Generate from model and write results to a file. a much more performance-\/optimized method. Fast\+Random\+Walk will reduce the runtime by \%96.\+5 on average.

\begin{DoxyRefDesc}{Deprecated}
\item[\mbox{\hyperlink{deprecated__deprecated000001}{Deprecated}}]See Markov\+::\+A\+P\+I\+::\+Matrix\+Model\+::\+Fast\+Random\+Walk for more information. \end{DoxyRefDesc}

\begin{DoxyParams}{Parameters}
{\em n} & -\/ Number of passwords to generate. \\
\hline
{\em wordlist\+File\+Name} & -\/ Filename to write to \\
\hline
{\em min\+Len} & -\/ Minimum password length to generate \\
\hline
{\em max\+Len} & -\/ Maximum password length to generate \\
\hline
{\em threads} & -\/ number of OS threads to spawn \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00092}{92}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00092                                                                                                                                \{}
\DoxyCodeLine{00093     \textcolor{keywordtype}{char}* res;}
\DoxyCodeLine{00094     \textcolor{keywordtype}{char} print[100];}
\DoxyCodeLine{00095     std::ofstream wordlist; }
\DoxyCodeLine{00096     wordlist.open(wordlistFileName);}
\DoxyCodeLine{00097     std::mutex mlock;}
\DoxyCodeLine{00098     \textcolor{keywordtype}{int} iterationsPerThread = n/threads;}
\DoxyCodeLine{00099     \textcolor{keywordtype}{int} iterationsCarryOver = n\%threads;}
\DoxyCodeLine{00100     std::vector<std::thread*> threadsV;}
\DoxyCodeLine{00101     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<threads;i++)\{}
\DoxyCodeLine{00102         threadsV.push\_back(\textcolor{keyword}{new} std::thread(\&\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}{Markov::API::MarkovPasswords::GenerateThread}}, \textcolor{keyword}{this}, \&mlock, iterationsPerThread, \&wordlist, minLen, maxLen));}
\DoxyCodeLine{00103     \}}
\DoxyCodeLine{00104 }
\DoxyCodeLine{00105     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<threads;i++)\{}
\DoxyCodeLine{00106         threadsV[i]-\/>join();}
\DoxyCodeLine{00107         \textcolor{keyword}{delete} threadsV[i];}
\DoxyCodeLine{00108     \}}
\DoxyCodeLine{00109 }
\DoxyCodeLine{00110     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}{GenerateThread}}(\&mlock, iterationsCarryOver, \&wordlist, minLen, maxLen);}
\DoxyCodeLine{00111     }
\DoxyCodeLine{00112 \}}

\end{DoxyCode}


References \mbox{\hyperlink{markov_passwords_8cpp_source_l00114}{Generate\+Thread()}}.



Referenced by \mbox{\hyperlink{markopy_8cpp_source_l00011}{Markov\+::\+Markopy\+::\+B\+O\+O\+S\+T\+\_\+\+P\+Y\+T\+H\+O\+N\+\_\+\+M\+O\+D\+U\+L\+E()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!GenerateThread@{GenerateThread}}
\index{GenerateThread@{GenerateThread}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{GenerateThread()}{GenerateThread()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Generate\+Thread (\begin{DoxyParamCaption}\item[{std\+::mutex $\ast$}]{output\+Lock,  }\item[{unsigned long int}]{n,  }\item[{std\+::ofstream $\ast$}]{wordlist,  }\item[{int}]{min\+Len,  }\item[{int}]{max\+Len }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



A single thread invoked by the Generate function. 

{\bfseries{D\+E\+P\+R\+E\+C\+A\+T\+ED\+:}} See Markov\+::\+A\+P\+I\+::\+Matrix\+Model\+::\+Fast\+Random\+Walk\+Thread for more information. This has been replaced with a much more performance-\/optimized method. Fast\+Random\+Walk will reduce the runtime by \%96.\+5 on average.


\begin{DoxyParams}{Parameters}
{\em output\+Lock} & -\/ shared mutex lock to lock during output operation. Prevents race condition on write. \\
\hline
{\em n} & number of lines to be generated by this thread \\
\hline
{\em wordlist} & wordlistfile \\
\hline
{\em min\+Len} & -\/ Minimum password length to generate \\
\hline
{\em max\+Len} & -\/ Maximum password length to generate \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00114}{114}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00114                                                                                                                                        \{}
\DoxyCodeLine{00115     \textcolor{keywordtype}{char}* res = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[maxLen+5];}
\DoxyCodeLine{00116     \textcolor{keywordflow}{if}(n==0) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00117 }
\DoxyCodeLine{00118     \mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov::Random::Marsaglia}} MarsagliaRandomEngine;}
\DoxyCodeLine{00119     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++) \{}
\DoxyCodeLine{00120         this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{RandomWalk}}(\&MarsagliaRandomEngine, minLen, maxLen, res); }
\DoxyCodeLine{00121         outputLock-\/>lock();}
\DoxyCodeLine{00122         *wordlist << res << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{00123         outputLock-\/>unlock();}
\DoxyCodeLine{00124     \}}
\DoxyCodeLine{00125 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_8h_source_l00292}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Random\+Walk()}}.



Referenced by \mbox{\hyperlink{markov_passwords_8cpp_source_l00092}{Generate()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}\label{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!Import@{Import}}
\index{Import@{Import}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Import (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Open a file to import with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Model\+::\+Import}} with std\+::ifstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Import a file with filename 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.Import(\textcolor{stringliteral}{"test.mdl"});}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{model_8h_source_l00265}{265}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00265                                                               \{}
\DoxyCodeLine{00266     std::ifstream importfile;}
\DoxyCodeLine{00267     importfile.open(filename);}
\DoxyCodeLine{00268     \textcolor{keywordflow}{return} this-\/>\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(\&importfile);}
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}\label{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!Import@{Import}}
\index{Import@{Import}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Import (\begin{DoxyParamCaption}\item[{std\+::ifstream $\ast$}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Import a file to construct the model. 

File contains a list of edges. For more info on the file format, check out the wiki and github readme pages. Format is\+: Left\+\_\+repr;Edge\+Weight;right\+\_\+repr

Iterate over this list, and construct nodes and edges accordingly. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Import a file from ifstream 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{std::ifstream file(\textcolor{stringliteral}{"test.mdl"});}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.Import(\&file);}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{model_8h_source_l00206}{206}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00206                                                         \{}
\DoxyCodeLine{00207     std::string cell;}
\DoxyCodeLine{00208 }
\DoxyCodeLine{00209     \textcolor{keywordtype}{char} src;}
\DoxyCodeLine{00210     \textcolor{keywordtype}{char} target;}
\DoxyCodeLine{00211     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} oc;}
\DoxyCodeLine{00212 }
\DoxyCodeLine{00213     \textcolor{keywordflow}{while} (std::getline(*\mbox{\hyperlink{namespacemodel__2gram_a2c21010331f2adf96f64d1e90d019e76}{f}}, cell)) \{}
\DoxyCodeLine{00214         \textcolor{comment}{//std::cout << "cell: " << cell << std::endl;}}
\DoxyCodeLine{00215         src = cell[0];}
\DoxyCodeLine{00216         target = cell[cell.length() -\/ 1];}
\DoxyCodeLine{00217         \textcolor{keywordtype}{char}* j;}
\DoxyCodeLine{00218         oc = std::strtol(cell.substr(2, cell.length() -\/ 2).c\_str(),\&j,10);}
\DoxyCodeLine{00219         \textcolor{comment}{//std::cout << oc << "\(\backslash\)n";}}
\DoxyCodeLine{00220         \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* srcN;}
\DoxyCodeLine{00221         \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* targetN;}
\DoxyCodeLine{00222         \mbox{\hyperlink{class_markov_1_1_edge}{Markov::Edge<NodeStorageType>}}* e;}
\DoxyCodeLine{00223         \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.find(src) == this-\/>nodes.end()) \{}
\DoxyCodeLine{00224             srcN = \textcolor{keyword}{new} \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}(src);}
\DoxyCodeLine{00225             this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.insert(std::pair<\textcolor{keywordtype}{char}, \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}*>(src, srcN));}
\DoxyCodeLine{00226             \textcolor{comment}{//std::cout << "Creating new node at start.\(\backslash\)n";}}
\DoxyCodeLine{00227         \}}
\DoxyCodeLine{00228         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00229             srcN = this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.find(src)-\/>second;}
\DoxyCodeLine{00230         \}}
\DoxyCodeLine{00231 }
\DoxyCodeLine{00232         \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.find(target) == this-\/>nodes.end()) \{}
\DoxyCodeLine{00233             targetN = \textcolor{keyword}{new} \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}(target);}
\DoxyCodeLine{00234             this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.insert(std::pair<\textcolor{keywordtype}{char}, \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}*>(target, targetN));}
\DoxyCodeLine{00235             \textcolor{comment}{//std::cout << "Creating new node at end.\(\backslash\)n";}}
\DoxyCodeLine{00236         \}}
\DoxyCodeLine{00237         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00238             targetN = this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.find(target)-\/>second;}
\DoxyCodeLine{00239         \}}
\DoxyCodeLine{00240         e = srcN-\/>\mbox{\hyperlink{class_markov_1_1_node_a0e867cddf6b8dd784c36b12aa820fee9}{Link}}(targetN);}
\DoxyCodeLine{00241         e-\/>\mbox{\hyperlink{class_markov_1_1_edge_aa9d6cc6e631f1b515b4db604c96ad4ad}{AdjustEdge}}(oc);}
\DoxyCodeLine{00242         this-\/>\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}}.push\_back(e);}
\DoxyCodeLine{00243 }
\DoxyCodeLine{00244         \textcolor{comment}{//std::cout << int(srcN-\/>NodeValue()) << " -\/-\/" << e-\/>EdgeWeight() << "-\/-\/> " << int(targetN-\/>NodeValue()) << "\(\backslash\)n";}}
\DoxyCodeLine{00245 }
\DoxyCodeLine{00246 }
\DoxyCodeLine{00247     \}}
\DoxyCodeLine{00248 }
\DoxyCodeLine{00249     \textcolor{keywordflow}{for} (std::pair<\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}, \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}*> \textcolor{keyword}{const}\& x : this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}) \{}
\DoxyCodeLine{00250         \textcolor{comment}{//std::cout << "Total edges in EdgesV: " << x.second-\/>edgesV.size() << "\(\backslash\)n"; }}
\DoxyCodeLine{00251         std::sort (x.second-\/>edgesV.begin(), x.second-\/>edgesV.end(), [](Edge<NodeStorageType> *lhs, Edge<NodeStorageType> *rhs)-\/>bool\{}
\DoxyCodeLine{00252             return lhs-\/>EdgeWeight() > rhs-\/>EdgeWeight();}
\DoxyCodeLine{00253         \});}
\DoxyCodeLine{00254         \textcolor{comment}{//for(int i=0;i<x.second-\/>edgesV.size();i++)}}
\DoxyCodeLine{00255         \textcolor{comment}{//  std::cout << x.second-\/>edgesV[i]-\/>EdgeWeight() << ", ";}}
\DoxyCodeLine{00256         \textcolor{comment}{//std::cout << "\(\backslash\)n";}}
\DoxyCodeLine{00257     \}}
\DoxyCodeLine{00258     \textcolor{comment}{//std::cout << "Total number of nodes: " << this-\/>nodes.size() << std::endl;}}
\DoxyCodeLine{00259     \textcolor{comment}{//std::cout << "Total number of edges: " << this-\/>edges.size() << std::endl;}}
\DoxyCodeLine{00260 }
\DoxyCodeLine{00261     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00262 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}\label{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!Nodes@{Nodes}}
\index{Nodes@{Nodes}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{Nodes()}{Nodes()}}
{\footnotesize\ttfamily std\+::map$<$char , \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$char $>$$\ast$$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Nodes\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [inherited]}}



Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. 

\begin{DoxyReturn}{Returns}
starter node with 00 Node\+Value 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_8h_source_l00177}{177}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00177 \{ \textcolor{keywordflow}{return} \&\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}};\}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_ac3fb665ee48937ca845d930e72e07917}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_ac3fb665ee48937ca845d930e72e07917}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!OpenDatasetFile@{OpenDatasetFile}}
\index{OpenDatasetFile@{OpenDatasetFile}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{OpenDatasetFile()}{OpenDatasetFile()}}
{\footnotesize\ttfamily std\+::ifstream $\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Open\+Dataset\+File (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Open dataset file and return the ifstream pointer. 


\begin{DoxyParams}{Parameters}
{\em filename} & -\/ Filename to open \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
ifstream$\ast$ to the the dataset file 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00027}{27}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00027                                                                           \{}
\DoxyCodeLine{00028 }
\DoxyCodeLine{00029     std::ifstream* \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}{datasetFile}};}
\DoxyCodeLine{00030 }
\DoxyCodeLine{00031     std::ifstream newFile(filename);}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033     \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}{datasetFile}} = \&newFile;}
\DoxyCodeLine{00034 }
\DoxyCodeLine{00035     this-\/>\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(datasetFile);}
\DoxyCodeLine{00036     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}{datasetFile}};}
\DoxyCodeLine{00037 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_8h_source_l00206}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Import()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_ac3fb665ee48937ca845d930e72e07917_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}\label{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!RandomWalk@{RandomWalk}}
\index{RandomWalk@{RandomWalk}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{RandomWalk()}{RandomWalk()}}
{\footnotesize\ttfamily char  $\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Random\+Walk (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{Markov\+::\+Random\+::\+Random\+Engine}} $\ast$}]{random\+Engine,  }\item[{int}]{min\+Setting,  }\item[{int}]{max\+Setting,  }\item[{char  $\ast$}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Do a random walk on this model. 

Start from the starter node, on each node, invoke Random\+Next using the random engine on current node, until terminator node is reached. If terminator node is reached before minimum length criateria is reached, ignore the last selection and re-\/invoke random\+Next

If maximum length criteria is reached but final node is not, cut off the generation and proceed to the final node. This function takes \mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{Markov\+::\+Random\+::\+Random\+Engine}} as a parameter to generate pseudo random numbers from

This library is shipped with two random engines, Marsaglia and Mersenne. While mersenne output is higher in entropy, most use cases don\textquotesingle{}t really need super high entropy output, so \mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov\+::\+Random\+::\+Marsaglia}} is preferable for better performance.

This function W\+I\+LL N\+OT reallocate buffer. Make sure no out of bound writes are happening via maximum length criteria.

{\bfseries{Example}} {\bfseries{Use\+:}} Generate 10 lines, with 5 to 10 characters, and print the output. Use Marsaglia 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}{Model}}.import(\textcolor{stringliteral}{"model.mdl"});}
\DoxyCodeLine{\textcolor{keywordtype}{char}* res = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[11];}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov::Random::Marsaglia}} MarsagliaRandomEngine;}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 10; i++) \{}
\DoxyCodeLine{    this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{RandomWalk}}(\&MarsagliaRandomEngine, 5, 10, res); }
\DoxyCodeLine{    std::cout << res << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{ \}}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em random\+Engine} & \mbox{\hyperlink{namespace_markov_1_1_random}{Random}} Engine to use for the random walks. For examples, see \mbox{\hyperlink{class_markov_1_1_random_1_1_mersenne}{Markov\+::\+Random\+::\+Mersenne}} and \mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov\+::\+Random\+::\+Marsaglia}} \\
\hline
{\em min\+Setting} & Minimum number of characters to generate \\
\hline
{\em max\+Setting} & Maximum number of character to generate \\
\hline
{\em buffer} & buffer to write the result to \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Null terminated string that was generated. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_8h_source_l00292}{292}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00292                                                                                                                                                          \{}
\DoxyCodeLine{00293     \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* n = this-\/>\mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starterNode}};}
\DoxyCodeLine{00294     \textcolor{keywordtype}{int} len = 0;}
\DoxyCodeLine{00295     \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* temp\_node;}
\DoxyCodeLine{00296     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{}
\DoxyCodeLine{00297         temp\_node = n-\/>\mbox{\hyperlink{class_markov_1_1_node_a87224bed22e5da09e0ddb91c681a6b2c}{RandomNext}}(randomEngine);}
\DoxyCodeLine{00298         \textcolor{keywordflow}{if} (len >= maxSetting) \{}
\DoxyCodeLine{00299             \textcolor{keywordflow}{break};}
\DoxyCodeLine{00300         \}}
\DoxyCodeLine{00301         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((temp\_node == NULL) \&\& (len < minSetting)) \{}
\DoxyCodeLine{00302             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00303         \}}
\DoxyCodeLine{00304 }
\DoxyCodeLine{00305         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (temp\_node == NULL)\{}
\DoxyCodeLine{00306             \textcolor{keywordflow}{break};}
\DoxyCodeLine{00307         \}}
\DoxyCodeLine{00308             }
\DoxyCodeLine{00309         n = temp\_node;}
\DoxyCodeLine{00310 }
\DoxyCodeLine{00311         buffer[len++] = n-\/>\mbox{\hyperlink{class_markov_1_1_node_ac7cce56376f2a00764f64a0194cbb498}{NodeValue}}();}
\DoxyCodeLine{00312     \}}
\DoxyCodeLine{00313 }
\DoxyCodeLine{00314     \textcolor{comment}{//null terminate the string}}
\DoxyCodeLine{00315     buffer[len] = 0x00;}
\DoxyCodeLine{00316 }
\DoxyCodeLine{00317     \textcolor{comment}{//do something with the generated string}}
\DoxyCodeLine{00318     \textcolor{keywordflow}{return} buffer; \textcolor{comment}{//for now}}
\DoxyCodeLine{00319 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_a4f4997da3a6cd3bd2717ce9759736660}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_a4f4997da3a6cd3bd2717ce9759736660}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!Save@{Save}}
\index{Save@{Save}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{Save()}{Save()}}
{\footnotesize\ttfamily std\+::ofstream $\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Save (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Export model to file. 


\begin{DoxyParams}{Parameters}
{\em filename} & -\/ Export filename. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::ofstream$\ast$ of the exported file. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00080}{80}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00080                                                                 \{}
\DoxyCodeLine{00081     std::ofstream* exportFile;}
\DoxyCodeLine{00082 }
\DoxyCodeLine{00083     std::ofstream newFile(filename);}
\DoxyCodeLine{00084 }
\DoxyCodeLine{00085     exportFile = \&newFile;}
\DoxyCodeLine{00086     }
\DoxyCodeLine{00087     this-\/>\mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}}(exportFile);}
\DoxyCodeLine{00088     \textcolor{keywordflow}{return} exportFile;}
\DoxyCodeLine{00089 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_8h_source_l00273}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Export()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a4f4997da3a6cd3bd2717ce9759736660_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}\label{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!StarterNode@{StarterNode}}
\index{StarterNode@{StarterNode}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{StarterNode()}{StarterNode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$char $>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Starter\+Node\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [inherited]}}



Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. 

\begin{DoxyReturn}{Returns}
starter node with 00 Node\+Value 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_8h_source_l00167}{167}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00167 \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starterNode}};\}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!Train@{Train}}
\index{Train@{Train}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{Train()}{Train()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Train (\begin{DoxyParamCaption}\item[{const char $\ast$}]{dataset\+File\+Name,  }\item[{char}]{delimiter,  }\item[{int}]{threads }\end{DoxyParamCaption})}



Train the model with the dataset file. 


\begin{DoxyParams}{Parameters}
{\em dataset\+File\+Name} & -\/ Ifstream$\ast$ to the dataset. If null, use class member \\
\hline
{\em delimiter} & -\/ a character, same as the delimiter in dataset content \\
\hline
{\em threads} & -\/ number of OS threads to spawn\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords}{Markov::API::MarkovPasswords}} mp;}
\DoxyCodeLine{mp.\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(\textcolor{stringliteral}{"models/2gram.mdl"});}
\DoxyCodeLine{mp.\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2}{Train}}(\textcolor{stringliteral}{"password.corpus"});}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00040}{40}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00040                                                                                                \{}
\DoxyCodeLine{00041     \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler}{Markov::API::Concurrency::ThreadSharedListHandler}} listhandler(datasetFileName);}
\DoxyCodeLine{00042     \textcolor{keyword}{auto} start = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{00043 }
\DoxyCodeLine{00044     std::vector<std::thread*> threadsV;}
\DoxyCodeLine{00045     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<threads;i++)\{}
\DoxyCodeLine{00046         threadsV.push\_back(\textcolor{keyword}{new} std::thread(\&\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e}{Markov::API::MarkovPasswords::TrainThread}}, \textcolor{keyword}{this}, \&listhandler, delimiter));}
\DoxyCodeLine{00047     \}}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<threads;i++)\{}
\DoxyCodeLine{00050         threadsV[i]-\/>join();}
\DoxyCodeLine{00051         \textcolor{keyword}{delete} threadsV[i];}
\DoxyCodeLine{00052     \}}
\DoxyCodeLine{00053     \textcolor{keyword}{auto} finish = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{00054     std::chrono::duration<double> elapsed = finish -\/ start;}
\DoxyCodeLine{00055     std::cout << \textcolor{stringliteral}{"Elapsed time: "} << elapsed.count() << \textcolor{stringliteral}{" s\(\backslash\)n"};}
\DoxyCodeLine{00056 }
\DoxyCodeLine{00057 \}}

\end{DoxyCode}


References \mbox{\hyperlink{thread_shared_list_handler_8cpp_source_l00004}{Markov\+::\+A\+P\+I\+::\+Concurrency\+::\+Thread\+Shared\+List\+Handler\+::\+Thread\+Shared\+List\+Handler()}}, and \mbox{\hyperlink{markov_passwords_8cpp_source_l00059}{Train\+Thread()}}.



Referenced by \mbox{\hyperlink{markopy_8cpp_source_l00011}{Markov\+::\+Markopy\+::\+B\+O\+O\+S\+T\+\_\+\+P\+Y\+T\+H\+O\+N\+\_\+\+M\+O\+D\+U\+L\+E()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!TrainThread@{TrainThread}}
\index{TrainThread@{TrainThread}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{TrainThread()}{TrainThread()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Train\+Thread (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler}{Markov\+::\+A\+P\+I\+::\+Concurrency\+::\+Thread\+Shared\+List\+Handler}} $\ast$}]{listhandler,  }\item[{char}]{delimiter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



A single thread invoked by the Train function. 


\begin{DoxyParams}{Parameters}
{\em listhandler} & -\/ Listhandler class to read corpus from \\
\hline
{\em delimiter} & -\/ a character, same as the delimiter in dataset content \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00059}{59}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00059                                                                                                                   \{}
\DoxyCodeLine{00060     \textcolor{keywordtype}{char} format\_str[] =\textcolor{stringliteral}{"\%ld,\%s"};}
\DoxyCodeLine{00061     format\_str[2]=delimiter;}
\DoxyCodeLine{00062     std::string line;}
\DoxyCodeLine{00063     \textcolor{keywordflow}{while} (listhandler-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler_a068e1a9ff477de23a44c10230df416a5}{next}}(\&line)) \{}
\DoxyCodeLine{00064         \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} oc;}
\DoxyCodeLine{00065         \textcolor{keywordflow}{if} (line.size() > 100) \{}
\DoxyCodeLine{00066             line = line.substr(0, 100);}
\DoxyCodeLine{00067         \}}
\DoxyCodeLine{00068         \textcolor{keywordtype}{char}* linebuf = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[line.length()+5];}
\DoxyCodeLine{00069 \textcolor{preprocessor}{\#ifdef \_WIN32}}
\DoxyCodeLine{00070         sscanf\_s(line.c\_str(), format\_str, \&oc, linebuf, line.length()+5);}
\DoxyCodeLine{00071 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00072         sscanf(line.c\_str(), format\_str, \&oc, linebuf);}
\DoxyCodeLine{00073 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00074         this-\/>\mbox{\hyperlink{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}{AdjustEdge}}((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)linebuf, oc); }
\DoxyCodeLine{00075         \textcolor{keyword}{delete} linebuf;}
\DoxyCodeLine{00076     \}}
\DoxyCodeLine{00077 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_8h_source_l00322}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Adjust\+Edge()}}, and \mbox{\hyperlink{thread_shared_list_handler_8cpp_source_l00010}{Markov\+::\+A\+P\+I\+::\+Concurrency\+::\+Thread\+Shared\+List\+Handler\+::next()}}.



Referenced by \mbox{\hyperlink{markov_passwords_8cpp_source_l00040}{Train()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e_icgraph}
\end{center}
\end{figure}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!datasetFile@{datasetFile}}
\index{datasetFile@{datasetFile}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{datasetFile}{datasetFile}}
{\footnotesize\ttfamily std\+::ifstream$\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::dataset\+File\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{markov_passwords_8h_source_l00106}{106}} of file \mbox{\hyperlink{markov_passwords_8h_source}{markov\+Passwords.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}\label{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!edges@{edges}}
\index{edges@{edges}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{edges}{edges}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$char $>$$\ast$$>$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::edges\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



A list of all edges in this model. 



Definition at line \mbox{\hyperlink{model_8h_source_l00194}{194}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_af5f012dcc495dbe769e663d6cb161d6a}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_af5f012dcc495dbe769e663d6cb161d6a}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!modelSavefile@{modelSavefile}}
\index{modelSavefile@{modelSavefile}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{modelSavefile}{modelSavefile}}
{\footnotesize\ttfamily std\+::ofstream$\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::model\+Savefile\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{markov_passwords_8h_source_l00107}{107}} of file \mbox{\hyperlink{markov_passwords_8h_source}{markov\+Passwords.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}\label{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!nodes@{nodes}}
\index{nodes@{nodes}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{nodes}{nodes}}
{\footnotesize\ttfamily std\+::map$<$char , \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$char $>$$\ast$$>$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::nodes\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



Map Left\+Node is the Nodes Node\+Value Map Right\+Node is the node pointer. 



Definition at line \mbox{\hyperlink{model_8h_source_l00183}{183}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_ac05e60de64e866027410d4fa1cd03248}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_ac05e60de64e866027410d4fa1cd03248}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!outputFile@{outputFile}}
\index{outputFile@{outputFile}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{outputFile}{outputFile}}
{\footnotesize\ttfamily std\+::ofstream$\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::output\+File\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{markov_passwords_8h_source_l00108}{108}} of file \mbox{\hyperlink{markov_passwords_8h_source}{markov\+Passwords.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}\label{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}} 
\index{Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}!starterNode@{starterNode}}
\index{starterNode@{starterNode}!Markov::API::MarkovPasswords@{Markov::API::MarkovPasswords}}
\doxysubsubsection{\texorpdfstring{starterNode}{starterNode}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$char $>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::starter\+Node\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



Starter \mbox{\hyperlink{class_markov_1_1_node}{Node}} of this model. 



Definition at line \mbox{\hyperlink{model_8h_source_l00188}{188}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{markov_passwords_8h}{markov\+Passwords.\+h}}\item 
\mbox{\hyperlink{markov_passwords_8cpp}{markov\+Passwords.\+cpp}}\end{DoxyCompactItemize}
