\hypertarget{class_markov_1_1_model}{}\doxysection{Markov\+::Model$<$ Node\+Storage\+Type $>$ Class Template Reference}
\label{class_markov_1_1_model}\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}


class for the final \mbox{\hyperlink{namespace_markov}{Markov}} \mbox{\hyperlink{class_markov_1_1_model}{Model}}, constructed from nodes and edges.  


\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_markov_1_1_model_a593b1dc98082221e3f69636e3a087dfd}\label{class_markov_1_1_model_a593b1dc98082221e3f69636e3a087dfd}} 
\mbox{\hyperlink{class_markov_1_1_model_a593b1dc98082221e3f69636e3a087dfd}{Markov\+::\+Model}} ()
\begin{DoxyCompactList}\small\item\em Initialize a model with only start and end nodes. \end{DoxyCompactList}\item 
Node\+Storage\+Type $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a2e0249e4630353a260e06b8f3a72f5bb}{Random\+Walk}} ()
\begin{DoxyCompactList}\small\item\em Do a random walk on this model. Start from the starter node, invoke Random\+Next on current node until terminator node is reached. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_model_abb14649eb59af2b60d17400e3c1d827b}{adjust}} (Node\+Storage\+Type $\ast$payload, long int occurrence)
\begin{DoxyCompactList}\small\item\em Adjust the model with a single string. Start from the starter node, and for each character, adjust the edge weight from current node to the next, until NULL character is reached. Then, update the edge weight from current node, to the terminator node. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}} (std\+::ifstream $\ast$)
\begin{DoxyCompactList}\small\item\em Import a file to construct the model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}{Import}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to import with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Markov\+::\+Model\+::\+Import}} with std\+::ifstream. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}} (std\+::ofstream $\ast$)
\begin{DoxyCompactList}\small\item\em Export a file of the model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}{Export}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to export with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Markov\+::\+Model\+::\+Export}} with std\+::ofstream. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ Node\+Storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a62954b990ae10a74dcc543682abf3315}{Starter\+Node}} ()
\begin{DoxyCompactList}\small\item\em Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_markov_1_1_model_a647b2a8065393938c84e28b8e0e4874e}\label{class_markov_1_1_model_a647b2a8065393938c84e28b8e0e4874e}} 
std\+::vector$<$ \mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ Node\+Storage\+Type $>$ $>$ $\ast$ {\bfseries Edges} ()
\item 
\mbox{\Hypertarget{class_markov_1_1_model_acc0161496b713014342e21f6134fce3c}\label{class_markov_1_1_model_acc0161496b713014342e21f6134fce3c}} 
std\+::map$<$ Node\+Storage\+Type, \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ Node\+Storage\+Type $>$ $\ast$ $>$ $\ast$ {\bfseries Nodes} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Node\+Storage\+Type$>$\newline
class Markov\+::\+Model$<$ Node\+Storage\+Type $>$}

class for the final \mbox{\hyperlink{namespace_markov}{Markov}} \mbox{\hyperlink{class_markov_1_1_model}{Model}}, constructed from nodes and edges. 

This class will be {\itshape templated later to work with other data types than char}. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_markov_1_1_model_abb14649eb59af2b60d17400e3c1d827b}\label{class_markov_1_1_model_abb14649eb59af2b60d17400e3c1d827b}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!adjust@{adjust}}
\index{adjust@{adjust}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{adjust()}{adjust()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
void \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::adjust (\begin{DoxyParamCaption}\item[{Node\+Storage\+Type $\ast$}]{payload,  }\item[{long int}]{occurrence }\end{DoxyParamCaption})}



Adjust the model with a single string. Start from the starter node, and for each character, adjust the edge weight from current node to the next, until NULL character is reached. Then, update the edge weight from current node, to the terminator node. 


\begin{DoxyParams}{Parameters}
{\em string} & -\/ String that is passed from the training, and will be used to adjust the model with \\
\hline
{\em occurrence} & -\/ Occurrence of this string. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}\label{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Export@{Export}}
\index{Export@{Export}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Export (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Open a file to export with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Markov\+::\+Model\+::\+Export}} with std\+::ofstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}\label{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Export@{Export}}
\index{Export@{Export}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Export (\begin{DoxyParamCaption}\item[{std\+::ofstream $\ast$}]{f }\end{DoxyParamCaption})}



Export a file of the model. 

File contains a list of edges. Format is\+: Left\+\_\+repr;weight;right\+\_\+repr Iterate over this vertices, and their edges, and write them to file. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}\label{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Import@{Import}}
\index{Import@{Import}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Import (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Open a file to import with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Markov\+::\+Model\+::\+Import}} with std\+::ifstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}\label{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Import@{Import}}
\index{Import@{Import}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Import (\begin{DoxyParamCaption}\item[{std\+::ifstream $\ast$}]{f }\end{DoxyParamCaption})}



Import a file to construct the model. 

File contains a list of edges. Format is\+: Left\+\_\+repr;weight;right\+\_\+repr Iterate over this list, and construct nodes and edges accordingly. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_a2e0249e4630353a260e06b8f3a72f5bb}\label{class_markov_1_1_model_a2e0249e4630353a260e06b8f3a72f5bb}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!RandomWalk@{RandomWalk}}
\index{RandomWalk@{RandomWalk}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{RandomWalk()}{RandomWalk()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
Node\+Storage\+Type $\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Random\+Walk}



Do a random walk on this model. Start from the starter node, invoke Random\+Next on current node until terminator node is reached. 

\begin{DoxyReturn}{Returns}
Null terminated string that was generated. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_a62954b990ae10a74dcc543682abf3315}\label{class_markov_1_1_model_a62954b990ae10a74dcc543682abf3315}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!StarterNode@{StarterNode}}
\index{StarterNode@{StarterNode}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{StarterNode()}{StarterNode()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$Node\+Storage\+Type$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Starter\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. 

\begin{DoxyReturn}{Returns}
starter node with 00 value 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
D\+:/\+Repositories/\+Markov\+Passwords/\+Win-\/visualstudio/\+Markov\+Model/src/model.\+h\item 
D\+:/\+Repositories/\+Markov\+Passwords/\+Win-\/visualstudio/\+Markov\+Model/src/model.\+cpp\end{DoxyCompactItemize}
