\hypertarget{model_8h_source}{}\doxysection{model.\+h}
\label{model_8h_source}\index{model.h@{model.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{/** @dir Model.h}}
\DoxyCodeLine{00002 \textcolor{comment}{ *}}
\DoxyCodeLine{00003 \textcolor{comment}{ */}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 }
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#}\textcolor{preprocessor}{pragma} \textcolor{preprocessor}{once}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{map}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{vector}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{fstream}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00010 \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{assert}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00011 \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00012 \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{algorithm}\textcolor{preprocessor}{>}}
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include} \mbox{\hyperlink{node_8h}{"node.h"}}}
\DoxyCodeLine{00014 \textcolor{preprocessor}{\#}\textcolor{preprocessor}{include} \mbox{\hyperlink{edge_8h}{"edge.h"}}}
\DoxyCodeLine{00015 }
\DoxyCodeLine{00016 \textcolor{comment}{/**}}
\DoxyCodeLine{00017 \textcolor{comment}{    @brief Namespace for the markov-\/model related classes. }}
\DoxyCodeLine{00018 \textcolor{comment}{    Contains Model, Node and Edge classes}}
\DoxyCodeLine{00019 \textcolor{comment}{*/}}
\DoxyCodeLine{00020 \textcolor{keyword}{namespace} Markov \{}
\DoxyCodeLine{00021 }
\DoxyCodeLine{00022     \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00023}\mbox{\hyperlink{class_markov_1_1_node}{00023}}     \textcolor{keyword}{class} Node;}
\DoxyCodeLine{00024 }
\DoxyCodeLine{00025     \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00026}\mbox{\hyperlink{class_markov_1_1_edge}{00026}}     \textcolor{keyword}{class} Edge;}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028     \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{00029 }
\DoxyCodeLine{00030     \textcolor{comment}{/** @brief class for the final Markov Model, constructed from nodes and edges.}}
\DoxyCodeLine{00031 \textcolor{comment}{     * }}
\DoxyCodeLine{00032 \textcolor{comment}{     * Each atomic piece of the generation result is stored in a node, while edges contain the relation weights.}}
\DoxyCodeLine{00033 \textcolor{comment}{     * *Extending:*}}
\DoxyCodeLine{00034 \textcolor{comment}{     * To extend the class, implement the template and inherit from it, as "class MyModel : public Markov::Model<char>". }}
\DoxyCodeLine{00035 \textcolor{comment}{     * For a complete demonstration of how to extend the class, see MarkovPasswords.}}
\DoxyCodeLine{00036 \textcolor{comment}{     *}}
\DoxyCodeLine{00037 \textcolor{comment}{     * Whole model can be defined as a list of the edges, as dangling nodes are pointless. This approach is used for the import/export operations.}}
\DoxyCodeLine{00038 \textcolor{comment}{     * For more information on importing/exporting model, check out the github readme and wiki page.}}
\DoxyCodeLine{00039 \textcolor{comment}{     * }}
\DoxyCodeLine{00040 \textcolor{comment}{    */}}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00041}\mbox{\hyperlink{class_markov_1_1_model}{00041}}     \textcolor{keyword}{class} \mbox{\hyperlink{class_markov_1_1_model}{Model}} \{}
\DoxyCodeLine{00042     \textcolor{keyword}{public}:}
\DoxyCodeLine{00043 }
\DoxyCodeLine{00044         \textcolor{comment}{/** @brief Initialize a model with only start and end nodes.}}
\DoxyCodeLine{00045 \textcolor{comment}{         * }}
\DoxyCodeLine{00046 \textcolor{comment}{         * Initialize an empty model with only a starterNode}}
\DoxyCodeLine{00047 \textcolor{comment}{         * Starter node is a special kind of node that has constant 0x00 value, and will be used to initiate the generation execution from.}}
\DoxyCodeLine{00048 \textcolor{comment}{        */}}
\DoxyCodeLine{00049         Model<NodeStorageType>();}
\DoxyCodeLine{00050 }
\DoxyCodeLine{00051         \textcolor{comment}{/** @brief Do a random walk on this model. }}
\DoxyCodeLine{00052 \textcolor{comment}{         * }}
\DoxyCodeLine{00053 \textcolor{comment}{         * Start from the starter node, on each node, invoke RandomNext using the random engine on current node, until terminator node is reached.}}
\DoxyCodeLine{00054 \textcolor{comment}{         * If terminator node is reached before minimum length criateria is reached, ignore the last selection and re-\/invoke randomNext}}
\DoxyCodeLine{00055 \textcolor{comment}{         * }}
\DoxyCodeLine{00056 \textcolor{comment}{         * If maximum length criteria is reached but final node is not, cut off the generation and proceed to the final node.}}
\DoxyCodeLine{00057 \textcolor{comment}{         * This function takes Markov::Random::RandomEngine as a parameter to generate pseudo random numbers from}}
\DoxyCodeLine{00058 \textcolor{comment}{         * }}
\DoxyCodeLine{00059 \textcolor{comment}{         * This library is shipped with two random engines, Marsaglia and Mersenne. While mersenne output is higher in entropy, most use cases}}
\DoxyCodeLine{00060 \textcolor{comment}{         * don't really need super high entropy output, so Markov::Random::Marsaglia is preferable for better performance.}}
\DoxyCodeLine{00061 \textcolor{comment}{         * }}
\DoxyCodeLine{00062 \textcolor{comment}{         * This function WILL NOT reallocate buffer. Make sure no out of bound writes are happening via maximum length criteria.}}
\DoxyCodeLine{00063 \textcolor{comment}{         * }}
\DoxyCodeLine{00064 \textcolor{comment}{         * @b Example @b Use: Generate 10 lines, with 5 to 10 characters, and print the output. Use Marsaglia}}
\DoxyCodeLine{00065 \textcolor{comment}{         * @code\{.cpp\}}}
\DoxyCodeLine{00066 \textcolor{comment}{         * Markov::Model<char> model;}}
\DoxyCodeLine{00067 \textcolor{comment}{         * Model.import("model.mdl");}}
\DoxyCodeLine{00068 \textcolor{comment}{         * char* res = new char[11];}}
\DoxyCodeLine{00069 \textcolor{comment}{         * Markov::Random::Marsaglia MarsagliaRandomEngine;}}
\DoxyCodeLine{00070 \textcolor{comment}{         * for (int i = 0; i < 10; i++) \{}}
\DoxyCodeLine{00071 \textcolor{comment}{         *      this-\/>RandomWalk(\&MarsagliaRandomEngine, 5, 10, res); }}
\DoxyCodeLine{00072 \textcolor{comment}{         *      std::cout << res << "\(\backslash\)n";}}
\DoxyCodeLine{00073 \textcolor{comment}{         *  \}}}
\DoxyCodeLine{00074 \textcolor{comment}{         * @endcode}}
\DoxyCodeLine{00075 \textcolor{comment}{         * }}
\DoxyCodeLine{00076 \textcolor{comment}{         * @param randomEngine Random Engine to use for the random walks. For examples, see Markov::Random::Mersenne and Markov::Random::Marsaglia}}
\DoxyCodeLine{00077 \textcolor{comment}{         * @param minSetting Minimum number of characters to generate}}
\DoxyCodeLine{00078 \textcolor{comment}{         * @param maxSetting Maximum number of character to generate}}
\DoxyCodeLine{00079 \textcolor{comment}{         * @param buffer buffer to write the result to}}
\DoxyCodeLine{00080 \textcolor{comment}{         * @return Null terminated string that was generated.}}
\DoxyCodeLine{00081 \textcolor{comment}{        */}}
\DoxyCodeLine{00082         NodeStorageType* \mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{RandomWalk}}(Markov::\mbox{\hyperlink{namespace_markov_1_1_random}{Random}}::\mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{RandomEngine}}* randomEngine, \textcolor{keywordtype}{int} minSetting, \textcolor{keywordtype}{int} maxSetting, NodeStorageType* buffer);}
\DoxyCodeLine{00083 }
\DoxyCodeLine{00084         \textcolor{comment}{/** @brief Adjust the model with a single string. }}
\DoxyCodeLine{00085 \textcolor{comment}{         * }}
\DoxyCodeLine{00086 \textcolor{comment}{         * Start from the starter node, and for each character, AdjustEdge the edge EdgeWeight from current node to the next, until NULL character is reached.}}
\DoxyCodeLine{00087 \textcolor{comment}{         * }}
\DoxyCodeLine{00088 \textcolor{comment}{         * Then, update the edge EdgeWeight from current node, to the terminator node.}}
\DoxyCodeLine{00089 \textcolor{comment}{         * }}
\DoxyCodeLine{00090 \textcolor{comment}{         * This function is used for training purposes, as it can be used for adjusting the model with each line of the corpus file.}}
\DoxyCodeLine{00091 \textcolor{comment}{         * }}
\DoxyCodeLine{00092 \textcolor{comment}{         * @b Example @b Use: Create an empty model and train it with string: "testdata"}}
\DoxyCodeLine{00093 \textcolor{comment}{         * @code\{.cpp\}}}
\DoxyCodeLine{00094 \textcolor{comment}{         * Markov::Model<char> model;}}
\DoxyCodeLine{00095 \textcolor{comment}{         * char test[] = "testdata";}}
\DoxyCodeLine{00096 \textcolor{comment}{         * model.AdjustEdge(test, 15); }}
\DoxyCodeLine{00097 \textcolor{comment}{         * @endcode}}
\DoxyCodeLine{00098 \textcolor{comment}{         * }}
\DoxyCodeLine{00099 \textcolor{comment}{         * }}
\DoxyCodeLine{00100 \textcolor{comment}{         * @param string -\/ String that is passed from the training, and will be used to AdjustEdge the model with}}
\DoxyCodeLine{00101 \textcolor{comment}{         * @param occurrence -\/ Occurrence of this string. }}
\DoxyCodeLine{00102 \textcolor{comment}{         * }}
\DoxyCodeLine{00103 \textcolor{comment}{         * }}
\DoxyCodeLine{00104 \textcolor{comment}{        */}}
\DoxyCodeLine{00105         \textcolor{keywordtype}{void} \mbox{\hyperlink{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}{AdjustEdge}}(\textcolor{keyword}{const} NodeStorageType* payload, \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} occurrence);}
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107         \textcolor{comment}{/** @brief Import a file to construct the model. }}
\DoxyCodeLine{00108 \textcolor{comment}{         * }}
\DoxyCodeLine{00109 \textcolor{comment}{         * File contains a list of edges. For more info on the file format, check out the wiki and github readme pages.}}
\DoxyCodeLine{00110 \textcolor{comment}{         * Format is: Left\_repr;EdgeWeight;right\_repr}}
\DoxyCodeLine{00111 \textcolor{comment}{         * }}
\DoxyCodeLine{00112 \textcolor{comment}{         * Iterate over this list, and construct nodes and edges accordingly. }}
\DoxyCodeLine{00113 \textcolor{comment}{         * @return True if successful, False for incomplete models or corrupt file formats}}
\DoxyCodeLine{00114 \textcolor{comment}{         * }}
\DoxyCodeLine{00115 \textcolor{comment}{         * @b Example @b Use: Import a file from ifstream}}
\DoxyCodeLine{00116 \textcolor{comment}{         * @code\{.cpp\}}}
\DoxyCodeLine{00117 \textcolor{comment}{         * Markov::Model<char> model;}}
\DoxyCodeLine{00118 \textcolor{comment}{         * std::ifstream file("test.mdl");}}
\DoxyCodeLine{00119 \textcolor{comment}{         * model.Import(\&file);}}
\DoxyCodeLine{00120 \textcolor{comment}{         * @endcode}}
\DoxyCodeLine{00121 \textcolor{comment}{        */}}
\DoxyCodeLine{00122         \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(std::ifstream*);}
\DoxyCodeLine{00123 }
\DoxyCodeLine{00124         \textcolor{comment}{/** @brief Open a file to import with filename, and call bool Model::Import with std::ifstream}}
\DoxyCodeLine{00125 \textcolor{comment}{         * @return True if successful, False for incomplete models or corrupt file formats}}
\DoxyCodeLine{00126 \textcolor{comment}{         * }}
\DoxyCodeLine{00127 \textcolor{comment}{         * @b Example @b Use: Import a file with filename}}
\DoxyCodeLine{00128 \textcolor{comment}{         * @code\{.cpp\}}}
\DoxyCodeLine{00129 \textcolor{comment}{         * Markov::Model<char> model;}}
\DoxyCodeLine{00130 \textcolor{comment}{         * model.Import("test.mdl");}}
\DoxyCodeLine{00131 \textcolor{comment}{         * @endcode}}
\DoxyCodeLine{00132 \textcolor{comment}{        */}}
\DoxyCodeLine{00133         \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}{Import}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename);}
\DoxyCodeLine{00134 }
\DoxyCodeLine{00135         \textcolor{comment}{/** @brief Export a file of the model.}}
\DoxyCodeLine{00136 \textcolor{comment}{         *}}
\DoxyCodeLine{00137 \textcolor{comment}{         * File contains a list of edges.}}
\DoxyCodeLine{00138 \textcolor{comment}{         * Format is: Left\_repr;EdgeWeight;right\_repr.}}
\DoxyCodeLine{00139 \textcolor{comment}{         * For more information on the format, check out the project wiki or github readme.}}
\DoxyCodeLine{00140 \textcolor{comment}{         * }}
\DoxyCodeLine{00141 \textcolor{comment}{         * Iterate over this vertices, and their edges, and write them to file.}}
\DoxyCodeLine{00142 \textcolor{comment}{         * @return True if successful, False for incomplete models.}}
\DoxyCodeLine{00143 \textcolor{comment}{         * }}
\DoxyCodeLine{00144 \textcolor{comment}{         * @b Example @b Use: Export file to ofstream}}
\DoxyCodeLine{00145 \textcolor{comment}{         * @code\{.cpp\}}}
\DoxyCodeLine{00146 \textcolor{comment}{         * Markov::Model<char> model;}}
\DoxyCodeLine{00147 \textcolor{comment}{         * std::ofstream file("test.mdl");}}
\DoxyCodeLine{00148 \textcolor{comment}{         * model.Export(\&file);}}
\DoxyCodeLine{00149 \textcolor{comment}{         * @endcode}}
\DoxyCodeLine{00150 \textcolor{comment}{        */}}
\DoxyCodeLine{00151         \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}}(std::ofstream*);}
\DoxyCodeLine{00152 }
\DoxyCodeLine{00153         \textcolor{comment}{/** @brief Open a file to export with filename, and call bool Model::Export with std::ofstream}}
\DoxyCodeLine{00154 \textcolor{comment}{         * @return True if successful, False for incomplete models or corrupt file formats}}
\DoxyCodeLine{00155 \textcolor{comment}{         * }}
\DoxyCodeLine{00156 \textcolor{comment}{         * @b Example @b Use: Export file to filename}}
\DoxyCodeLine{00157 \textcolor{comment}{         * @code\{.cpp\}}}
\DoxyCodeLine{00158 \textcolor{comment}{         * Markov::Model<char> model;}}
\DoxyCodeLine{00159 \textcolor{comment}{         * model.Export("test.mdl");}}
\DoxyCodeLine{00160 \textcolor{comment}{         * @endcode}}
\DoxyCodeLine{00161 \textcolor{comment}{        */}}
\DoxyCodeLine{00162         \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}{Export}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename);}
\DoxyCodeLine{00163 }
\DoxyCodeLine{00164         \textcolor{comment}{/** @brief Return starter Node}}
\DoxyCodeLine{00165 \textcolor{comment}{         * @return starter node with 00 NodeValue}}
\DoxyCodeLine{00166 \textcolor{comment}{        */}}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00167}\mbox{\hyperlink{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}{00167}}         Node<NodeStorageType>* \mbox{\hyperlink{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}{StarterNode}}()\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starterNode}};\}}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169         \textcolor{comment}{/** @brief Return a vector of all the edges in the model}}
\DoxyCodeLine{00170 \textcolor{comment}{         * @return vector of edges}}
\DoxyCodeLine{00171 \textcolor{comment}{        */}}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00172}\mbox{\hyperlink{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}{00172}}         std::vector<Edge<NodeStorageType>*>* \mbox{\hyperlink{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}{Edges}}()\{ \textcolor{keywordflow}{return} \&\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}};\}}
\DoxyCodeLine{00173 }
\DoxyCodeLine{00174         \textcolor{comment}{/** @brief Return starter Node}}
\DoxyCodeLine{00175 \textcolor{comment}{         * @return starter node with 00 NodeValue}}
\DoxyCodeLine{00176 \textcolor{comment}{        */}}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00177}\mbox{\hyperlink{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}{00177}}         std::map<NodeStorageType, Node<NodeStorageType>*>* \mbox{\hyperlink{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}{Nodes}}()\{ \textcolor{keywordflow}{return} \&\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}};\}}
\DoxyCodeLine{00178 }
\DoxyCodeLine{00179     \textcolor{keyword}{private}:}
\DoxyCodeLine{00180         \textcolor{comment}{/** @brief Map LeftNode is the Nodes NodeValue}}
\DoxyCodeLine{00181 \textcolor{comment}{         * Map RightNode is the node pointer}}
\DoxyCodeLine{00182 \textcolor{comment}{        */}}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00183}\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{00183}}         std::map<NodeStorageType, Node<NodeStorageType>*> \mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}};}
\DoxyCodeLine{00184 }
\DoxyCodeLine{00185         \textcolor{comment}{/** @brief Starter Node of this model. }}
\DoxyCodeLine{00186 \textcolor{comment}{         * }}
\DoxyCodeLine{00187 \textcolor{comment}{        */}}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00188}\mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{00188}}         Node<NodeStorageType>* \mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starterNode}};}
\DoxyCodeLine{00189 }
\DoxyCodeLine{00190 }
\DoxyCodeLine{00191         \textcolor{comment}{/** @brief A list of all edges in this model. }}
\DoxyCodeLine{00192 \textcolor{comment}{         * }}
\DoxyCodeLine{00193 \textcolor{comment}{        */}}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00194}\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{00194}}         std::vector<Edge<NodeStorageType>*> \mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}};}
\DoxyCodeLine{00195     \};}
\DoxyCodeLine{00196 }
\DoxyCodeLine{00197 \};}
\DoxyCodeLine{00198 }
\DoxyCodeLine{00199 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00200}\mbox{\hyperlink{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}{00200}} Markov::\mbox{\hyperlink{class_markov_1_1_model}{Model}}<NodeStorageType>::Model() \{}
\DoxyCodeLine{00201     \textcolor{keyword}{this}-\/>starterNode = \textcolor{keyword}{new} Markov::Node<NodeStorageType>(0);}
\DoxyCodeLine{00202     \textcolor{keyword}{this}-\/>nodes.insert(\{ 0, \textcolor{keyword}{this}-\/>starterNode \});}
\DoxyCodeLine{00203 \}}
\DoxyCodeLine{00204 }
\DoxyCodeLine{00205 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00206}\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{00206}} \textcolor{keywordtype}{bool} Markov::\mbox{\hyperlink{class_markov_1_1_model}{Model}}<NodeStorageType>::\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(std::ifstream* f) \{}
\DoxyCodeLine{00207     std::string cell;}
\DoxyCodeLine{00208 }
\DoxyCodeLine{00209     \textcolor{keywordtype}{char} src;}
\DoxyCodeLine{00210     \textcolor{keywordtype}{char} target;}
\DoxyCodeLine{00211     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} oc;}
\DoxyCodeLine{00212 }
\DoxyCodeLine{00213     \textcolor{keywordflow}{while} (std::getline(*f, cell)) \{}
\DoxyCodeLine{00214         \textcolor{comment}{//std::cout << "cell: " << cell << std::endl;}}
\DoxyCodeLine{00215         src = cell[0];}
\DoxyCodeLine{00216         target = cell[cell.length() -\/ 1];}
\DoxyCodeLine{00217         \textcolor{keywordtype}{char}* j;}
\DoxyCodeLine{00218         oc = std::strtol(cell.substr(2, cell.length() -\/ 2).c\_str(),\&j,10);}
\DoxyCodeLine{00219         \textcolor{comment}{//std::cout << oc << "\(\backslash\)n";}}
\DoxyCodeLine{00220         Markov::Node<NodeStorageType>* srcN;}
\DoxyCodeLine{00221         Markov::Node<NodeStorageType>* targetN;}
\DoxyCodeLine{00222         Markov::Edge<NodeStorageType>* e;}
\DoxyCodeLine{00223         \textcolor{keywordflow}{if} (\textcolor{keyword}{this}-\/>nodes.find(src) == \textcolor{keyword}{this}-\/>nodes.end()) \{}
\DoxyCodeLine{00224             srcN = \textcolor{keyword}{new} Markov::Node<NodeStorageType>(src);}
\DoxyCodeLine{00225             \textcolor{keyword}{this}-\/>nodes.insert(std::pair<\textcolor{keywordtype}{char}, Markov::Node<NodeStorageType>*>(src, srcN));}
\DoxyCodeLine{00226             \textcolor{comment}{//std::cout << "Creating new node at start.\(\backslash\)n";}}
\DoxyCodeLine{00227         \}}
\DoxyCodeLine{00228         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00229             srcN = \textcolor{keyword}{this}-\/>nodes.find(src)-\/>second;}
\DoxyCodeLine{00230         \}}
\DoxyCodeLine{00231 }
\DoxyCodeLine{00232         \textcolor{keywordflow}{if} (\textcolor{keyword}{this}-\/>nodes.find(target) == \textcolor{keyword}{this}-\/>nodes.end()) \{}
\DoxyCodeLine{00233             targetN = \textcolor{keyword}{new} Markov::Node<NodeStorageType>(target);}
\DoxyCodeLine{00234             \textcolor{keyword}{this}-\/>nodes.insert(std::pair<\textcolor{keywordtype}{char}, Markov::Node<NodeStorageType>*>(target, targetN));}
\DoxyCodeLine{00235             \textcolor{comment}{//std::cout << "Creating new node at end.\(\backslash\)n";}}
\DoxyCodeLine{00236         \}}
\DoxyCodeLine{00237         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00238             targetN = \textcolor{keyword}{this}-\/>nodes.find(target)-\/>second;}
\DoxyCodeLine{00239         \}}
\DoxyCodeLine{00240         e = srcN-\/>Link(targetN);}
\DoxyCodeLine{00241         e-\/>AdjustEdge(oc);}
\DoxyCodeLine{00242         \textcolor{keyword}{this}-\/>edges.push\_back(e);}
\DoxyCodeLine{00243 }
\DoxyCodeLine{00244         \textcolor{comment}{//std::cout << int(srcN-\/>NodeValue()) << " -\/-\/" << e-\/>EdgeWeight() << "-\/-\/> " << int(targetN-\/>NodeValue()) << "\(\backslash\)n";}}
\DoxyCodeLine{00245 }
\DoxyCodeLine{00246 }
\DoxyCodeLine{00247     \}}
\DoxyCodeLine{00248 }
\DoxyCodeLine{00249     \textcolor{keywordflow}{for} (std::pair<\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}, Markov::Node<NodeStorageType>*> \textcolor{keyword}{const}\& x : \textcolor{keyword}{this}-\/>nodes) \{}
\DoxyCodeLine{00250         \textcolor{comment}{//std::cout << "Total edges in EdgesV: " << x.second-\/>edgesV.size() << "\(\backslash\)n"; }}
\DoxyCodeLine{00251         std::sort (x.second-\/>edgesV.begin(), x.second-\/>edgesV.end(), [](Edge<NodeStorageType> *lhs, Edge<NodeStorageType> *rhs)-\/>\textcolor{keywordtype}{bool}\{}
\DoxyCodeLine{00252             \textcolor{keywordflow}{return} lhs-\/>EdgeWeight() > rhs-\/>EdgeWeight();}
\DoxyCodeLine{00253         \});}
\DoxyCodeLine{00254         \textcolor{comment}{//for(int i=0;i<x.second-\/>edgesV.size();i++)}}
\DoxyCodeLine{00255         \textcolor{comment}{//  std::cout << x.second-\/>edgesV[i]-\/>EdgeWeight() << ", ";}}
\DoxyCodeLine{00256         \textcolor{comment}{//std::cout << "\(\backslash\)n";}}
\DoxyCodeLine{00257     \}}
\DoxyCodeLine{00258     \textcolor{comment}{//std::cout << "Total number of nodes: " << this-\/>nodes.size() << std::endl;}}
\DoxyCodeLine{00259     \textcolor{comment}{//std::cout << "Total number of edges: " << this-\/>edges.size() << std::endl;}}
\DoxyCodeLine{00260 }
\DoxyCodeLine{00261     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00262 \}}
\DoxyCodeLine{00263 }
\DoxyCodeLine{00264 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00265}\mbox{\hyperlink{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}{00265}} \textcolor{keywordtype}{bool} Markov::\mbox{\hyperlink{class_markov_1_1_model}{Model}}<NodeStorageType>::\mbox{\hyperlink{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}{Import}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename) \{}
\DoxyCodeLine{00266     std::ifstream importfile;}
\DoxyCodeLine{00267     importfile.open(filename);}
\DoxyCodeLine{00268     \textcolor{keywordflow}{return} \textcolor{keyword}{this}-\/>Import(\&importfile);}
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270 \}}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00273}\mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{00273}} \textcolor{keywordtype}{bool} Markov::\mbox{\hyperlink{class_markov_1_1_model}{Model}}<NodeStorageType>::\mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}}(std::ofstream* f) \{}
\DoxyCodeLine{00274     Markov::Edge<NodeStorageType>* e;}
\DoxyCodeLine{00275     \textcolor{keywordflow}{for} (std::vector<\textcolor{keywordtype}{int}>::size\_type i = 0; i != \textcolor{keyword}{this}-\/>edges.size(); i++) \{}
\DoxyCodeLine{00276         e = \textcolor{keyword}{this}-\/>edges[i];}
\DoxyCodeLine{00277         \textcolor{comment}{//std::cout << e-\/>LeftNode()-\/>NodeValue() << "," << e-\/>EdgeWeight() << "," << e-\/>RightNode()-\/>NodeValue() << "\(\backslash\)n";}}
\DoxyCodeLine{00278         *f << e-\/>LeftNode()-\/>NodeValue() << \textcolor{stringliteral}{","} << e-\/>EdgeWeight() << \textcolor{stringliteral}{","} << e-\/>RightNode()-\/>NodeValue() << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{00279     \}}
\DoxyCodeLine{00280 }
\DoxyCodeLine{00281     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00282 \}}
\DoxyCodeLine{00283 }
\DoxyCodeLine{00284 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00285}\mbox{\hyperlink{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}{00285}} \textcolor{keywordtype}{bool} Markov::\mbox{\hyperlink{class_markov_1_1_model}{Model}}<NodeStorageType>::\mbox{\hyperlink{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}{Export}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename) \{}
\DoxyCodeLine{00286     std::ofstream exportfile;}
\DoxyCodeLine{00287     exportfile.open(filename);}
\DoxyCodeLine{00288     \textcolor{keywordflow}{return} \textcolor{keyword}{this}-\/>Export(\&exportfile);}
\DoxyCodeLine{00289 \}}
\DoxyCodeLine{00290 }
\DoxyCodeLine{00291 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00292}\mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{00292}} NodeStorageType* Markov::\mbox{\hyperlink{class_markov_1_1_model}{Model}}<NodeStorageType>::\mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{RandomWalk}}(Markov::\mbox{\hyperlink{namespace_markov_1_1_random}{Random}}::\mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{RandomEngine}}* randomEngine, \textcolor{keywordtype}{int} minSetting, \textcolor{keywordtype}{int} maxSetting, NodeStorageType* buffer) \{}
\DoxyCodeLine{00293     Markov::Node<NodeStorageType>* n = \textcolor{keyword}{this}-\/>starterNode;}
\DoxyCodeLine{00294     \textcolor{keywordtype}{int} len = 0;}
\DoxyCodeLine{00295     Markov::Node<NodeStorageType>* temp\_node;}
\DoxyCodeLine{00296     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{}
\DoxyCodeLine{00297         temp\_node = n-\/>RandomNext(randomEngine);}
\DoxyCodeLine{00298         \textcolor{keywordflow}{if} (len >= maxSetting) \{}
\DoxyCodeLine{00299             \textcolor{keywordflow}{break};}
\DoxyCodeLine{00300         \}}
\DoxyCodeLine{00301         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((temp\_node == NULL) \&\& (len < minSetting)) \{}
\DoxyCodeLine{00302             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00303         \}}
\DoxyCodeLine{00304 }
\DoxyCodeLine{00305         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (temp\_node == NULL)\{}
\DoxyCodeLine{00306             \textcolor{keywordflow}{break};}
\DoxyCodeLine{00307         \}}
\DoxyCodeLine{00308 }
\DoxyCodeLine{00309         n = temp\_node;}
\DoxyCodeLine{00310 }
\DoxyCodeLine{00311         buffer[len++] = n-\/>NodeValue();}
\DoxyCodeLine{00312     \}}
\DoxyCodeLine{00313 }
\DoxyCodeLine{00314     \textcolor{comment}{//null terminate the string}}
\DoxyCodeLine{00315     buffer[len] = 0x00;}
\DoxyCodeLine{00316 }
\DoxyCodeLine{00317     \textcolor{comment}{//do something with the generated string}}
\DoxyCodeLine{00318     \textcolor{keywordflow}{return} buffer; \textcolor{comment}{//for now}}
\DoxyCodeLine{00319 \}}
\DoxyCodeLine{00320 }
\DoxyCodeLine{00321 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NodeStorageType>}
\DoxyCodeLine{\Hypertarget{model_8h_source_l00322}\mbox{\hyperlink{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}{00322}} \textcolor{keywordtype}{void} Markov::\mbox{\hyperlink{class_markov_1_1_model}{Model}}<NodeStorageType>::\mbox{\hyperlink{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}{AdjustEdge}}(\textcolor{keyword}{const} NodeStorageType* payload, \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} occurrence) \{}
\DoxyCodeLine{00323     NodeStorageType p = payload[0];}
\DoxyCodeLine{00324     Markov::Node<NodeStorageType>* curnode = \textcolor{keyword}{this}-\/>starterNode;}
\DoxyCodeLine{00325     Markov::Edge<NodeStorageType>* e;}
\DoxyCodeLine{00326     \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{00327 }
\DoxyCodeLine{00328     \textcolor{keywordflow}{if} (p == 0) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00329     \textcolor{keywordflow}{while} (p != 0) \{}
\DoxyCodeLine{00330         e = curnode-\/>FindEdge(p);}
\DoxyCodeLine{00331         \textcolor{keywordflow}{if} (e == NULL) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00332         e-\/>AdjustEdge(occurrence);}
\DoxyCodeLine{00333         curnode = e-\/>RightNode();}
\DoxyCodeLine{00334         p = payload[++i];}
\DoxyCodeLine{00335     \}}
\DoxyCodeLine{00336 }
\DoxyCodeLine{00337     e = curnode-\/>FindEdge(\textcolor{stringliteral}{'\(\backslash\)xff'});}
\DoxyCodeLine{00338     e-\/>AdjustEdge(occurrence);}
\DoxyCodeLine{00339     \textcolor{keywordflow}{return};}
\DoxyCodeLine{00340 \}}

\end{DoxyCode}
