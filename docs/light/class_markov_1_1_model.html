<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MarkovPasswords: Markov::Model&lt; NodeStorageType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MarkovPasswords
   </div>
   <div id="projectbrief">Utilizing Markov Models for brute forcing attacks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_markov_1_1_model.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_markov_1_1_model-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Markov::Model&lt; NodeStorageType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>class for the final <a class="el" href="namespace_markov.html" title="Namespace for the markov-model related classes. Contains Model, Node and Edge classes.">Markov</a> <a class="el" href="class_markov_1_1_model.html" title="class for the final Markov Model, constructed from nodes and edges.">Model</a>, constructed from nodes and edges.  
 <a href="class_markov_1_1_model.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="model_8h_source.html">model.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Markov::Model&lt; NodeStorageType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_markov_1_1_model__inherit__graph.png" border="0" usemap="#_markov_1_1_model_3_01_node_storage_type_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="_markov_1_1_model_3_01_node_storage_type_01_4_inherit__map" id="_markov_1_1_model_3_01_node_storage_type_01_4_inherit__map">
<area shape="rect" title="class for the final Markov Model, constructed from nodes and edges." alt="" coords="5,5,223,47"/>
<area shape="rect" href="class_markov_1_1_model.html" title=" " alt="" coords="26,109,202,136"/>
<area shape="rect" href="class_markov_passwords.html" title="Markov::Model with char represented nodes." alt="" coords="45,185,183,212"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Markov::Model&lt; NodeStorageType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_markov_1_1_model__coll__graph.png" border="0" usemap="#_markov_1_1_model_3_01_node_storage_type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_markov_1_1_model_3_01_node_storage_type_01_4_coll__map" id="_markov_1_1_model_3_01_node_storage_type_01_4_coll__map">
<area shape="rect" title="class for the final Markov Model, constructed from nodes and edges." alt="" coords="7,199,225,240"/>
<area shape="rect" href="class_markov_1_1_node.html" title=" " alt="" coords="11,95,221,136"/>
<area shape="rect" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge." alt="" coords="5,5,227,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1d564c132cbf681f10f8ed0dfc772df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#ae1d564c132cbf681f10f8ed0dfc772df">Model</a> ()</td></tr>
<tr class="memdesc:ae1d564c132cbf681f10f8ed0dfc772df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a model with only start and end nodes.  <a href="class_markov_1_1_model.html#ae1d564c132cbf681f10f8ed0dfc772df">More...</a><br /></td></tr>
<tr class="separator:ae1d564c132cbf681f10f8ed0dfc772df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a11c6679c998936332f8409ae95375"><td class="memItemLeft" align="right" valign="top">NodeStorageType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375">RandomWalk</a> (<a class="el" href="class_markov_1_1_random_1_1_random_engine.html">Markov::Random::RandomEngine</a> *randomEngine, int minSetting, int maxSetting, NodeStorageType *buffer)</td></tr>
<tr class="memdesc:aa4a11c6679c998936332f8409ae95375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a random walk on this model.  <a href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375">More...</a><br /></td></tr>
<tr class="separator:aa4a11c6679c998936332f8409ae95375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad252913f83fa3eb14cc3f9f92c5ee37a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#ad252913f83fa3eb14cc3f9f92c5ee37a">AdjustEdge</a> (const NodeStorageType *payload, long int occurrence)</td></tr>
<tr class="memdesc:ad252913f83fa3eb14cc3f9f92c5ee37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the model with a single string.  <a href="class_markov_1_1_model.html#ad252913f83fa3eb14cc3f9f92c5ee37a">More...</a><br /></td></tr>
<tr class="separator:ad252913f83fa3eb14cc3f9f92c5ee37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379ea9943f9d4c212e1140d4a9af64f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Import</a> (std::ifstream *)</td></tr>
<tr class="memdesc:a379ea9943f9d4c212e1140d4a9af64f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a file to construct the model.  <a href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">More...</a><br /></td></tr>
<tr class="separator:a379ea9943f9d4c212e1140d4a9af64f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f872a3af96a91d4627c1a5d5e66b19a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a3f872a3af96a91d4627c1a5d5e66b19a">Import</a> (const char *filename)</td></tr>
<tr class="memdesc:a3f872a3af96a91d4627c1a5d5e66b19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file to import with filename, and call bool <a class="el" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5" title="Import a file to construct the model.">Model::Import</a> with std::ifstream.  <a href="class_markov_1_1_model.html#a3f872a3af96a91d4627c1a5d5e66b19a">More...</a><br /></td></tr>
<tr class="separator:a3f872a3af96a91d4627c1a5d5e66b19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16027a94235d2988ac4be35ea07d939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Export</a> (std::ofstream *)</td></tr>
<tr class="memdesc:ae16027a94235d2988ac4be35ea07d939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a file of the model.  <a href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">More...</a><br /></td></tr>
<tr class="separator:ae16027a94235d2988ac4be35ea07d939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788426a3c41a7838a2aae199e8aef5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#af788426a3c41a7838a2aae199e8aef5b">Export</a> (const char *filename)</td></tr>
<tr class="memdesc:af788426a3c41a7838a2aae199e8aef5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file to export with filename, and call bool <a class="el" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939" title="Export a file of the model.">Model::Export</a> with std::ofstream.  <a href="class_markov_1_1_model.html#af788426a3c41a7838a2aae199e8aef5b">More...</a><br /></td></tr>
<tr class="separator:af788426a3c41a7838a2aae199e8aef5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb15a14d034f3365b9d2d3efa1ffc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_markov_1_1_node.html">Node</a>&lt; NodeStorageType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a35cb15a14d034f3365b9d2d3efa1ffc0">StarterNode</a> ()</td></tr>
<tr class="memdesc:a35cb15a14d034f3365b9d2d3efa1ffc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return starter <a class="el" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge.">Node</a>.  <a href="class_markov_1_1_model.html#a35cb15a14d034f3365b9d2d3efa1ffc0">More...</a><br /></td></tr>
<tr class="separator:a35cb15a14d034f3365b9d2d3efa1ffc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08608905d7b042627ea844b08045fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_markov_1_1_edge.html">Edge</a>&lt; NodeStorageType &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a2e08608905d7b042627ea844b08045fe">Edges</a> ()</td></tr>
<tr class="memdesc:a2e08608905d7b042627ea844b08045fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of all the edges in the model.  <a href="class_markov_1_1_model.html#a2e08608905d7b042627ea844b08045fe">More...</a><br /></td></tr>
<tr class="separator:a2e08608905d7b042627ea844b08045fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f6df805e340ce96e9dc4ee4ebc6537"><td class="memItemLeft" align="right" valign="top">std::map&lt; NodeStorageType, <a class="el" href="class_markov_1_1_node.html">Node</a>&lt; NodeStorageType &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a71f6df805e340ce96e9dc4ee4ebc6537">Nodes</a> ()</td></tr>
<tr class="memdesc:a71f6df805e340ce96e9dc4ee4ebc6537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return starter <a class="el" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge.">Node</a>.  <a href="class_markov_1_1_model.html#a71f6df805e340ce96e9dc4ee4ebc6537">More...</a><br /></td></tr>
<tr class="separator:a71f6df805e340ce96e9dc4ee4ebc6537"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa772f79f444c2971f615df7be5e28bca"><td class="memItemLeft" align="right" valign="top">std::map&lt; NodeStorageType, <a class="el" href="class_markov_1_1_node.html">Node</a>&lt; NodeStorageType &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a></td></tr>
<tr class="memdesc:aa772f79f444c2971f615df7be5e28bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map LeftNode is the Nodes NodeValue Map RightNode is the node pointer.  <a href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">More...</a><br /></td></tr>
<tr class="separator:aa772f79f444c2971f615df7be5e28bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d9bf601df78f80076f5d3fbb65fe28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_markov_1_1_node.html">Node</a>&lt; NodeStorageType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#ad2d9bf601df78f80076f5d3fbb65fe28">starterNode</a></td></tr>
<tr class="memdesc:ad2d9bf601df78f80076f5d3fbb65fe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starter <a class="el" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge.">Node</a> of this model.  <a href="class_markov_1_1_model.html#ad2d9bf601df78f80076f5d3fbb65fe28">More...</a><br /></td></tr>
<tr class="separator:ad2d9bf601df78f80076f5d3fbb65fe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d54b6e00a7e92b2c3bf72e1bfa560a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_markov_1_1_edge.html">Edge</a>&lt; NodeStorageType &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">edges</a></td></tr>
<tr class="memdesc:a06d54b6e00a7e92b2c3bf72e1bfa560a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all edges in this model.  <a href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">More...</a><br /></td></tr>
<tr class="separator:a06d54b6e00a7e92b2c3bf72e1bfa560a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename NodeStorageType&gt;<br />
class Markov::Model&lt; NodeStorageType &gt;</h3>

<p>class for the final <a class="el" href="namespace_markov.html" title="Namespace for the markov-model related classes. Contains Model, Node and Edge classes.">Markov</a> <a class="el" href="class_markov_1_1_model.html" title="class for the final Markov Model, constructed from nodes and edges.">Model</a>, constructed from nodes and edges. </p>
<p>Each atomic piece of the generation result is stored in a node, while edges contain the relation weights. <em>Extending:</em> To extend the class, implement the template and inherit from it, as "class MyModel : public Markov::Model&lt;char&gt;". For a complete demonstration of how to extend the class, see <a class="el" href="class_markov_passwords.html" title="Markov::Model with char represented nodes.">MarkovPasswords</a>.</p>
<p>Whole model can be defined as a list of the edges, as dangling nodes are pointless. This approach is used for the import/export operations. For more information on importing/exporting model, check out the github readme and wiki page. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae1d564c132cbf681f10f8ed0dfc772df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d564c132cbf681f10f8ed0dfc772df">&#9670;&nbsp;</a></span>Model()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::<a class="el" href="class_markov_1_1_model.html">Model</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a model with only start and end nodes. </p>
<p>Initialize an empty model with only a starterNode Starter node is a special kind of node that has constant 0x00 value, and will be used to initiate the generation execution from. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad252913f83fa3eb14cc3f9f92c5ee37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad252913f83fa3eb14cc3f9f92c5ee37a">&#9670;&nbsp;</a></span>AdjustEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::AdjustEdge </td>
          <td>(</td>
          <td class="paramtype">const NodeStorageType *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>occurrence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the model with a single string. </p>
<p>Start from the starter node, and for each character, AdjustEdge the edge EdgeWeight from current node to the next, until NULL character is reached.</p>
<p>Then, update the edge EdgeWeight from current node, to the terminator node.</p>
<p>This function is used for training purposes, as it can be used for adjusting the model with each line of the corpus file.</p>
<p><b>Example</b> <b>Use:</b> Create an empty model and train it with string: "testdata" </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line"><span class="keywordtype">char</span> test[] = <span class="stringliteral">&quot;testdata&quot;</span>;</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#ad252913f83fa3eb14cc3f9f92c5ee37a">AdjustEdge</a>(test, 15); </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>- String that is passed from the training, and will be used to AdjustEdge the model with </td></tr>
    <tr><td class="paramname">occurrence</td><td>- Occurrence of this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e08608905d7b042627ea844b08045fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08608905d7b042627ea844b08045fe">&#9670;&nbsp;</a></span>Edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_markov_1_1_edge.html">Edge</a>&lt;NodeStorageType&gt;*&gt;* <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::Edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of all the edges in the model. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of edges </dd></dl>

</div>
</div>
<a id="af788426a3c41a7838a2aae199e8aef5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af788426a3c41a7838a2aae199e8aef5b">&#9670;&nbsp;</a></span>Export() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::Export </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file to export with filename, and call bool <a class="el" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939" title="Export a file of the model.">Model::Export</a> with std::ofstream. </p>
<dl class="section return"><dt>Returns</dt><dd>True if successful, False for incomplete models or corrupt file formats</dd></dl>
<p><b>Example</b> <b>Use:</b> Export file to filename </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Export</a>(<span class="stringliteral">&quot;test.mdl&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae16027a94235d2988ac4be35ea07d939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16027a94235d2988ac4be35ea07d939">&#9670;&nbsp;</a></span>Export() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::Export </td>
          <td>(</td>
          <td class="paramtype">std::ofstream *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export a file of the model. </p>
<p>File contains a list of edges. Format is: Left_repr;EdgeWeight;right_repr. For more information on the format, check out the project wiki or github readme.</p>
<p>Iterate over this vertices, and their edges, and write them to file. </p><dl class="section return"><dt>Returns</dt><dd>True if successful, False for incomplete models.</dd></dl>
<p><b>Example</b> <b>Use:</b> Export file to ofstream </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line">std::ofstream file(<span class="stringliteral">&quot;test.mdl&quot;</span>);</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Export</a>(&amp;file);</div>
</div><!-- fragment --> <div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939_icgraph.png" border="0" usemap="#class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939_icgraph" alt=""/></div>
<map name="class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939_icgraph" id="class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939_icgraph">
<area shape="rect" title="Export a file of the model." alt="" coords="255,35,423,61"/>
<area shape="rect" href="src_2main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title="Launch CLI tool." alt="" coords="79,5,133,32"/>
<area shape="rect" href="namespace_testing_1_1_m_v_p_1_1_markov_model.html#af8b6c0d926618a1037c1f30bfc15b87a" title="Test class for minimal viable Model." alt="" coords="5,57,207,98"/>
</map>
</div>

</div>
</div>
<a id="a3f872a3af96a91d4627c1a5d5e66b19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f872a3af96a91d4627c1a5d5e66b19a">&#9670;&nbsp;</a></span>Import() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::Import </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file to import with filename, and call bool <a class="el" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5" title="Import a file to construct the model.">Model::Import</a> with std::ifstream. </p>
<dl class="section return"><dt>Returns</dt><dd>True if successful, False for incomplete models or corrupt file formats</dd></dl>
<p><b>Example</b> <b>Use:</b> Import a file with filename </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Import</a>(<span class="stringliteral">&quot;test.mdl&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a379ea9943f9d4c212e1140d4a9af64f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379ea9943f9d4c212e1140d4a9af64f5">&#9670;&nbsp;</a></span>Import() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::Import </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a file to construct the model. </p>
<p>File contains a list of edges. For more info on the file format, check out the wiki and github readme pages. Format is: Left_repr;EdgeWeight;right_repr</p>
<p>Iterate over this list, and construct nodes and edges accordingly. </p><dl class="section return"><dt>Returns</dt><dd>True if successful, False for incomplete models or corrupt file formats</dd></dl>
<p><b>Example</b> <b>Use:</b> Import a file from ifstream </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line">std::ifstream file(<span class="stringliteral">&quot;test.mdl&quot;</span>);</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Import</a>(&amp;file);</div>
</div><!-- fragment --> <div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5_icgraph.png" border="0" usemap="#class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5_icgraph" alt=""/></div>
<map name="class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5_icgraph" id="class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5_icgraph">
<area shape="rect" title="Import a file to construct the model." alt="" coords="255,35,424,61"/>
<area shape="rect" href="src_2main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title="Launch CLI tool." alt="" coords="79,5,133,32"/>
<area shape="rect" href="namespace_testing_1_1_m_v_p_1_1_markov_model.html#af8b6c0d926618a1037c1f30bfc15b87a" title="Test class for minimal viable Model." alt="" coords="5,57,207,98"/>
</map>
</div>

</div>
</div>
<a id="a71f6df805e340ce96e9dc4ee4ebc6537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f6df805e340ce96e9dc4ee4ebc6537">&#9670;&nbsp;</a></span>Nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;NodeStorageType, <a class="el" href="class_markov_1_1_node.html">Node</a>&lt;NodeStorageType&gt;*&gt;* <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::Nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return starter <a class="el" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge.">Node</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>starter node with 00 NodeValue </dd></dl>

</div>
</div>
<a id="aa4a11c6679c998936332f8409ae95375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a11c6679c998936332f8409ae95375">&#9670;&nbsp;</a></span>RandomWalk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodeStorageType * <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::RandomWalk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_markov_1_1_random_1_1_random_engine.html">Markov::Random::RandomEngine</a> *&#160;</td>
          <td class="paramname"><em>randomEngine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minSetting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSetting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeStorageType *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a random walk on this model. </p>
<p>Start from the starter node, on each node, invoke RandomNext using the random engine on current node, until terminator node is reached. If terminator node is reached before minimum length criateria is reached, ignore the last selection and re-invoke randomNext</p>
<p>If maximum length criteria is reached but final node is not, cut off the generation and proceed to the final node. This function takes <a class="el" href="class_markov_1_1_random_1_1_random_engine.html">Markov::Random::RandomEngine</a> as a parameter to generate pseudo random numbers from</p>
<p>This library is shipped with two random engines, Marsaglia and Mersenne. While mersenne output is higher in entropy, most use cases don't really need super high entropy output, so <a class="el" href="class_markov_1_1_random_1_1_marsaglia.html">Markov::Random::Marsaglia</a> is preferable for better performance.</p>
<p>This function WILL NOT reallocate buffer. Make sure no out of bound writes are happening via maximum length criteria.</p>
<p><b>Example</b> <b>Use:</b> Generate 10 lines, with 5 to 10 characters, and print the output. Use Marsaglia </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line"><a class="code" href="class_markov_1_1_model.html#ae1d564c132cbf681f10f8ed0dfc772df">Model</a>.import(<span class="stringliteral">&quot;model.mdl&quot;</span>);</div>
<div class="line"><span class="keywordtype">char</span>* res = <span class="keyword">new</span> <span class="keywordtype">char</span>[11];</div>
<div class="line"><a class="code" href="class_markov_1_1_random_1_1_marsaglia.html">Markov::Random::Marsaglia</a> MarsagliaRandomEngine;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {</div>
<div class="line">    this-&gt;<a class="code" href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375">RandomWalk</a>(&amp;MarsagliaRandomEngine, 5, 10, res); </div>
<div class="line">    std::cout &lt;&lt; res &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> }</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">randomEngine</td><td><a class="el" href="namespace_markov_1_1_random.html">Random</a> Engine to use for the random walks. For examples, see Markov::Random::Mersenne and <a class="el" href="class_markov_1_1_random_1_1_marsaglia.html">Markov::Random::Marsaglia</a> </td></tr>
    <tr><td class="paramname">minSetting</td><td>Minimum number of characters to generate </td></tr>
    <tr><td class="paramname">maxSetting</td><td>Maximum number of character to generate </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer to write the result to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Null terminated string that was generated. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375_icgraph.png" border="0" usemap="#class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375_icgraph" alt=""/></div>
<map name="class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375_icgraph" id="class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375_icgraph">
<area shape="rect" title="Do a random walk on this model." alt="" coords="255,46,468,73"/>
<area shape="rect" href="namespace_testing_1_1_m_v_p_1_1_markov_model.html#af8b6c0d926618a1037c1f30bfc15b87a" title="Test class for minimal viable Model." alt="" coords="5,5,207,47"/>
<area shape="rect" href="namespace_testing_1_1_markov_model.html#a84a573ca81cb8cb3db9845b0cdcf06a6" title="Test class for rest of model cases." alt="" coords="24,71,188,112"/>
</map>
</div>

</div>
</div>
<a id="a35cb15a14d034f3365b9d2d3efa1ffc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cb15a14d034f3365b9d2d3efa1ffc0">&#9670;&nbsp;</a></span>StarterNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_markov_1_1_node.html">Node</a>&lt;NodeStorageType&gt;* <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::StarterNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return starter <a class="el" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge.">Node</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>starter node with 00 NodeValue </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0_icgraph.png" border="0" usemap="#class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0_icgraph" alt=""/></div>
<map name="class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0_icgraph" id="class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0_icgraph">
<area shape="rect" title="Return starter Node." alt="" coords="255,46,459,73"/>
<area shape="rect" href="namespace_testing_1_1_m_v_p_1_1_markov_model.html#af8b6c0d926618a1037c1f30bfc15b87a" title="Test class for minimal viable Model." alt="" coords="5,5,207,47"/>
<area shape="rect" href="namespace_testing_1_1_markov_model.html#a84a573ca81cb8cb3db9845b0cdcf06a6" title="Test class for rest of model cases." alt="" coords="24,71,188,112"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a06d54b6e00a7e92b2c3bf72e1bfa560a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d54b6e00a7e92b2c3bf72e1bfa560a">&#9670;&nbsp;</a></span>edges</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_markov_1_1_edge.html">Edge</a>&lt;NodeStorageType&gt;*&gt; <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of all edges in this model. </p>

</div>
</div>
<a id="aa772f79f444c2971f615df7be5e28bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa772f79f444c2971f615df7be5e28bca">&#9670;&nbsp;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;NodeStorageType, <a class="el" href="class_markov_1_1_node.html">Node</a>&lt;NodeStorageType&gt;*&gt; <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map LeftNode is the Nodes NodeValue Map RightNode is the node pointer. </p>

</div>
</div>
<a id="ad2d9bf601df78f80076f5d3fbb65fe28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d9bf601df78f80076f5d3fbb65fe28">&#9670;&nbsp;</a></span>starterNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeStorageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_markov_1_1_node.html">Node</a>&lt;NodeStorageType&gt;* <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; NodeStorageType &gt;::starterNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starter <a class="el" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge.">Node</a> of this model. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/media/ignis/HDD/Repositories/MarkovPasswords/MarkovModel/src/<a class="el" href="model_8h_source.html">model.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclass_markov_1_1_model_html_ad252913f83fa3eb14cc3f9f92c5ee37a"><div class="ttname"><a href="class_markov_1_1_model.html#ad252913f83fa3eb14cc3f9f92c5ee37a">Markov::Model::AdjustEdge</a></div><div class="ttdeci">void AdjustEdge(const NodeStorageType *payload, long int occurrence)</div><div class="ttdoc">Adjust the model with a single string.</div><div class="ttdef"><b>Definition:</b> model.h:322</div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_a379ea9943f9d4c212e1140d4a9af64f5"><div class="ttname"><a href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Markov::Model::Import</a></div><div class="ttdeci">bool Import(std::ifstream *)</div><div class="ttdoc">Import a file to construct the model.</div><div class="ttdef"><b>Definition:</b> model.h:206</div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_aa4a11c6679c998936332f8409ae95375"><div class="ttname"><a href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375">Markov::Model::RandomWalk</a></div><div class="ttdeci">NodeStorageType * RandomWalk(Markov::Random::RandomEngine *randomEngine, int minSetting, int maxSetting, NodeStorageType *buffer)</div><div class="ttdoc">Do a random walk on this model.</div><div class="ttdef"><b>Definition:</b> model.h:292</div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_ae16027a94235d2988ac4be35ea07d939"><div class="ttname"><a href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Markov::Model::Export</a></div><div class="ttdeci">bool Export(std::ofstream *)</div><div class="ttdoc">Export a file of the model.</div><div class="ttdef"><b>Definition:</b> model.h:273</div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_ae1d564c132cbf681f10f8ed0dfc772df"><div class="ttname"><a href="class_markov_1_1_model.html#ae1d564c132cbf681f10f8ed0dfc772df">Markov::Model::Model</a></div><div class="ttdeci">Model()</div><div class="ttdoc">Initialize a model with only start and end nodes.</div><div class="ttdef"><b>Definition:</b> model.h:200</div></div>
<div class="ttc" id="aclass_markov_1_1_random_1_1_marsaglia_html"><div class="ttname"><a href="class_markov_1_1_random_1_1_marsaglia.html">Markov::Random::Marsaglia</a></div><div class="ttdef"><b>Definition:</b> random.h:14</div></div>
<div class="ttc" id="aclass_markov_1_1_model_html"><div class="ttname"><a href="class_markov_1_1_model.html">Markov::Model&lt; char &gt;</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_markov.html">Markov</a></li><li class="navelem"><a class="el" href="class_markov_1_1_model.html">Model</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
