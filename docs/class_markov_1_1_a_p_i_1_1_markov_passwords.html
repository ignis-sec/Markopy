<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Markopy: Markov::API::MarkovPasswords Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome-light.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Markopy
   </div>
   <div id="projectbrief">Utilizing Markov Models for brute forcing attacks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_markov_1_1_a_p_i_1_1_markov_passwords.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_markov_1_1_a_p_i_1_1_markov_passwords-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Markov::API::MarkovPasswords Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_markov_1_1_model.html" title="class for the final Markov Model, constructed from nodes and edges.">Markov::Model</a> with char represented nodes.  
 <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="markov_passwords_8h_source.html">markovPasswords.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Markov::API::MarkovPasswords:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for Markov::API::MarkovPasswords:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a82a0edae676072c420fe74882d87a3cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a82a0edae676072c420fe74882d87a3cc">MarkovPasswords</a> ()</td></tr>
<tr class="memdesc:a82a0edae676072c420fe74882d87a3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the markov model from MarkovModel::Markov::Model.  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a82a0edae676072c420fe74882d87a3cc">More...</a><br /></td></tr>
<tr class="separator:a82a0edae676072c420fe74882d87a3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f0caaea1f96d4fdeea126f78d7081f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ab7f0caaea1f96d4fdeea126f78d7081f">MarkovPasswords</a> (const <a class="el" href="classchar.html">char</a> *filename)</td></tr>
<tr class="memdesc:ab7f0caaea1f96d4fdeea126f78d7081f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the markov model from MarkovModel::Markov::Model, with an import file.  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ab7f0caaea1f96d4fdeea126f78d7081f">More...</a><br /></td></tr>
<tr class="separator:ab7f0caaea1f96d4fdeea126f78d7081f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb665ee48937ca845d930e72e07917"><td class="memItemLeft" align="right" valign="top">std::ifstream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ac3fb665ee48937ca845d930e72e07917">OpenDatasetFile</a> (const <a class="el" href="classchar.html">char</a> *filename)</td></tr>
<tr class="memdesc:ac3fb665ee48937ca845d930e72e07917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open dataset file and return the ifstream pointer.  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ac3fb665ee48937ca845d930e72e07917">More...</a><br /></td></tr>
<tr class="separator:ac3fb665ee48937ca845d930e72e07917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd4423ae3850e258dcb6b11a7feb9b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a2fd4423ae3850e258dcb6b11a7feb9b2">Train</a> (const <a class="el" href="classchar.html">char</a> *datasetFileName, <a class="el" href="classchar.html">char</a> delimiter, int threads)</td></tr>
<tr class="memdesc:a2fd4423ae3850e258dcb6b11a7feb9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Train the model with the dataset file.  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a2fd4423ae3850e258dcb6b11a7feb9b2">More...</a><br /></td></tr>
<tr class="separator:a2fd4423ae3850e258dcb6b11a7feb9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4997da3a6cd3bd2717ce9759736660"><td class="memItemLeft" align="right" valign="top">std::ofstream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a4f4997da3a6cd3bd2717ce9759736660">Save</a> (const <a class="el" href="classchar.html">char</a> *filename)</td></tr>
<tr class="memdesc:a4f4997da3a6cd3bd2717ce9759736660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export model to file.  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a4f4997da3a6cd3bd2717ce9759736660">More...</a><br /></td></tr>
<tr class="separator:a4f4997da3a6cd3bd2717ce9759736660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13886b29051abf3edeed97bd7f985f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a13886b29051abf3edeed97bd7f985f39">Generate</a> (unsigned long int n, const <a class="el" href="classchar.html">char</a> *wordlistFileName, int minLen=6, int maxLen=12, int threads=20)</td></tr>
<tr class="memdesc:a13886b29051abf3edeed97bd7f985f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375" title="Do a random walk on this model.">Markov::Model::RandomWalk</a> n times, and collect output.  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a13886b29051abf3edeed97bd7f985f39">More...</a><br /></td></tr>
<tr class="separator:a13886b29051abf3edeed97bd7f985f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad490665eae3beb022afc7e2491583d0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ad490665eae3beb022afc7e2491583d0a">Buff</a> (const <a class="el" href="classchar.html">char</a> *str, double multiplier, bool bDontAdjustSelfLoops=true, bool bDontAdjustExtendedLoops=false)</td></tr>
<tr class="memdesc:ad490665eae3beb022afc7e2491583d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buff expression of some characters in the model.  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ad490665eae3beb022afc7e2491583d0a">More...</a><br /></td></tr>
<tr class="separator:ad490665eae3beb022afc7e2491583d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a11c6679c998936332f8409ae95375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchar.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375">RandomWalk</a> (<a class="el" href="class_markov_1_1_random_1_1_random_engine.html">Markov::Random::RandomEngine</a> *randomEngine, int minSetting, int maxSetting, <a class="el" href="classchar.html">char</a> *buffer)</td></tr>
<tr class="memdesc:aa4a11c6679c998936332f8409ae95375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a random walk on this model.  <a href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375">More...</a><br /></td></tr>
<tr class="separator:aa4a11c6679c998936332f8409ae95375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad252913f83fa3eb14cc3f9f92c5ee37a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#ad252913f83fa3eb14cc3f9f92c5ee37a">AdjustEdge</a> (const <a class="el" href="classchar.html">char</a> *payload, long int occurrence)</td></tr>
<tr class="memdesc:ad252913f83fa3eb14cc3f9f92c5ee37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the model with a single string.  <a href="class_markov_1_1_model.html#ad252913f83fa3eb14cc3f9f92c5ee37a">More...</a><br /></td></tr>
<tr class="separator:ad252913f83fa3eb14cc3f9f92c5ee37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379ea9943f9d4c212e1140d4a9af64f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Import</a> (std::ifstream *)</td></tr>
<tr class="memdesc:a379ea9943f9d4c212e1140d4a9af64f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a file to construct the model.  <a href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">More...</a><br /></td></tr>
<tr class="separator:a379ea9943f9d4c212e1140d4a9af64f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f872a3af96a91d4627c1a5d5e66b19a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a3f872a3af96a91d4627c1a5d5e66b19a">Import</a> (const <a class="el" href="classchar.html">char</a> *filename)</td></tr>
<tr class="memdesc:a3f872a3af96a91d4627c1a5d5e66b19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file to import with filename, and call bool Model::Import with std::ifstream.  <a href="class_markov_1_1_model.html#a3f872a3af96a91d4627c1a5d5e66b19a">More...</a><br /></td></tr>
<tr class="separator:a3f872a3af96a91d4627c1a5d5e66b19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16027a94235d2988ac4be35ea07d939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Export</a> (std::ofstream *)</td></tr>
<tr class="memdesc:ae16027a94235d2988ac4be35ea07d939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a file of the model.  <a href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">More...</a><br /></td></tr>
<tr class="separator:ae16027a94235d2988ac4be35ea07d939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788426a3c41a7838a2aae199e8aef5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#af788426a3c41a7838a2aae199e8aef5b">Export</a> (const <a class="el" href="classchar.html">char</a> *filename)</td></tr>
<tr class="memdesc:af788426a3c41a7838a2aae199e8aef5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file to export with filename, and call bool Model::Export with std::ofstream.  <a href="class_markov_1_1_model.html#af788426a3c41a7838a2aae199e8aef5b">More...</a><br /></td></tr>
<tr class="separator:af788426a3c41a7838a2aae199e8aef5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb15a14d034f3365b9d2d3efa1ffc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_markov_1_1_node.html">Node</a>&lt; <a class="el" href="classchar.html">char</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a35cb15a14d034f3365b9d2d3efa1ffc0">StarterNode</a> ()</td></tr>
<tr class="memdesc:a35cb15a14d034f3365b9d2d3efa1ffc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return starter Node.  <a href="class_markov_1_1_model.html#a35cb15a14d034f3365b9d2d3efa1ffc0">More...</a><br /></td></tr>
<tr class="separator:a35cb15a14d034f3365b9d2d3efa1ffc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08608905d7b042627ea844b08045fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_markov_1_1_edge.html">Edge</a>&lt; <a class="el" href="classchar.html">char</a> &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a2e08608905d7b042627ea844b08045fe">Edges</a> ()</td></tr>
<tr class="memdesc:a2e08608905d7b042627ea844b08045fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of all the edges in the model.  <a href="class_markov_1_1_model.html#a2e08608905d7b042627ea844b08045fe">More...</a><br /></td></tr>
<tr class="separator:a2e08608905d7b042627ea844b08045fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f6df805e340ce96e9dc4ee4ebc6537"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classchar.html">char</a>, <a class="el" href="class_markov_1_1_node.html">Node</a>&lt; <a class="el" href="classchar.html">char</a> &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a71f6df805e340ce96e9dc4ee4ebc6537">Nodes</a> ()</td></tr>
<tr class="memdesc:a71f6df805e340ce96e9dc4ee4ebc6537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return starter Node.  <a href="class_markov_1_1_model.html#a71f6df805e340ce96e9dc4ee4ebc6537">More...</a><br /></td></tr>
<tr class="separator:a71f6df805e340ce96e9dc4ee4ebc6537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf22db37833ae6a4c707b446bef4359d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#adf22db37833ae6a4c707b446bef4359d">OptimizeEdgeOrder</a> ()</td></tr>
<tr class="memdesc:adf22db37833ae6a4c707b446bef4359d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort edges of all nodes in the model ordered by edge weights.  <a href="class_markov_1_1_model.html#adf22db37833ae6a4c707b446bef4359d">More...</a><br /></td></tr>
<tr class="separator:adf22db37833ae6a4c707b446bef4359d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5f51b0fdb75101b797f38b08da84848e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a5f51b0fdb75101b797f38b08da84848e">TrainThread</a> (<a class="el" href="class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler.html">Markov::API::Concurrency::ThreadSharedListHandler</a> *listhandler, <a class="el" href="classchar.html">char</a> delimiter)</td></tr>
<tr class="memdesc:a5f51b0fdb75101b797f38b08da84848e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single thread invoked by the Train function.  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a5f51b0fdb75101b797f38b08da84848e">More...</a><br /></td></tr>
<tr class="separator:a5f51b0fdb75101b797f38b08da84848e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2703ec2d5c97adaf8d205000ca34756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ac2703ec2d5c97adaf8d205000ca34756">GenerateThread</a> (std::mutex *outputLock, unsigned long int n, std::ofstream *wordlist, int minLen, int maxLen)</td></tr>
<tr class="memdesc:ac2703ec2d5c97adaf8d205000ca34756"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single thread invoked by the Generate function.  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ac2703ec2d5c97adaf8d205000ca34756">More...</a><br /></td></tr>
<tr class="separator:ac2703ec2d5c97adaf8d205000ca34756"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab4794af67fd4513921fee8ae669f2dd4"><td class="memItemLeft" align="right" valign="top">std::ifstream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ab4794af67fd4513921fee8ae669f2dd4">datasetFile</a></td></tr>
<tr class="separator:ab4794af67fd4513921fee8ae669f2dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f012dcc495dbe769e663d6cb161d6a"><td class="memItemLeft" align="right" valign="top">std::ofstream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#af5f012dcc495dbe769e663d6cb161d6a">modelSavefile</a></td></tr>
<tr class="memdesc:af5f012dcc495dbe769e663d6cb161d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dataset file input of our system <br  />
  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#af5f012dcc495dbe769e663d6cb161d6a">More...</a><br /></td></tr>
<tr class="separator:af5f012dcc495dbe769e663d6cb161d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05e60de64e866027410d4fa1cd03248"><td class="memItemLeft" align="right" valign="top">std::ofstream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ac05e60de64e866027410d4fa1cd03248">outputFile</a></td></tr>
<tr class="memdesc:ac05e60de64e866027410d4fa1cd03248"><td class="mdescLeft">&#160;</td><td class="mdescRight">File to save model of our system <br  />
  <a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ac05e60de64e866027410d4fa1cd03248">More...</a><br /></td></tr>
<tr class="separator:ac05e60de64e866027410d4fa1cd03248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa772f79f444c2971f615df7be5e28bca"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classchar.html">char</a>, <a class="el" href="class_markov_1_1_node.html">Node</a>&lt; <a class="el" href="classchar.html">char</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a></td></tr>
<tr class="memdesc:aa772f79f444c2971f615df7be5e28bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map LeftNode is the Nodes NodeValue Map RightNode is the node pointer.  <a href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">More...</a><br /></td></tr>
<tr class="separator:aa772f79f444c2971f615df7be5e28bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d9bf601df78f80076f5d3fbb65fe28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_markov_1_1_node.html">Node</a>&lt; <a class="el" href="classchar.html">char</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#ad2d9bf601df78f80076f5d3fbb65fe28">starterNode</a></td></tr>
<tr class="memdesc:ad2d9bf601df78f80076f5d3fbb65fe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starter Node of this model.  <a href="class_markov_1_1_model.html#ad2d9bf601df78f80076f5d3fbb65fe28">More...</a><br /></td></tr>
<tr class="separator:ad2d9bf601df78f80076f5d3fbb65fe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d54b6e00a7e92b2c3bf72e1bfa560a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_markov_1_1_edge.html">Edge</a>&lt; <a class="el" href="classchar.html">char</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">edges</a></td></tr>
<tr class="memdesc:a06d54b6e00a7e92b2c3bf72e1bfa560a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all edges in this model.  <a href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">More...</a><br /></td></tr>
<tr class="separator:a06d54b6e00a7e92b2c3bf72e1bfa560a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_markov_1_1_model.html" title="class for the final Markov Model, constructed from nodes and edges.">Markov::Model</a> with char represented nodes. </p>
<p>Includes wrappers for <a class="el" href="class_markov_1_1_model.html" title="class for the final Markov Model, constructed from nodes and edges.">Markov::Model</a> and additional helper functions to handle file I/O</p>
<p>This class is an extension of Markov::Model&lt;char&gt;, with higher level abstractions such as train and generate. </p>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8h_source.html#l00026">26</a> of file <a class="el" href="markov_passwords_8h_source.html">markovPasswords.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a82a0edae676072c420fe74882d87a3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a0edae676072c420fe74882d87a3cc">&#9670;&nbsp;</a></span>MarkovPasswords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Markov::API::MarkovPasswords::MarkovPasswords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the markov model from MarkovModel::Markov::Model. </p>
<p>Parent constructor. Has no extra functionality. </p>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8cpp_source.html#l00034">34</a> of file <a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                                          : <a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a>(){</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    </div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    </div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7f0caaea1f96d4fdeea126f78d7081f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f0caaea1f96d4fdeea126f78d7081f">&#9670;&nbsp;</a></span>MarkovPasswords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Markov::API::MarkovPasswords::MarkovPasswords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a> *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the markov model from MarkovModel::Markov::Model, with an import file. </p>
<p>This function calls the <a class="el" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5" title="Import a file to construct the model.">Markov::Model::Import</a> on the filename to construct the model. Same thing as creating and empty model, and calling <a class="el" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5" title="Import a file to construct the model.">MarkovPasswords::Import</a> on the filename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>- Filename to import</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> <b>Use:</b> Construction via filename </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a82a0edae676072c420fe74882d87a3cc">MarkovPasswords</a> <a class="code" href="namespacemarkopy.html#a2626224ad1569dd3ce7c37599cb1e6fe">mp</a>(<span class="stringliteral">&quot;test.mdl&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="markov_passwords_8cpp_source.html#l00039">39</a> of file <a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                                                              {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    std::ifstream* importFile;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160; </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    this-&gt;<a class="code" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Import</a>(filename);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    </div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="comment">//std::ifstream* newFile(filename);</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="comment">//importFile = newFile; </span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160; </div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="model_8h_source.html#l00280">Markov::Model&lt; NodeStorageType &gt;::Import()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_ab7f0caaea1f96d4fdeea126f78d7081f_cgraph.svg" width="528" height="58"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad252913f83fa3eb14cc3f9f92c5ee37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad252913f83fa3eb14cc3f9f92c5ee37a">&#9670;&nbsp;</a></span>AdjustEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::AdjustEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a>  *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>occurrence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust the model with a single string. </p>
<p>Start from the starter node, and for each character, AdjustEdge the edge EdgeWeight from current node to the next, until NULL character is reached.</p>
<p>Then, update the edge EdgeWeight from current node, to the terminator node.</p>
<p>This function is used for training purposes, as it can be used for adjusting the model with each line of the corpus file.</p>
<p><b>Example</b> <b>Use:</b> Create an empty model and train it with string: "testdata" </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line"><span class="keywordtype">char</span> test[] = <span class="stringliteral">&quot;testdata&quot;</span>;</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#ad252913f83fa3eb14cc3f9f92c5ee37a">AdjustEdge</a>(test, 15); </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>- String that is passed from the training, and will be used to AdjustEdge the model with </td></tr>
    <tr><td class="paramname">occurrence</td><td>- Occurrence of this string. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00337">337</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                                                                                                 {</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    NodeStorageType p = payload[0];</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>* curnode = this-&gt;<a class="code" href="class_markov_1_1_model.html#ad2d9bf601df78f80076f5d3fbb65fe28">starterNode</a>;</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <a class="code" href="class_markov_1_1_edge.html">Markov::Edge&lt;NodeStorageType&gt;</a>* e;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160; </div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordflow">if</span> (p == 0) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordflow">while</span> (p != 0) {</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        e = curnode-&gt;<a class="code" href="class_markov_1_1_node.html#ad836573fbdec1c6d7e72945f48ed081c">FindEdge</a>(p);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        <span class="keywordflow">if</span> (e == NULL) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        e-&gt;<a class="code" href="class_markov_1_1_edge.html#aa9d6cc6e631f1b515b4db604c96ad4ad">AdjustEdge</a>(occurrence);</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        curnode = e-&gt;<a class="code" href="class_markov_1_1_edge.html#a2e7d14e46631c85c84f6f8f1dd2949cd">RightNode</a>();</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        p = payload[++i];</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    }</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160; </div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    e = curnode-&gt;<a class="code" href="class_markov_1_1_node.html#ad836573fbdec1c6d7e72945f48ed081c">FindEdge</a>(<span class="stringliteral">&#39;\xff&#39;</span>);</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    e-&gt;<a class="code" href="class_markov_1_1_edge.html#aa9d6cc6e631f1b515b4db604c96ad4ad">AdjustEdge</a>(occurrence);</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad490665eae3beb022afc7e2491583d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad490665eae3beb022afc7e2491583d0a">&#9670;&nbsp;</a></span>Buff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Markov::API::MarkovPasswords::Buff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDontAdjustSelfLoops</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDontAdjustExtendedLoops</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buff expression of some characters in the model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A string containing all the characters to be buffed </td></tr>
    <tr><td class="paramname">multiplier</td><td>A constant value to buff the nodes with. </td></tr>
    <tr><td class="paramname">bDontAdjustSelfEdges</td><td>Do not adjust weights if target node is same as source node </td></tr>
    <tr><td class="paramname">bDontAdjustExtendedLoops</td><td>Do not adjust if both source and target nodes are in first parameter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8cpp_source.html#l00153">153</a> of file <a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                                                                                                                               {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    std::string buffstr(str);</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    std::map&lt; char, Node&lt; char &gt; * &gt; *<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    std::map&lt; char, Edge&lt; char &gt; * &gt; *<a class="code" href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">edges</a>;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a> = this-&gt;<a class="code" href="class_markov_1_1_model.html#a71f6df805e340ce96e9dc4ee4ebc6537">Nodes</a>();</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="keywordtype">int</span> i=0;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [repr, node] : *<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>){</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <a class="code" href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">edges</a> = node-&gt;Edges();</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; [targetrepr, edge] : *<a class="code" href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">edges</a>){</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keywordflow">if</span>(buffstr.find(targetrepr)!= std::string::npos){</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                <span class="keywordflow">if</span>(bDontAdjustSelfLoops &amp;&amp; repr==targetrepr) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                <span class="keywordflow">if</span>(bDontAdjustExtendedLoops){</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                    <span class="keywordflow">if</span>(buffstr.find(repr)!= std::string::npos){</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                        <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                    }</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                <span class="keywordtype">long</span> <span class="keywordtype">int</span> weight = edge-&gt;EdgeWeight();</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                weight = weight*multiplier;     </div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                edge-&gt;AdjustEdge(weight);</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160; </div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        }</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        i++;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    }</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160; </div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    this-&gt;<a class="code" href="class_markov_1_1_model.html#adf22db37833ae6a4c707b446bef4359d">OptimizeEdgeOrder</a>();</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="edge_8h_source.html#l00137">Markov::Edge&lt; NodeStorageType &gt;::AdjustEdge()</a>, <a class="el" href="node_8h_source.html#l00272">Markov::Node&lt; storageType &gt;::Edges()</a>, <a class="el" href="edge_8h_source.html#l00160">Markov::Edge&lt; NodeStorageType &gt;::EdgeWeight()</a>, <a class="el" href="model_8h_source.html#l00181">Markov::Model&lt; NodeStorageType &gt;::Nodes()</a>, and <a class="el" href="model_8h_source.html#l00265">Markov::Model&lt; NodeStorageType &gt;::OptimizeEdgeOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_markov_a_p_i_c_l_i_2src_2main_8cpp_source.html#l00023">main()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_ad490665eae3beb022afc7e2491583d0a_cgraph.svg" width="586" height="272"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_ad490665eae3beb022afc7e2491583d0a_icgraph.svg" width="388" height="58"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2e08608905d7b042627ea844b08045fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08608905d7b042627ea844b08045fe">&#9670;&nbsp;</a></span>Edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_markov_1_1_edge.html">Edge</a>&lt;<a class="el" href="classchar.html">char</a> &gt;*&gt;* <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::Edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of all the edges in the model. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of edges </dd></dl>

<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00176">176</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;{ <span class="keywordflow">return</span> &amp;<a class="code" href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">edges</a>;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af788426a3c41a7838a2aae199e8aef5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af788426a3c41a7838a2aae199e8aef5b">&#9670;&nbsp;</a></span>Export() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::Export </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a> *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a file to export with filename, and call bool <a class="el" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939" title="Export a file of the model.">Model::Export</a> with std::ofstream. </p>
<dl class="section return"><dt>Returns</dt><dd>True if successful, False for incomplete models or corrupt file formats</dd></dl>
<p><b>Example</b> <b>Use:</b> Export file to filename </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Export</a>(<span class="stringliteral">&quot;test.mdl&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00300">300</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                                                              {</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    std::ofstream exportfile;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    exportfile.open(filename);</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Export</a>(&amp;exportfile);</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae16027a94235d2988ac4be35ea07d939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16027a94235d2988ac4be35ea07d939">&#9670;&nbsp;</a></span>Export() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::Export </td>
          <td>(</td>
          <td class="paramtype">std::ofstream *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export a file of the model. </p>
<p>File contains a list of edges. Format is: Left_repr;EdgeWeight;right_repr. For more information on the format, check out the project wiki or github readme.</p>
<p>Iterate over this vertices, and their edges, and write them to file. </p><dl class="section return"><dt>Returns</dt><dd>True if successful, False for incomplete models.</dd></dl>
<p><b>Example</b> <b>Use:</b> Export file to ofstream </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line">std::ofstream file(<span class="stringliteral">&quot;test.mdl&quot;</span>);</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Export</a>(&amp;file);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00288">288</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                                                        {</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <a class="code" href="class_markov_1_1_edge.html">Markov::Edge&lt;NodeStorageType&gt;</a>* e;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;int&gt;::size_type i = 0; i != this-&gt;<a class="code" href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">edges</a>.size(); i++) {</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        e = this-&gt;<a class="code" href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">edges</a>[i];</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="comment">//std::cout &lt;&lt; e-&gt;LeftNode()-&gt;NodeValue() &lt;&lt; &quot;,&quot; &lt;&lt; e-&gt;EdgeWeight() &lt;&lt; &quot;,&quot; &lt;&lt; e-&gt;RightNode()-&gt;NodeValue() &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        *<a class="code" href="namespacemodel__2gram.html#a2c21010331f2adf96f64d1e90d019e76">f</a> &lt;&lt; e-&gt;<a class="code" href="class_markov_1_1_edge.html#a3975b42a420de76e216d343dca059f88">LeftNode</a>()-&gt;<a class="code" href="class_markov_1_1_node.html#ac7cce56376f2a00764f64a0194cbb498">NodeValue</a>() &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; e-&gt;<a class="code" href="class_markov_1_1_edge.html#a2b1e5a6e6f81502cd8ac6b20ed38b677">EdgeWeight</a>() &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; e-&gt;<a class="code" href="class_markov_1_1_edge.html#a2e7d14e46631c85c84f6f8f1dd2949cd">RightNode</a>()-&gt;<a class="code" href="class_markov_1_1_node.html#ac7cce56376f2a00764f64a0194cbb498">NodeValue</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    }</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160; </div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a13886b29051abf3edeed97bd7f985f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13886b29051abf3edeed97bd7f985f39">&#9670;&nbsp;</a></span>Generate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Markov::API::MarkovPasswords::Generate </td>
          <td>(</td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a> *&#160;</td>
          <td class="paramname"><em>wordlistFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minLen</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call <a class="el" href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375" title="Do a random walk on this model.">Markov::Model::RandomWalk</a> n times, and collect output. </p>
<p>Generate from model and write results to a file. a much more performance-optimized method. FastRandomWalk will reduce the runtime by %96.5 on average.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>See Markov::API::MatrixModel::FastRandomWalk for more information. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- Number of passwords to generate. </td></tr>
    <tr><td class="paramname">wordlistFileName</td><td>- Filename to write to </td></tr>
    <tr><td class="paramname">minLen</td><td>- Minimum password length to generate </td></tr>
    <tr><td class="paramname">maxLen</td><td>- Maximum password length to generate </td></tr>
    <tr><td class="paramname">threads</td><td>- number of OS threads to spawn </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8cpp_source.html#l00118">118</a> of file <a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                                                                                                                               {</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keywordtype">char</span>* res;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordtype">char</span> print[100];</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    std::ofstream wordlist; </div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    wordlist.open(wordlistFileName);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    std::mutex mlock;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="keywordtype">int</span> iterationsPerThread = n/threads;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordtype">int</span> iterationsCarryOver = n%threads;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    std::vector&lt;std::thread*&gt; threadsV;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;threads;i++){</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        threadsV.push_back(<span class="keyword">new</span> std::thread(&amp;<a class="code" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ac2703ec2d5c97adaf8d205000ca34756">Markov::API::MarkovPasswords::GenerateThread</a>, <span class="keyword">this</span>, &amp;mlock, iterationsPerThread, &amp;wordlist, minLen, maxLen));</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160; </div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;threads;i++){</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        threadsV[i]-&gt;join();</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keyword">delete</span> threadsV[i];</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    }</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160; </div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    this-&gt;<a class="code" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ac2703ec2d5c97adaf8d205000ca34756">GenerateThread</a>(&amp;mlock, iterationsCarryOver, &amp;wordlist, minLen, maxLen);</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    </div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="markov_passwords_8cpp_source.html#l00140">GenerateThread()</a>.</p>

<p class="reference">Referenced by <a class="el" href="markopy_8cpp_source.html#l00034">Markov::Markopy::BOOST_PYTHON_MODULE()</a>, and <a class="el" href="_generate_8cpp_source.html#l00042">Markov::GUI::Generate::generation()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39_icgraph.svg" width="552" height="128"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac2703ec2d5c97adaf8d205000ca34756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2703ec2d5c97adaf8d205000ca34756">&#9670;&nbsp;</a></span>GenerateThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Markov::API::MarkovPasswords::GenerateThread </td>
          <td>(</td>
          <td class="paramtype">std::mutex *&#160;</td>
          <td class="paramname"><em>outputLock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream *&#160;</td>
          <td class="paramname"><em>wordlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A single thread invoked by the Generate function. </p>
<p><b>DEPRECATED:</b> See Markov::API::MatrixModel::FastRandomWalkThread for more information. This has been replaced with a much more performance-optimized method. FastRandomWalk will reduce the runtime by %96.5 on average.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputLock</td><td>- shared mutex lock to lock during output operation. Prevents race condition on write. </td></tr>
    <tr><td class="paramname">n</td><td>number of lines to be generated by this thread </td></tr>
    <tr><td class="paramname">wordlist</td><td>wordlistfile </td></tr>
    <tr><td class="paramname">minLen</td><td>- Minimum password length to generate </td></tr>
    <tr><td class="paramname">maxLen</td><td>- Maximum password length to generate </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8cpp_source.html#l00140">140</a> of file <a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                                                                                                                                       {</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keywordtype">char</span>* res = <span class="keyword">new</span> <span class="keywordtype">char</span>[maxLen+5];</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="keywordflow">if</span>(n==0) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160; </div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <a class="code" href="class_markov_1_1_random_1_1_marsaglia.html">Markov::Random::Marsaglia</a> MarsagliaRandomEngine;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        this-&gt;<a class="code" href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375">RandomWalk</a>(&amp;MarsagliaRandomEngine, minLen, maxLen, res); </div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        outputLock-&gt;lock();</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        *wordlist &lt;&lt; res &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        outputLock-&gt;unlock();</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    }</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="model_8h_source.html#l00307">Markov::Model&lt; NodeStorageType &gt;::RandomWalk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="markov_passwords_8cpp_source.html#l00118">Generate()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756_cgraph.svg" width="579" height="58"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756_icgraph.svg" width="100%" height="396"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a3f872a3af96a91d4627c1a5d5e66b19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f872a3af96a91d4627c1a5d5e66b19a">&#9670;&nbsp;</a></span>Import() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::Import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a> *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a file to import with filename, and call bool <a class="el" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5" title="Import a file to construct the model.">Model::Import</a> with std::ifstream. </p>
<dl class="section return"><dt>Returns</dt><dd>True if successful, False for incomplete models or corrupt file formats</dd></dl>
<p><b>Example</b> <b>Use:</b> Import a file with filename </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Import</a>(<span class="stringliteral">&quot;test.mdl&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00280">280</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                                                              {</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    std::ifstream importfile;</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    importfile.open(filename);</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Import</a>(&amp;importfile);</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160; </div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a379ea9943f9d4c212e1140d4a9af64f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379ea9943f9d4c212e1140d4a9af64f5">&#9670;&nbsp;</a></span>Import() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::Import </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Import a file to construct the model. </p>
<p>File contains a list of edges. For more info on the file format, check out the wiki and github readme pages. Format is: Left_repr;EdgeWeight;right_repr</p>
<p>Iterate over this list, and construct nodes and edges accordingly. </p><dl class="section return"><dt>Returns</dt><dd>True if successful, False for incomplete models or corrupt file formats</dd></dl>
<p><b>Example</b> <b>Use:</b> Import a file from ifstream </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line">std::ifstream file(<span class="stringliteral">&quot;test.mdl&quot;</span>);</div>
<div class="line">model.<a class="code" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Import</a>(&amp;file);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00216">216</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                                                        {</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    std::string cell;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160; </div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keywordtype">char</span> src;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keywordtype">char</span> target;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordtype">long</span> <span class="keywordtype">int</span> oc;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160; </div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keywordflow">while</span> (std::getline(*<a class="code" href="namespacemodel__2gram.html#a2c21010331f2adf96f64d1e90d019e76">f</a>, cell)) {</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        <span class="comment">//std::cout &lt;&lt; &quot;cell: &quot; &lt;&lt; cell &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        src = cell[0];</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        target = cell[cell.length() - 1];</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        <span class="keywordtype">char</span>* j;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        oc = std::strtol(cell.substr(2, cell.length() - 2).c_str(),&amp;j,10);</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="comment">//std::cout &lt;&lt; oc &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>* srcN;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>* targetN;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <a class="code" href="class_markov_1_1_edge.html">Markov::Edge&lt;NodeStorageType&gt;</a>* e;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>.find(src) == this-&gt;nodes.end()) {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            srcN = <span class="keyword">new</span> <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>(src);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            this-&gt;<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>.insert(std::pair&lt;<span class="keywordtype">char</span>, <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>*&gt;(src, srcN));</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            <span class="comment">//std::cout &lt;&lt; &quot;Creating new node at start.\n&quot;;</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        }</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;            srcN = this-&gt;<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>.find(src)-&gt;second;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        }</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160; </div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>.find(target) == this-&gt;nodes.end()) {</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            targetN = <span class="keyword">new</span> <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>(target);</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            this-&gt;<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>.insert(std::pair&lt;<span class="keywordtype">char</span>, <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>*&gt;(target, targetN));</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            <span class="comment">//std::cout &lt;&lt; &quot;Creating new node at end.\n&quot;;</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        }</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;            targetN = this-&gt;<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>.find(target)-&gt;second;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        }</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        e = srcN-&gt;<a class="code" href="class_markov_1_1_node.html#a0e867cddf6b8dd784c36b12aa820fee9">Link</a>(targetN);</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        e-&gt;<a class="code" href="class_markov_1_1_edge.html#aa9d6cc6e631f1b515b4db604c96ad4ad">AdjustEdge</a>(oc);</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        this-&gt;<a class="code" href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">edges</a>.push_back(e);</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160; </div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        <span class="comment">//std::cout &lt;&lt; int(srcN-&gt;NodeValue()) &lt;&lt; &quot; --&quot; &lt;&lt; e-&gt;EdgeWeight() &lt;&lt; &quot;--&gt; &quot; &lt;&lt; int(targetN-&gt;NodeValue()) &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160; </div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160; </div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    }</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    this-&gt;<a class="code" href="class_markov_1_1_model.html#adf22db37833ae6a4c707b446bef4359d">OptimizeEdgeOrder</a>();</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160; </div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a71f6df805e340ce96e9dc4ee4ebc6537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f6df805e340ce96e9dc4ee4ebc6537">&#9670;&nbsp;</a></span>Nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classchar.html">char</a> , <a class="el" href="class_markov_1_1_node.html">Node</a>&lt;<a class="el" href="classchar.html">char</a> &gt;*&gt;* <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::Nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return starter <a class="el" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge.">Node</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>starter node with 00 NodeValue </dd></dl>

<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00181">181</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;{ <span class="keywordflow">return</span> &amp;<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac3fb665ee48937ca845d930e72e07917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fb665ee48937ca845d930e72e07917">&#9670;&nbsp;</a></span>OpenDatasetFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ifstream * Markov::API::MarkovPasswords::OpenDatasetFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a> *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open dataset file and return the ifstream pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>- Filename to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ifstream* to the the dataset file </dd></dl>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8cpp_source.html#l00051">51</a> of file <a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                                                                          {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160; </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    std::ifstream* <a class="code" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ab4794af67fd4513921fee8ae669f2dd4">datasetFile</a>;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160; </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    std::ifstream newFile(filename);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160; </div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <a class="code" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ab4794af67fd4513921fee8ae669f2dd4">datasetFile</a> = &amp;newFile;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    this-&gt;<a class="code" href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Import</a>(datasetFile);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ab4794af67fd4513921fee8ae669f2dd4">datasetFile</a>;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="model_8h_source.html#l00216">Markov::Model&lt; NodeStorageType &gt;::Import()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_ac3fb665ee48937ca845d930e72e07917_cgraph.svg" width="528" height="58"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adf22db37833ae6a4c707b446bef4359d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf22db37833ae6a4c707b446bef4359d">&#9670;&nbsp;</a></span>OptimizeEdgeOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::OptimizeEdgeOrder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort edges of all nodes in the model ordered by edge weights. </p>

<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00265">265</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                                                    {</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    <span class="keywordflow">for</span> (std::pair&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>, <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>*&gt; <span class="keyword">const</span>&amp; x : this-&gt;<a class="code" href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">nodes</a>) {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        <span class="comment">//std::cout &lt;&lt; &quot;Total edges in EdgesV: &quot; &lt;&lt; x.second-&gt;edgesV.size() &lt;&lt; &quot;\n&quot;; </span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        std::sort (x.second-&gt;edgesV.begin(), x.second-&gt;edgesV.end(), [](Edge&lt;NodeStorageType&gt; *lhs, Edge&lt;NodeStorageType&gt; *rhs)-&gt;bool{</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            return lhs-&gt;EdgeWeight() &gt; rhs-&gt;EdgeWeight();</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        });</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        <span class="comment">//for(int i=0;i&lt;x.second-&gt;edgesV.size();i++)</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="comment">//  std::cout &lt;&lt; x.second-&gt;edgesV[i]-&gt;EdgeWeight() &lt;&lt; &quot;, &quot;;</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="comment">//std::cout &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    }</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="comment">//std::cout &lt;&lt; &quot;Total number of nodes: &quot; &lt;&lt; this-&gt;nodes.size() &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="comment">//std::cout &lt;&lt; &quot;Total number of edges: &quot; &lt;&lt; this-&gt;edges.size() &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4a11c6679c998936332f8409ae95375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a11c6679c998936332f8409ae95375">&#9670;&nbsp;</a></span>RandomWalk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchar.html">char</a>  * <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::RandomWalk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_markov_1_1_random_1_1_random_engine.html">Markov::Random::RandomEngine</a> *&#160;</td>
          <td class="paramname"><em>randomEngine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minSetting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSetting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a>  *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a random walk on this model. </p>
<p>Start from the starter node, on each node, invoke RandomNext using the random engine on current node, until terminator node is reached. If terminator node is reached before minimum length criateria is reached, ignore the last selection and re-invoke randomNext</p>
<p>If maximum length criteria is reached but final node is not, cut off the generation and proceed to the final node. This function takes <a class="el" href="class_markov_1_1_random_1_1_random_engine.html" title="An abstract class for Random Engine.">Markov::Random::RandomEngine</a> as a parameter to generate pseudo random numbers from</p>
<p>This library is shipped with two random engines, Marsaglia and Mersenne. While mersenne output is higher in entropy, most use cases don't really need super high entropy output, so <a class="el" href="class_markov_1_1_random_1_1_marsaglia.html" title="Implementation of Marsaglia Random Engine.">Markov::Random::Marsaglia</a> is preferable for better performance.</p>
<p>This function WILL NOT reallocate buffer. Make sure no out of bound writes are happening via maximum length criteria.</p>
<p><b>Example</b> <b>Use:</b> Generate 10 lines, with 5 to 10 characters, and print the output. Use Marsaglia </p><div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_model.html">Markov::Model&lt;char&gt;</a> model;</div>
<div class="line"><a class="code" href="class_markov_1_1_model.html#ae1d564c132cbf681f10f8ed0dfc772df">Model</a>.import(<span class="stringliteral">&quot;model.mdl&quot;</span>);</div>
<div class="line"><span class="keywordtype">char</span>* res = <span class="keyword">new</span> <span class="keywordtype">char</span>[11];</div>
<div class="line"><a class="code" href="class_markov_1_1_random_1_1_marsaglia.html">Markov::Random::Marsaglia</a> MarsagliaRandomEngine;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {</div>
<div class="line">    this-&gt;<a class="code" href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375">RandomWalk</a>(&amp;MarsagliaRandomEngine, 5, 10, res); </div>
<div class="line">    std::cout &lt;&lt; res &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> }</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">randomEngine</td><td><a class="el" href="namespace_markov_1_1_random.html" title="Objects related to RNG.">Random</a> Engine to use for the random walks. For examples, see <a class="el" href="class_markov_1_1_random_1_1_mersenne.html" title="Implementation of Mersenne Twister Engine.">Markov::Random::Mersenne</a> and <a class="el" href="class_markov_1_1_random_1_1_marsaglia.html" title="Implementation of Marsaglia Random Engine.">Markov::Random::Marsaglia</a> </td></tr>
    <tr><td class="paramname">minSetting</td><td>Minimum number of characters to generate </td></tr>
    <tr><td class="paramname">maxSetting</td><td>Maximum number of character to generate </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer to write the result to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Null terminated string that was generated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00307">307</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                                                                                                                                                         {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>* n = this-&gt;<a class="code" href="class_markov_1_1_model.html#ad2d9bf601df78f80076f5d3fbb65fe28">starterNode</a>;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <span class="keywordtype">int</span> len = 0;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <a class="code" href="class_markov_1_1_node.html">Markov::Node&lt;NodeStorageType&gt;</a>* temp_node;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        temp_node = n-&gt;<a class="code" href="class_markov_1_1_node.html#a87224bed22e5da09e0ddb91c681a6b2c">RandomNext</a>(randomEngine);</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keywordflow">if</span> (len &gt;= maxSetting) {</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        }</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((temp_node == NULL) &amp;&amp; (len &lt; minSetting)) {</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        }</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160; </div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (temp_node == NULL){</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        }</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            </div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        n = temp_node;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160; </div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        buffer[len++] = n-&gt;<a class="code" href="class_markov_1_1_node.html#ac7cce56376f2a00764f64a0194cbb498">NodeValue</a>();</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    }</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160; </div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="comment">//null terminate the string</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    buffer[len] = 0x00;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160; </div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="comment">//do something with the generated string</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="keywordflow">return</span> buffer; <span class="comment">//for now</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f4997da3a6cd3bd2717ce9759736660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4997da3a6cd3bd2717ce9759736660">&#9670;&nbsp;</a></span>Save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream * Markov::API::MarkovPasswords::Save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a> *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export model to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>- Export filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ofstream* of the exported file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8cpp_source.html#l00106">106</a> of file <a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                                                                {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    std::ofstream* exportFile;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160; </div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    std::ofstream newFile(filename);</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160; </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    exportFile = &amp;newFile;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    </div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    this-&gt;<a class="code" href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Export</a>(exportFile);</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">return</span> exportFile;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="model_8h_source.html#l00288">Markov::Model&lt; NodeStorageType &gt;::Export()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_a4f4997da3a6cd3bd2717ce9759736660_cgraph.svg" width="527" height="58"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a35cb15a14d034f3365b9d2d3efa1ffc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cb15a14d034f3365b9d2d3efa1ffc0">&#9670;&nbsp;</a></span>StarterNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_markov_1_1_node.html">Node</a>&lt;<a class="el" href="classchar.html">char</a> &gt;* <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::StarterNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return starter <a class="el" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge.">Node</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>starter node with 00 NodeValue </dd></dl>

<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00171">171</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="class_markov_1_1_model.html#ad2d9bf601df78f80076f5d3fbb65fe28">starterNode</a>;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fd4423ae3850e258dcb6b11a7feb9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd4423ae3850e258dcb6b11a7feb9b2">&#9670;&nbsp;</a></span>Train()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Markov::API::MarkovPasswords::Train </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a> *&#160;</td>
          <td class="paramname"><em>datasetFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a>&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Train the model with the dataset file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">datasetFileName</td><td>- Ifstream* to the dataset. If null, use class member </td></tr>
    <tr><td class="paramname">delimiter</td><td>- a character, same as the delimiter in dataset content </td></tr>
    <tr><td class="paramname">threads</td><td>- number of OS threads to spawn</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html">Markov::API::MarkovPasswords</a> <a class="code" href="namespacemarkopy.html#a2626224ad1569dd3ce7c37599cb1e6fe">mp</a>;</div>
<div class="line"><a class="code" href="namespacemp.html">mp</a>.Import(<span class="stringliteral">&quot;models/2gram.mdl&quot;</span>);</div>
<div class="line"><a class="code" href="namespacemp.html">mp</a>.Train(<span class="stringliteral">&quot;password.corpus&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="markov_passwords_8cpp_source.html#l00065">65</a> of file <a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                                                                                               {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  signal(SIGINT, <a class="code" href="markov_passwords_8cpp.html#a3b33e6f48f5d988f336e915c5346eb95">intHandler</a>);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <a class="code" href="class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler.html">Markov::API::Concurrency::ThreadSharedListHandler</a> listhandler(datasetFileName);</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160; </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    std::vector&lt;std::thread*&gt; threadsV;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;threads;i++){</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        threadsV.push_back(<span class="keyword">new</span> std::thread(&amp;<a class="code" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a5f51b0fdb75101b797f38b08da84848e">Markov::API::MarkovPasswords::TrainThread</a>, <span class="keyword">this</span>, &amp;listhandler, delimiter));</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    }</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160; </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;threads;i++){</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        threadsV[i]-&gt;join();</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keyword">delete</span> threadsV[i];</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keyword">auto</span> finish = std::chrono::high_resolution_clock::now();</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    std::chrono::duration&lt;double&gt; elapsed = finish - start;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Elapsed time: &quot;</span> &lt;&lt; elapsed.count() &lt;&lt; <span class="stringliteral">&quot; s\n&quot;</span>;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160; </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="markov_passwords_8cpp_source.html#l00026">intHandler()</a>, <a class="el" href="thread_shared_list_handler_8cpp_source.html#l00012">Markov::API::Concurrency::ThreadSharedListHandler::ThreadSharedListHandler()</a>, and <a class="el" href="markov_passwords_8cpp_source.html#l00085">TrainThread()</a>.</p>

<p class="reference">Referenced by <a class="el" href="markopy_8cpp_source.html#l00034">Markov::Markopy::BOOST_PYTHON_MODULE()</a>, <a class="el" href="_train_8cpp_source.html#l00038">Markov::GUI::Train::train()</a>, <a class="el" href="_generate_8cpp_source.html#l00082">Markov::GUI::Generate::train()</a>, and <a class="el" href="model_matrix_8cpp_source.html#l00025">Markov::API::ModelMatrix::Train()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2_cgraph.svg" width="100%" height="473"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2_icgraph.svg" width="100%" height="472"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a5f51b0fdb75101b797f38b08da84848e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f51b0fdb75101b797f38b08da84848e">&#9670;&nbsp;</a></span>TrainThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Markov::API::MarkovPasswords::TrainThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler.html">Markov::API::Concurrency::ThreadSharedListHandler</a> *&#160;</td>
          <td class="paramname"><em>listhandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a>&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A single thread invoked by the Train function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listhandler</td><td>- Listhandler class to read corpus from </td></tr>
    <tr><td class="paramname">delimiter</td><td>- a character, same as the delimiter in dataset content </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8cpp_source.html#l00085">85</a> of file <a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                                                                                                                  {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordtype">char</span> format_str[] =<span class="stringliteral">&quot;%ld,%s&quot;</span>;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    format_str[3]=delimiter;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    std::string line;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">while</span> (listhandler-&gt;<a class="code" href="class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler.html#a068e1a9ff477de23a44c10230df416a5">next</a>(&amp;line) &amp;&amp; <a class="code" href="markov_passwords_8cpp.html#a8e56c23aec0c3ae06851ab864c1f67e5">keepRunning</a>) {</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordtype">long</span> <span class="keywordtype">int</span> oc;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">if</span> (line.size() &gt; 100) {</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            line = line.substr(0, 100);</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        }</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <span class="keywordtype">char</span>* linebuf = <span class="keyword">new</span> <span class="keywordtype">char</span>[line.length()+5];</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        sscanf_s(line.c_str(), <span class="stringliteral">&quot;%ld,%s&quot;</span>, &amp;oc, linebuf, line.length()+5); <span class="comment">//&lt;== changed format_str to-&gt; &quot;%ld,%s&quot;</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        sscanf(line.c_str(), format_str, &amp;oc, linebuf);</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        this-&gt;<a class="code" href="class_markov_1_1_model.html#ad252913f83fa3eb14cc3f9f92c5ee37a">AdjustEdge</a>((<span class="keyword">const</span> <span class="keywordtype">char</span>*)linebuf, oc); </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keyword">delete</span> linebuf;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    }</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="model_8h_source.html#l00337">Markov::Model&lt; NodeStorageType &gt;::AdjustEdge()</a>, <a class="el" href="markov_passwords_8cpp_source.html#l00024">keepRunning</a>, and <a class="el" href="thread_shared_list_handler_8cpp_source.html#l00018">Markov::API::Concurrency::ThreadSharedListHandler::next()</a>.</p>

<p class="reference">Referenced by <a class="el" href="markov_passwords_8cpp_source.html#l00065">Train()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e_cgraph.svg" width="604" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e_icgraph.svg" width="100%" height="472"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab4794af67fd4513921fee8ae669f2dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4794af67fd4513921fee8ae669f2dd4">&#9670;&nbsp;</a></span>datasetFile</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ifstream* Markov::API::MarkovPasswords::datasetFile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="markov_passwords_8h_source.html#l00123">123</a> of file <a class="el" href="markov_passwords_8h_source.html">markovPasswords.h</a>.</p>

</div>
</div>
<a id="a06d54b6e00a7e92b2c3bf72e1bfa560a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d54b6e00a7e92b2c3bf72e1bfa560a">&#9670;&nbsp;</a></span>edges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_markov_1_1_edge.html">Edge</a>&lt;<a class="el" href="classchar.html">char</a> &gt;*&gt; <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of all edges in this model. </p>

<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00204">204</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>

</div>
</div>
<a id="af5f012dcc495dbe769e663d6cb161d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f012dcc495dbe769e663d6cb161d6a">&#9670;&nbsp;</a></span>modelSavefile</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream* Markov::API::MarkovPasswords::modelSavefile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dataset file input of our system <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8h_source.html#l00124">124</a> of file <a class="el" href="markov_passwords_8h_source.html">markovPasswords.h</a>.</p>

</div>
</div>
<a id="aa772f79f444c2971f615df7be5e28bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa772f79f444c2971f615df7be5e28bca">&#9670;&nbsp;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classchar.html">char</a> , <a class="el" href="class_markov_1_1_node.html">Node</a>&lt;<a class="el" href="classchar.html">char</a> &gt;*&gt; <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map LeftNode is the Nodes NodeValue Map RightNode is the node pointer. </p>

<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00193">193</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>

</div>
</div>
<a id="ac05e60de64e866027410d4fa1cd03248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05e60de64e866027410d4fa1cd03248">&#9670;&nbsp;</a></span>outputFile</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream* Markov::API::MarkovPasswords::outputFile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File to save model of our system <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="markov_passwords_8h_source.html#l00125">125</a> of file <a class="el" href="markov_passwords_8h_source.html">markovPasswords.h</a>.</p>

</div>
</div>
<a id="ad2d9bf601df78f80076f5d3fbb65fe28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d9bf601df78f80076f5d3fbb65fe28">&#9670;&nbsp;</a></span>starterNode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_markov_1_1_node.html">Node</a>&lt;<a class="el" href="classchar.html">char</a> &gt;* <a class="el" href="class_markov_1_1_model.html">Markov::Model</a>&lt; <a class="el" href="classchar.html">char</a>  &gt;::starterNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starter <a class="el" href="class_markov_1_1_node.html" title="A node class that for the vertices of model. Connected with eachother using Edge.">Node</a> of this model. </p>

<p class="definition">Definition at line <a class="el" href="model_8h_source.html#l00198">198</a> of file <a class="el" href="model_8h_source.html">model.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="markov_passwords_8h_source.html">markovPasswords.h</a></li>
<li><a class="el" href="markov_passwords_8cpp_source.html">markovPasswords.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclass_markov_1_1_model_html_ad252913f83fa3eb14cc3f9f92c5ee37a"><div class="ttname"><a href="class_markov_1_1_model.html#ad252913f83fa3eb14cc3f9f92c5ee37a">Markov::Model::AdjustEdge</a></div><div class="ttdeci">void AdjustEdge(const NodeStorageType *payload, long int occurrence)</div><div class="ttdoc">Adjust the model with a single string.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00337">model.h:337</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_a71f6df805e340ce96e9dc4ee4ebc6537"><div class="ttname"><a href="class_markov_1_1_model.html#a71f6df805e340ce96e9dc4ee4ebc6537">Markov::Model&lt; char &gt;::Nodes</a></div><div class="ttdeci">std::map&lt; char, Node&lt; char &gt; * &gt; * Nodes()</div><div class="ttdoc">Return starter Node.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00181">model.h:181</a></div></div>
<div class="ttc" id="aclass_markov_1_1_node_html_a87224bed22e5da09e0ddb91c681a6b2c"><div class="ttname"><a href="class_markov_1_1_node.html#a87224bed22e5da09e0ddb91c681a6b2c">Markov::Node::RandomNext</a></div><div class="ttdeci">Node&lt; storageType &gt; * RandomNext(Markov::Random::RandomEngine *randomEngine)</div><div class="ttdoc">Chose a random node from the list of edges, with regards to its EdgeWeight, and TraverseNode to that.</div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00234">node.h:234</a></div></div>
<div class="ttc" id="aclass_markov_1_1_edge_html_a3975b42a420de76e216d343dca059f88"><div class="ttname"><a href="class_markov_1_1_edge.html#a3975b42a420de76e216d343dca059f88">Markov::Edge::LeftNode</a></div><div class="ttdeci">Node&lt; NodeStorageType &gt; * LeftNode()</div><div class="ttdoc">return edge's LeftNode</div><div class="ttdef"><b>Definition:</b> <a href="edge_8h_source.html#l00165">edge.h:165</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_a379ea9943f9d4c212e1140d4a9af64f5"><div class="ttname"><a href="class_markov_1_1_model.html#a379ea9943f9d4c212e1140d4a9af64f5">Markov::Model&lt; char &gt;::Import</a></div><div class="ttdeci">bool Import(std::ifstream *)</div><div class="ttdoc">Import a file to construct the model.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00216">model.h:216</a></div></div>
<div class="ttc" id="aclass_markov_1_1_edge_html_a2e7d14e46631c85c84f6f8f1dd2949cd"><div class="ttname"><a href="class_markov_1_1_edge.html#a2e7d14e46631c85c84f6f8f1dd2949cd">Markov::Edge::RightNode</a></div><div class="ttdeci">Node&lt; NodeStorageType &gt; * RightNode()</div><div class="ttdoc">return edge's RightNode</div><div class="ttdef"><b>Definition:</b> <a href="edge_8h_source.html#l00170">edge.h:170</a></div></div>
<div class="ttc" id="aclass_markov_1_1_a_p_i_1_1_markov_passwords_html"><div class="ttname"><a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html">Markov::API::MarkovPasswords</a></div><div class="ttdoc">Markov::Model with char represented nodes.</div><div class="ttdef"><b>Definition:</b> <a href="markov_passwords_8h_source.html#l00026">markovPasswords.h:26</a></div></div>
<div class="ttc" id="aclass_markov_1_1_a_p_i_1_1_markov_passwords_html_a5f51b0fdb75101b797f38b08da84848e"><div class="ttname"><a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a5f51b0fdb75101b797f38b08da84848e">Markov::API::MarkovPasswords::TrainThread</a></div><div class="ttdeci">void TrainThread(Markov::API::Concurrency::ThreadSharedListHandler *listhandler, char delimiter)</div><div class="ttdoc">A single thread invoked by the Train function.</div><div class="ttdef"><b>Definition:</b> <a href="markov_passwords_8cpp_source.html#l00085">markovPasswords.cpp:85</a></div></div>
<div class="ttc" id="amarkov_passwords_8cpp_html_a3b33e6f48f5d988f336e915c5346eb95"><div class="ttname"><a href="markov_passwords_8cpp.html#a3b33e6f48f5d988f336e915c5346eb95">intHandler</a></div><div class="ttdeci">void intHandler(int dummy)</div><div class="ttdef"><b>Definition:</b> <a href="markov_passwords_8cpp_source.html#l00026">markovPasswords.cpp:26</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_adf22db37833ae6a4c707b446bef4359d"><div class="ttname"><a href="class_markov_1_1_model.html#adf22db37833ae6a4c707b446bef4359d">Markov::Model&lt; char &gt;::OptimizeEdgeOrder</a></div><div class="ttdeci">void OptimizeEdgeOrder()</div><div class="ttdoc">Sort edges of all nodes in the model ordered by edge weights.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00265">model.h:265</a></div></div>
<div class="ttc" id="aclass_markov_1_1_edge_html_a2b1e5a6e6f81502cd8ac6b20ed38b677"><div class="ttname"><a href="class_markov_1_1_edge.html#a2b1e5a6e6f81502cd8ac6b20ed38b677">Markov::Edge::EdgeWeight</a></div><div class="ttdeci">uint64_t EdgeWeight()</div><div class="ttdoc">return edge's EdgeWeight.</div><div class="ttdef"><b>Definition:</b> <a href="edge_8h_source.html#l00160">edge.h:160</a></div></div>
<div class="ttc" id="aclass_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler_html"><div class="ttname"><a href="class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler.html">Markov::API::Concurrency::ThreadSharedListHandler</a></div><div class="ttdoc">Simple class for managing shared access to file.</div><div class="ttdef"><b>Definition:</b> <a href="thread_shared_list_handler_8h_source.html#l00025">threadSharedListHandler.h:25</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_aa4a11c6679c998936332f8409ae95375"><div class="ttname"><a href="class_markov_1_1_model.html#aa4a11c6679c998936332f8409ae95375">Markov::Model&lt; char &gt;::RandomWalk</a></div><div class="ttdeci">char * RandomWalk(Markov::Random::RandomEngine *randomEngine, int minSetting, int maxSetting, char *buffer)</div><div class="ttdoc">Do a random walk on this model.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00307">model.h:307</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_ae16027a94235d2988ac4be35ea07d939"><div class="ttname"><a href="class_markov_1_1_model.html#ae16027a94235d2988ac4be35ea07d939">Markov::Model::Export</a></div><div class="ttdeci">bool Export(std::ofstream *)</div><div class="ttdoc">Export a file of the model.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00288">model.h:288</a></div></div>
<div class="ttc" id="aclass_markov_1_1_a_p_i_1_1_markov_passwords_html_ab4794af67fd4513921fee8ae669f2dd4"><div class="ttname"><a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ab4794af67fd4513921fee8ae669f2dd4">Markov::API::MarkovPasswords::datasetFile</a></div><div class="ttdeci">std::ifstream * datasetFile</div><div class="ttdef"><b>Definition:</b> <a href="markov_passwords_8h_source.html#l00123">markovPasswords.h:123</a></div></div>
<div class="ttc" id="aclass_markov_1_1_a_p_i_1_1_markov_passwords_html_a82a0edae676072c420fe74882d87a3cc"><div class="ttname"><a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#a82a0edae676072c420fe74882d87a3cc">Markov::API::MarkovPasswords::MarkovPasswords</a></div><div class="ttdeci">MarkovPasswords()</div><div class="ttdoc">Initialize the markov model from MarkovModel::Markov::Model.</div><div class="ttdef"><b>Definition:</b> <a href="markov_passwords_8cpp_source.html#l00034">markovPasswords.cpp:34</a></div></div>
<div class="ttc" id="aclass_markov_1_1_node_html"><div class="ttname"><a href="class_markov_1_1_node.html">Markov::Node&lt; NodeStorageType &gt;</a></div></div>
<div class="ttc" id="aclass_markov_1_1_edge_html_aa9d6cc6e631f1b515b4db604c96ad4ad"><div class="ttname"><a href="class_markov_1_1_edge.html#aa9d6cc6e631f1b515b4db604c96ad4ad">Markov::Edge::AdjustEdge</a></div><div class="ttdeci">void AdjustEdge(long int offset)</div><div class="ttdoc">Adjust the edge EdgeWeight with offset. Adds the offset parameter to the edge EdgeWeight.</div><div class="ttdef"><b>Definition:</b> <a href="edge_8h_source.html#l00137">edge.h:137</a></div></div>
<div class="ttc" id="aclass_markov_1_1_node_html_a0e867cddf6b8dd784c36b12aa820fee9"><div class="ttname"><a href="class_markov_1_1_node.html#a0e867cddf6b8dd784c36b12aa820fee9">Markov::Node::Link</a></div><div class="ttdeci">Edge&lt; storageType &gt; * Link(Node&lt; storageType &gt; *)</div><div class="ttdoc">Link this node with another, with this node as its source.</div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00220">node.h:220</a></div></div>
<div class="ttc" id="aclass_markov_1_1_node_html_ac7cce56376f2a00764f64a0194cbb498"><div class="ttname"><a href="class_markov_1_1_node.html#ac7cce56376f2a00764f64a0194cbb498">Markov::Node::NodeValue</a></div><div class="ttdeci">unsigned char NodeValue()</div><div class="ttdoc">Return character representation of this node.</div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00215">node.h:215</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_ae1d564c132cbf681f10f8ed0dfc772df"><div class="ttname"><a href="class_markov_1_1_model.html#ae1d564c132cbf681f10f8ed0dfc772df">Markov::Model&lt; char &gt;::Model</a></div><div class="ttdeci">Model()</div><div class="ttdoc">Initialize a model with only start and end nodes.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00210">model.h:210</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_a06d54b6e00a7e92b2c3bf72e1bfa560a"><div class="ttname"><a href="class_markov_1_1_model.html#a06d54b6e00a7e92b2c3bf72e1bfa560a">Markov::Model&lt; char &gt;::edges</a></div><div class="ttdeci">std::vector&lt; Edge&lt; char &gt; * &gt; edges</div><div class="ttdoc">A list of all edges in this model.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00204">model.h:204</a></div></div>
<div class="ttc" id="anamespacemp_html"><div class="ttname"><a href="namespacemp.html">mp</a></div><div class="ttdef"><b>Definition:</b> <a href="mp_8py_source.html#l00001">mp.py:1</a></div></div>
<div class="ttc" id="aclass_markov_1_1_a_p_i_1_1_markov_passwords_html_ac2703ec2d5c97adaf8d205000ca34756"><div class="ttname"><a href="class_markov_1_1_a_p_i_1_1_markov_passwords.html#ac2703ec2d5c97adaf8d205000ca34756">Markov::API::MarkovPasswords::GenerateThread</a></div><div class="ttdeci">void GenerateThread(std::mutex *outputLock, unsigned long int n, std::ofstream *wordlist, int minLen, int maxLen)</div><div class="ttdoc">A single thread invoked by the Generate function.</div><div class="ttdef"><b>Definition:</b> <a href="markov_passwords_8cpp_source.html#l00140">markovPasswords.cpp:140</a></div></div>
<div class="ttc" id="aclass_markov_1_1_node_html_ad836573fbdec1c6d7e72945f48ed081c"><div class="ttname"><a href="class_markov_1_1_node.html#ad836573fbdec1c6d7e72945f48ed081c">Markov::Node::FindEdge</a></div><div class="ttdeci">Edge&lt; storageType &gt; * FindEdge(storageType repr)</div><div class="ttdoc">Find an edge with its character representation.</div><div class="ttdef"><b>Definition:</b> <a href="node_8h_source.html#l00260">node.h:260</a></div></div>
<div class="ttc" id="aclass_markov_1_1_random_1_1_marsaglia_html"><div class="ttname"><a href="class_markov_1_1_random_1_1_marsaglia.html">Markov::Random::Marsaglia</a></div><div class="ttdoc">Implementation of Marsaglia Random Engine.</div><div class="ttdef"><b>Definition:</b> <a href="random_8h_source.html#l00125">random.h:125</a></div></div>
<div class="ttc" id="aclass_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler_html_a068e1a9ff477de23a44c10230df416a5"><div class="ttname"><a href="class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler.html#a068e1a9ff477de23a44c10230df416a5">Markov::API::Concurrency::ThreadSharedListHandler::next</a></div><div class="ttdeci">bool next(std::string *line)</div><div class="ttdoc">Read the next line from the file.</div><div class="ttdef"><b>Definition:</b> <a href="thread_shared_list_handler_8cpp_source.html#l00018">threadSharedListHandler.cpp:18</a></div></div>
<div class="ttc" id="anamespacemodel__2gram_html_a2c21010331f2adf96f64d1e90d019e76"><div class="ttname"><a href="namespacemodel__2gram.html#a2c21010331f2adf96f64d1e90d019e76">model_2gram.f</a></div><div class="ttdeci">f</div><div class="ttdoc">output file handle</div><div class="ttdef"><b>Definition:</b> <a href="model__2gram_8py_source.html#l00016">model_2gram.py:16</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html"><div class="ttname"><a href="class_markov_1_1_model.html">Markov::Model&lt; char &gt;</a></div></div>
<div class="ttc" id="anamespacemarkopy_html_a2626224ad1569dd3ce7c37599cb1e6fe"><div class="ttname"><a href="namespacemarkopy.html#a2626224ad1569dd3ce7c37599cb1e6fe">markopy.mp</a></div><div class="ttdeci">mp</div><div class="ttdef"><b>Definition:</b> <a href="markopy_8py_source.html#l00122">markopy.py:122</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_aa772f79f444c2971f615df7be5e28bca"><div class="ttname"><a href="class_markov_1_1_model.html#aa772f79f444c2971f615df7be5e28bca">Markov::Model&lt; char &gt;::nodes</a></div><div class="ttdeci">std::map&lt; char, Node&lt; char &gt; * &gt; nodes</div><div class="ttdoc">Map LeftNode is the Nodes NodeValue Map RightNode is the node pointer.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00193">model.h:193</a></div></div>
<div class="ttc" id="aclass_markov_1_1_model_html_ad2d9bf601df78f80076f5d3fbb65fe28"><div class="ttname"><a href="class_markov_1_1_model.html#ad2d9bf601df78f80076f5d3fbb65fe28">Markov::Model&lt; char &gt;::starterNode</a></div><div class="ttdeci">Node&lt; char &gt; * starterNode</div><div class="ttdoc">Starter Node of this model.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00198">model.h:198</a></div></div>
<div class="ttc" id="amarkov_passwords_8cpp_html_a8e56c23aec0c3ae06851ab864c1f67e5"><div class="ttname"><a href="markov_passwords_8cpp.html#a8e56c23aec0c3ae06851ab864c1f67e5">keepRunning</a></div><div class="ttdeci">static volatile int keepRunning</div><div class="ttdef"><b>Definition:</b> <a href="markov_passwords_8cpp_source.html#l00024">markovPasswords.cpp:24</a></div></div>
<div class="ttc" id="aclass_markov_1_1_edge_html"><div class="ttname"><a href="class_markov_1_1_edge.html">Markov::Edge</a></div><div class="ttdoc">Edge class used to link nodes in the model together.</div><div class="ttdef"><b>Definition:</b> <a href="model_8h_source.html#l00030">model.h:30</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_markov.html">Markov</a></li><li class="navelem"><a class="el" href="namespace_markov_1_1_a_p_i.html">API</a></li><li class="navelem"><a class="el" href="class_markov_1_1_a_p_i_1_1_markov_passwords.html">MarkovPasswords</a></li>
    <li class="footer">Generated on Sun Jun 27 2021 17:05:20 for Markopy by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
