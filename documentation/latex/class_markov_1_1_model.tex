\hypertarget{class_markov_1_1_model}{}\doxysection{Markov\+::Model$<$ Node\+Storage\+Type $>$ Class Template Reference}
\label{class_markov_1_1_model}\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}


class for the final \mbox{\hyperlink{namespace_markov}{Markov}} \mbox{\hyperlink{class_markov_1_1_model}{Model}}, constructed from nodes and edges.  




{\ttfamily \#include $<$model.\+h$>$}



Inheritance diagram for Markov\+::Model$<$ Node\+Storage\+Type $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=243pt]{class_markov_1_1_model__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Markov\+::Model$<$ Node\+Storage\+Type $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=275pt]{class_markov_1_1_model__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}{Model}} ()
\begin{DoxyCompactList}\small\item\em Initialize a model with only start and end nodes. \end{DoxyCompactList}\item 
Node\+Storage\+Type $\ast$ \mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{Random\+Walk}} (\mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{Markov\+::\+Random\+::\+Random\+Engine}} $\ast$random\+Engine, int min\+Setting, int max\+Setting, Node\+Storage\+Type $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Do a random walk on this model. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}{Adjust\+Edge}} (const Node\+Storage\+Type $\ast$payload, long int occurrence)
\begin{DoxyCompactList}\small\item\em Adjust the model with a single string. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}} (std\+::ifstream $\ast$)
\begin{DoxyCompactList}\small\item\em Import a file to construct the model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}{Import}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to import with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Model\+::\+Import}} with std\+::ifstream. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}} (std\+::ofstream $\ast$)
\begin{DoxyCompactList}\small\item\em Export a file of the model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}{Export}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to export with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Model\+::\+Export}} with std\+::ofstream. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ Node\+Storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}{Starter\+Node}} ()
\begin{DoxyCompactList}\small\item\em Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ Node\+Storage\+Type $>$ $\ast$ $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}{Edges}} ()
\begin{DoxyCompactList}\small\item\em Return a vector of all the edges in the model. \end{DoxyCompactList}\item 
std\+::map$<$ Node\+Storage\+Type, \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ Node\+Storage\+Type $>$ $\ast$ $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}{Nodes}} ()
\begin{DoxyCompactList}\small\item\em Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::map$<$ Node\+Storage\+Type, \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ Node\+Storage\+Type $>$ $\ast$ $>$ \mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}
\begin{DoxyCompactList}\small\item\em Map Left\+Node is the Nodes Node\+Value Map Right\+Node is the node pointer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ Node\+Storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starter\+Node}}
\begin{DoxyCompactList}\small\item\em Starter \mbox{\hyperlink{class_markov_1_1_node}{Node}} of this model. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ Node\+Storage\+Type $>$ $\ast$ $>$ \mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}}
\begin{DoxyCompactList}\small\item\em A list of all edges in this model. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Node\+Storage\+Type$>$\newline
class Markov\+::\+Model$<$ Node\+Storage\+Type $>$}

class for the final \mbox{\hyperlink{namespace_markov}{Markov}} \mbox{\hyperlink{class_markov_1_1_model}{Model}}, constructed from nodes and edges. 

Each atomic piece of the generation result is stored in a node, while edges contain the relation weights. {\itshape Extending\+:} To extend the class, implement the template and inherit from it, as \char`\"{}class My\+Model \+: public Markov\+::\+Model$<$char$>$\char`\"{}. For a complete demonstration of how to extend the class, see \mbox{\hyperlink{class_markov_passwords}{Markov\+Passwords}}.

Whole model can be defined as a list of the edges, as dangling nodes are pointless. This approach is used for the import/export operations. For more information on importing/exporting model, check out the github readme and wiki page. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}\label{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Model@{Model}}
\index{Model@{Model}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Model()}{Model()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::\mbox{\hyperlink{class_markov_1_1_model}{Model}}}



Initialize a model with only start and end nodes. 

Initialize an empty model with only a starter\+Node Starter node is a special kind of node that has constant 0x00 value, and will be used to initiate the generation execution from. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}\label{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!AdjustEdge@{AdjustEdge}}
\index{AdjustEdge@{AdjustEdge}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{AdjustEdge()}{AdjustEdge()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
void \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Adjust\+Edge (\begin{DoxyParamCaption}\item[{const Node\+Storage\+Type $\ast$}]{payload,  }\item[{long int}]{occurrence }\end{DoxyParamCaption})}



Adjust the model with a single string. 

Start from the starter node, and for each character, Adjust\+Edge the edge Edge\+Weight from current node to the next, until N\+U\+LL character is reached.

Then, update the edge Edge\+Weight from current node, to the terminator node.

This function is used for training purposes, as it can be used for adjusting the model with each line of the corpus file.

{\bfseries{Example}} {\bfseries{Use\+:}} Create an empty model and train it with string\+: \char`\"{}testdata\char`\"{} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} model;}
\DoxyCodeLine{\textcolor{keywordtype}{char} test[] = \textcolor{stringliteral}{"testdata"};}
\DoxyCodeLine{model.\mbox{\hyperlink{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}{AdjustEdge}}(test, 15); }
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em string} & -\/ String that is passed from the training, and will be used to Adjust\+Edge the model with \\
\hline
{\em occurrence} & -\/ Occurrence of this string. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}\label{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Edges@{Edges}}
\index{Edges@{Edges}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Edges()}{Edges()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
std\+::vector$<$\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$Node\+Storage\+Type$>$$\ast$$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Edges (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a vector of all the edges in the model. 

\begin{DoxyReturn}{Returns}
vector of edges 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}\label{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Export@{Export}}
\index{Export@{Export}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Export (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Open a file to export with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Model\+::\+Export}} with std\+::ofstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Export file to filename 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} model;}
\DoxyCodeLine{model.\mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}}(\textcolor{stringliteral}{"test.mdl"});}
\end{DoxyCode}
 \mbox{\Hypertarget{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}\label{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Export@{Export}}
\index{Export@{Export}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Export (\begin{DoxyParamCaption}\item[{std\+::ofstream $\ast$}]{f }\end{DoxyParamCaption})}



Export a file of the model. 

File contains a list of edges. Format is\+: Left\+\_\+repr;Edge\+Weight;right\+\_\+repr. For more information on the format, check out the project wiki or github readme.

Iterate over this vertices, and their edges, and write them to file. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models.
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Export file to ofstream 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} model;}
\DoxyCodeLine{std::ofstream file(\textcolor{stringliteral}{"test.mdl"});}
\DoxyCodeLine{model.\mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}}(\&file);}
\end{DoxyCode}
 Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}\label{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Import@{Import}}
\index{Import@{Import}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Import (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Open a file to import with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Model\+::\+Import}} with std\+::ifstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Import a file with filename 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} model;}
\DoxyCodeLine{model.\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(\textcolor{stringliteral}{"test.mdl"});}
\end{DoxyCode}
 \mbox{\Hypertarget{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}\label{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Import@{Import}}
\index{Import@{Import}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Import (\begin{DoxyParamCaption}\item[{std\+::ifstream $\ast$}]{f }\end{DoxyParamCaption})}



Import a file to construct the model. 

File contains a list of edges. For more info on the file format, check out the wiki and github readme pages. Format is\+: Left\+\_\+repr;Edge\+Weight;right\+\_\+repr

Iterate over this list, and construct nodes and edges accordingly. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Import a file from ifstream 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} model;}
\DoxyCodeLine{std::ifstream file(\textcolor{stringliteral}{"test.mdl"});}
\DoxyCodeLine{model.\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(\&file);}
\end{DoxyCode}
 Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}\label{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Nodes@{Nodes}}
\index{Nodes@{Nodes}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Nodes()}{Nodes()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
std\+::map$<$Node\+Storage\+Type, \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$Node\+Storage\+Type$>$$\ast$$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Nodes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. 

\begin{DoxyReturn}{Returns}
starter node with 00 Node\+Value 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}\label{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!RandomWalk@{RandomWalk}}
\index{RandomWalk@{RandomWalk}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{RandomWalk()}{RandomWalk()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
Node\+Storage\+Type $\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Random\+Walk (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{Markov\+::\+Random\+::\+Random\+Engine}} $\ast$}]{random\+Engine,  }\item[{int}]{min\+Setting,  }\item[{int}]{max\+Setting,  }\item[{Node\+Storage\+Type $\ast$}]{buffer }\end{DoxyParamCaption})}



Do a random walk on this model. 

Start from the starter node, on each node, invoke Random\+Next using the random engine on current node, until terminator node is reached. If terminator node is reached before minimum length criateria is reached, ignore the last selection and re-\/invoke random\+Next

If maximum length criteria is reached but final node is not, cut off the generation and proceed to the final node. This function takes \mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{Markov\+::\+Random\+::\+Random\+Engine}} as a parameter to generate pseudo random numbers from

This library is shipped with two random engines, Marsaglia and Mersenne. While mersenne output is higher in entropy, most use cases don\textquotesingle{}t really need super high entropy output, so \mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov\+::\+Random\+::\+Marsaglia}} is preferable for better performance.

This function W\+I\+LL N\+OT reallocate buffer. Make sure no out of bound writes are happening via maximum length criteria.

{\bfseries{Example}} {\bfseries{Use\+:}} Generate 10 lines, with 5 to 10 characters, and print the output. Use Marsaglia 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} model;}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}{Model}}.import(\textcolor{stringliteral}{"model.mdl"});}
\DoxyCodeLine{\textcolor{keywordtype}{char}* res = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[11];}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov::Random::Marsaglia}} MarsagliaRandomEngine;}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 10; i++) \{}
\DoxyCodeLine{    this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{RandomWalk}}(\&MarsagliaRandomEngine, 5, 10, res); }
\DoxyCodeLine{    std::cout << res << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{ \}}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em random\+Engine} & \mbox{\hyperlink{namespace_markov_1_1_random}{Random}} Engine to use for the random walks. For examples, see Markov\+::\+Random\+::\+Mersenne and \mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov\+::\+Random\+::\+Marsaglia}} \\
\hline
{\em min\+Setting} & Minimum number of characters to generate \\
\hline
{\em max\+Setting} & Maximum number of character to generate \\
\hline
{\em buffer} & buffer to write the result to \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Null terminated string that was generated. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}\label{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!StarterNode@{StarterNode}}
\index{StarterNode@{StarterNode}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{StarterNode()}{StarterNode()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$Node\+Storage\+Type$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Starter\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. 

\begin{DoxyReturn}{Returns}
starter node with 00 Node\+Value 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0_icgraph}
\end{center}
\end{figure}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}\label{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!edges@{edges}}
\index{edges@{edges}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{edges}{edges}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
std\+::vector$<$\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$Node\+Storage\+Type$>$$\ast$$>$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::edges\hspace{0.3cm}{\ttfamily [private]}}



A list of all edges in this model. 

\mbox{\Hypertarget{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}\label{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!nodes@{nodes}}
\index{nodes@{nodes}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{nodes}{nodes}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
std\+::map$<$Node\+Storage\+Type, \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$Node\+Storage\+Type$>$$\ast$$>$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::nodes\hspace{0.3cm}{\ttfamily [private]}}



Map Left\+Node is the Nodes Node\+Value Map Right\+Node is the node pointer. 

\mbox{\Hypertarget{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}\label{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!starterNode@{starterNode}}
\index{starterNode@{starterNode}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{starterNode}{starterNode}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$Node\+Storage\+Type$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::starter\+Node\hspace{0.3cm}{\ttfamily [private]}}



Starter \mbox{\hyperlink{class_markov_1_1_node}{Node}} of this model. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/media/ignis/\+H\+D\+D/\+Repositories/\+Markov\+Passwords/\+Markov\+Model/src/\mbox{\hyperlink{model_8h}{model.\+h}}\end{DoxyCompactItemize}
