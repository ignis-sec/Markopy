\hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix}{}\doxysection{Markov\+::A\+PI\+::C\+U\+DA\+::C\+U\+D\+A\+Model\+Matrix Class Reference}
\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix}\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}


Extension of \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix}} which is modified to run on G\+PU devices.  




{\ttfamily \#include $<$cuda\+Model\+Matrix.\+h$>$}



Inheritance diagram for Markov\+::A\+PI\+::C\+U\+DA\+::C\+U\+D\+A\+Model\+Matrix\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Markov\+::A\+PI\+::C\+U\+DA\+::C\+U\+D\+A\+Model\+Matrix\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\+\_\+\+\_\+host\+\_\+\+\_\+ void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a5dd552997a32c0cabf3a6cca6fb07b73}{Migrate\+Matrix}} ()
\begin{DoxyCompactList}\small\item\em Migrate the class members to the V\+R\+AM. \end{DoxyCompactList}\item 
\+\_\+\+\_\+host\+\_\+\+\_\+ void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_ae40af2e90f0500e2780a017f0d39f5e5}{Flatten\+Matrix}} ()
\begin{DoxyCompactList}\small\item\em Flatten migrated matrix from 2d to 1d. \end{DoxyCompactList}\item 
\+\_\+\+\_\+host\+\_\+\+\_\+ void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_ae01dd336827730fa767863430654efe4}{Fast\+Random\+Walk}} (unsigned long int n, const char $\ast$wordlist\+File\+Name, int min\+Len, int max\+Len, bool b\+File\+IO)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_random}{Random}} walk on the Matrix-\/reduced \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aafb5809808b9b0450a0bc98740121b5f}{Construct\+Matrix}} ()
\begin{DoxyCompactList}\small\item\em Construct the related Matrix data for the model. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a405a1c967dfea8d829aa41ad2c14f709}{Dump\+J\+S\+ON}} ()
\begin{DoxyCompactList}\small\item\em Debug function to dump the model to a J\+S\+ON file. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a9e5a9885d48e95b9f5d1ed082d83db24}{Fast\+Random\+Walk}} (unsigned long int n, const char $\ast$wordlist\+File\+Name, int min\+Len=6, int max\+Len=12, int threads=20, bool b\+File\+IO=true)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{namespace_markov_1_1_random}{Random}} walk on the Matrix-\/reduced \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aeba8bb79aa4dc2cfeda310f34b7c9427}{Import}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to import with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Model\+::\+Import}} with std\+::ifstream. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}} (std\+::ifstream $\ast$)
\begin{DoxyCompactList}\small\item\em Import a file to construct the model. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af42d40d7a5c80f0dfe126a574a17f423}{Train}} (const char $\ast$dataset\+File\+Name, char delimiter, int threads)
\begin{DoxyCompactList}\small\item\em Train the model with the dataset file. \end{DoxyCompactList}\item 
std\+::ifstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac3fb665ee48937ca845d930e72e07917}{Open\+Dataset\+File}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open dataset file and return the ifstream pointer. \end{DoxyCompactList}\item 
std\+::ofstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a4f4997da3a6cd3bd2717ce9759736660}{Save}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Export model to file. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39}{Generate}} (unsigned long int n, const char $\ast$wordlist\+File\+Name, int min\+Len=6, int max\+Len=12, int threads=20)
\begin{DoxyCompactList}\small\item\em Call \mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{Markov\+::\+Model\+::\+Random\+Walk}} n times, and collect output. \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{Random\+Walk}} (\mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{Markov\+::\+Random\+::\+Random\+Engine}} $\ast$random\+Engine, int min\+Setting, int max\+Setting, char $\ast$buffer)
\begin{DoxyCompactList}\small\item\em Do a random walk on this model. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}{Adjust\+Edge}} (const char $\ast$payload, long int occurrence)
\begin{DoxyCompactList}\small\item\em Adjust the model with a single string. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}} (std\+::ofstream $\ast$)
\begin{DoxyCompactList}\small\item\em Export a file of the model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}{Export}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to export with filename, and call bool Model\+::\+Export with std\+::ofstream. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ char $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}{Starter\+Node}} ()
\begin{DoxyCompactList}\small\item\em Return starter Node. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ char $>$ $\ast$ $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}{Edges}} ()
\begin{DoxyCompactList}\small\item\em Return a vector of all the edges in the model. \end{DoxyCompactList}\item 
std\+::map$<$ char, \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ char $>$ $\ast$ $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}{Nodes}} ()
\begin{DoxyCompactList}\small\item\em Return starter Node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \+\_\+\+\_\+host\+\_\+\+\_\+ void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_ad1beeb03129fea545cfb18009d2d955f}{List\+Cuda\+Devices}} ()
\begin{DoxyCompactList}\small\item\em List \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{C\+U\+DA}} devices in the system. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\+\_\+\+\_\+host\+\_\+\+\_\+ char $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_ab1ef31ffbad0b0acebbfa2a78c47e349}{Alloc\+V\+R\+A\+M\+Output\+Buffer}} (long int n, long int single\+Gen\+Max\+Len, long int C\+U\+D\+A\+Kernel\+Grid\+Size, long int size\+Per\+Grid)
\begin{DoxyCompactList}\small\item\em Allocate the output buffer for kernel operation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_ad775d2e9c35e6f78c53f796df11405b5}{Fast\+Random\+Walk\+Partition}} (std\+::mutex $\ast$mlock, std\+::ofstream $\ast$wordlist, unsigned long int n, int min\+Len, int max\+Len, bool b\+File\+IO, int threads)
\begin{DoxyCompactList}\small\item\em A single partition of Fast\+Random\+Walk event. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a96f2885aac69b49b21c66ad5a32514b9}{Fast\+Random\+Walk\+Thread}} (std\+::mutex $\ast$mlock, std\+::ofstream $\ast$wordlist, unsigned long int n, int min\+Len, int max\+Len, int id, bool b\+File\+IO)
\begin{DoxyCompactList}\small\item\em A single thread of a single partition of Fast\+Random\+Walk. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a0f95257e1344225233ab49602cd9551c}{Deallocate\+Matrix}} ()
\begin{DoxyCompactList}\small\item\em Deallocate matrix and make it ready for re-\/construction. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
static \+\_\+\+\_\+host\+\_\+\+\_\+ int \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}{Cuda\+Check\+Notify\+Err}} (cuda\+Error\+\_\+t \+\_\+status, const char $\ast$msg, bool b\+Exit=true)
\begin{DoxyCompactList}\small\item\em Check results of the last operation on G\+PU. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static \+\_\+\+\_\+host\+\_\+\+\_\+ cuda\+Error\+\_\+t \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a506aa9d676544d166a21d017ab0aeea2}{Cuda\+Malloc2\+D\+To\+Flat}} (T $\ast$$\ast$dst, int row, int col)
\begin{DoxyCompactList}\small\item\em Malloc a 2D array in device space. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static \+\_\+\+\_\+host\+\_\+\+\_\+ cuda\+Error\+\_\+t \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a5bbde3a16fc7a4b8cdf07e72a31c1f54}{Cuda\+Memcpy2\+D\+To\+Flat}} (T $\ast$dst, T $\ast$$\ast$src, int row, int col)
\begin{DoxyCompactList}\small\item\em Memcpy a 2D array in device space after flattening. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static \+\_\+\+\_\+host\+\_\+\+\_\+ cuda\+Error\+\_\+t \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_abb56db7c9437eb4d71c390fa2b22c738}{Cuda\+Migrate2\+D\+Flat}} (T $\ast$$\ast$dst, T $\ast$$\ast$src, int row, int col)
\begin{DoxyCompactList}\small\item\em Both malloc and memcpy a 2D array into device V\+R\+AM. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
char $\ast$$\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edge\+Matrix}}
\begin{DoxyCompactList}\small\item\em 2-\/D Character array for the edge Matrix (The characters of Nodes) \end{DoxyCompactList}\item 
long int $\ast$$\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{value\+Matrix}}
\begin{DoxyCompactList}\small\item\em 2-\/d Integer array for the value Matrix (For the weights of Edges) \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrix\+Size}}
\begin{DoxyCompactList}\small\item\em to hold Matrix size \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrix\+Index}}
\begin{DoxyCompactList}\small\item\em to hold the Matrix index (To hold the orders of 2-\/D arrays\textquotesingle{}) \end{DoxyCompactList}\item 
long int $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a47bab10980c3117f75909b640a4096df}{total\+Edge\+Weights}}
\begin{DoxyCompactList}\small\item\em Array of the Total \mbox{\hyperlink{class_markov_1_1_edge}{Edge}} Weights. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a6e6994aef7ad847300be6e158e6b3322}{ready}}
\begin{DoxyCompactList}\small\item\em True when matrix is constructed. False if not. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e}{Train\+Thread}} (\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler}{Markov\+::\+A\+P\+I\+::\+Concurrency\+::\+Thread\+Shared\+List\+Handler}} $\ast$listhandler, char delimiter)
\begin{DoxyCompactList}\small\item\em A single thread invoked by the Train function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}{Generate\+Thread}} (std\+::mutex $\ast$output\+Lock, unsigned long int n, std\+::ofstream $\ast$wordlist, int min\+Len, int max\+Len)
\begin{DoxyCompactList}\small\item\em A single thread invoked by the Generate function. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
char $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a06672c27d6c96e9f8808f61c6648f191}{device\+\_\+edge\+Matrix}}
\begin{DoxyCompactList}\small\item\em V\+R\+AM Address pointer of edge matrix (from \mbox{\hyperlink{model_matrix_8h}{model\+Matrix.\+h}}) \end{DoxyCompactList}\item 
long int $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a81e3be9eac6dab929de3b118d9343b27}{device\+\_\+value\+Matrix}}
\begin{DoxyCompactList}\small\item\em V\+R\+AM Address pointer of value matrix (from \mbox{\hyperlink{model_matrix_8h}{model\+Matrix.\+h}}) \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a6a252a7c965c218114ad3d1663c4e840}{device\+\_\+matrix\+Index}}
\begin{DoxyCompactList}\small\item\em V\+R\+AM Address pointer of matrix\+Index (from \mbox{\hyperlink{model_matrix_8h}{model\+Matrix.\+h}}) \end{DoxyCompactList}\item 
long int $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_aae5fdd4bdffc7eb2561fb923024d2615}{device\+\_\+total\+Edge\+Weights}}
\begin{DoxyCompactList}\small\item\em V\+R\+AM Address pointer of total edge weights (from \mbox{\hyperlink{model_matrix_8h}{model\+Matrix.\+h}}) \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a1ec34676837c3cdd5ec2f18a77faec12}{device\+\_\+output\+Buffer}}
\begin{DoxyCompactList}\small\item\em Random\+Walk results in device. \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a26d0692f6a494ab4a2871142b39ce066}{output\+Buffer}}
\begin{DoxyCompactList}\small\item\em Random\+Walk results in host. \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a6345ea79ce015e2a97d1be91a661449a}{flat\+Edge\+Matrix}}
\begin{DoxyCompactList}\small\item\em Adding \mbox{\hyperlink{class_markov_1_1_edge}{Edge}} matrix end-\/to-\/end and resize to 1-\/D array for better perfomance on traversing. \end{DoxyCompactList}\item 
long int $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_abb65a788e9039a3b46cc5cdc76a11130}{flat\+Value\+Matrix}}
\begin{DoxyCompactList}\small\item\em Adding Value matrix end-\/to-\/end and resize to 1-\/D array for better perfomance on traversing. \end{DoxyCompactList}\item 
std\+::ifstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}{dataset\+File}}
\item 
std\+::ofstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_af5f012dcc495dbe769e663d6cb161d6a}{model\+Savefile}}
\begin{DoxyCompactList}\small\item\em Dataset file input of our system ~\newline
 \end{DoxyCompactList}\item 
std\+::ofstream $\ast$ \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac05e60de64e866027410d4fa1cd03248}{output\+File}}
\begin{DoxyCompactList}\small\item\em File to save model of our system ~\newline
 \end{DoxyCompactList}\item 
std\+::map$<$ char, \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ char $>$ $\ast$ $>$ \mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}
\begin{DoxyCompactList}\small\item\em Map Left\+Node is the Nodes Node\+Value Map Right\+Node is the node pointer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ char $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starter\+Node}}
\begin{DoxyCompactList}\small\item\em Starter Node of this model. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ char $>$ $\ast$ $>$ \mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}}
\begin{DoxyCompactList}\small\item\em A list of all edges in this model. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Extension of \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix}} which is modified to run on G\+PU devices. 

This implementation only supports Nvidia devices. 

Definition at line \mbox{\hyperlink{cuda_model_matrix_8h_source_l00011}{11}} of file \mbox{\hyperlink{cuda_model_matrix_8h_source}{cuda\+Model\+Matrix.\+h}}.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}\label{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!AdjustEdge@{AdjustEdge}}
\index{AdjustEdge@{AdjustEdge}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{AdjustEdge()}{AdjustEdge()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Adjust\+Edge (\begin{DoxyParamCaption}\item[{const Node\+Storage\+Type $\ast$}]{payload,  }\item[{long int}]{occurrence }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Adjust the model with a single string. 

Start from the starter node, and for each character, Adjust\+Edge the edge Edge\+Weight from current node to the next, until N\+U\+LL character is reached.

Then, update the edge Edge\+Weight from current node, to the terminator node.

This function is used for training purposes, as it can be used for adjusting the model with each line of the corpus file.

{\bfseries{Example}} {\bfseries{Use\+:}} Create an empty model and train it with string\+: \char`\"{}testdata\char`\"{} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{\textcolor{keywordtype}{char} test[] = \textcolor{stringliteral}{"testdata"};}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.AdjustEdge(test, 15); }
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em string} & -\/ String that is passed from the training, and will be used to Adjust\+Edge the model with \\
\hline
{\em occurrence} & -\/ Occurrence of this string. \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{model_8h_source_l00323}{323}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00323                                                                                                  \{}
\DoxyCodeLine{00324     NodeStorageType p = payload[0];}
\DoxyCodeLine{00325     \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* curnode = this-\/>\mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starterNode}};}
\DoxyCodeLine{00326     \mbox{\hyperlink{class_markov_1_1_edge}{Markov::Edge<NodeStorageType>}}* e;}
\DoxyCodeLine{00327     \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{00328 }
\DoxyCodeLine{00329     \textcolor{keywordflow}{if} (p == 0) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00330     \textcolor{keywordflow}{while} (p != 0) \{}
\DoxyCodeLine{00331         e = curnode-\/>\mbox{\hyperlink{class_markov_1_1_node_ad836573fbdec1c6d7e72945f48ed081c}{FindEdge}}(p);}
\DoxyCodeLine{00332         \textcolor{keywordflow}{if} (e == NULL) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00333         e-\/>\mbox{\hyperlink{class_markov_1_1_edge_aa9d6cc6e631f1b515b4db604c96ad4ad}{AdjustEdge}}(occurrence);}
\DoxyCodeLine{00334         curnode = e-\/>\mbox{\hyperlink{class_markov_1_1_edge_a2e7d14e46631c85c84f6f8f1dd2949cd}{RightNode}}();}
\DoxyCodeLine{00335         p = payload[++i];}
\DoxyCodeLine{00336     \}}
\DoxyCodeLine{00337 }
\DoxyCodeLine{00338     e = curnode-\/>\mbox{\hyperlink{class_markov_1_1_node_ad836573fbdec1c6d7e72945f48ed081c}{FindEdge}}(\textcolor{stringliteral}{'\(\backslash\)xff'});}
\DoxyCodeLine{00339     e-\/>\mbox{\hyperlink{class_markov_1_1_edge_aa9d6cc6e631f1b515b4db604c96ad4ad}{AdjustEdge}}(occurrence);}
\DoxyCodeLine{00340     \textcolor{keywordflow}{return};}
\DoxyCodeLine{00341 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_ab1ef31ffbad0b0acebbfa2a78c47e349}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_ab1ef31ffbad0b0acebbfa2a78c47e349}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!AllocVRAMOutputBuffer@{AllocVRAMOutputBuffer}}
\index{AllocVRAMOutputBuffer@{AllocVRAMOutputBuffer}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{AllocVRAMOutputBuffer()}{AllocVRAMOutputBuffer()}}
{\footnotesize\ttfamily \+\_\+\+\_\+host\+\_\+\+\_\+ char$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::\+Alloc\+V\+R\+A\+M\+Output\+Buffer (\begin{DoxyParamCaption}\item[{long int}]{n,  }\item[{long int}]{single\+Gen\+Max\+Len,  }\item[{long int}]{C\+U\+D\+A\+Kernel\+Grid\+Size,  }\item[{long int}]{size\+Per\+Grid }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Allocate the output buffer for kernel operation. 

T\+O\+DO


\begin{DoxyParams}{Parameters}
{\em n} & -\/ Number of passwords to generate. \\
\hline
{\em single\+Gen\+Max\+Len} & -\/ maximum string length for a single generation \\
\hline
{\em C\+U\+D\+A\+Kernel\+Grid\+Size} & -\/ Total number of grid members in \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{C\+U\+DA}} kernel \\
\hline
{\em size\+Per\+Grid} & -\/ Size to allocate per grid member \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the allocation on V\+R\+AM 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_aafb5809808b9b0450a0bc98740121b5f}\label{class_markov_1_1_a_p_i_1_1_model_matrix_aafb5809808b9b0450a0bc98740121b5f}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!ConstructMatrix@{ConstructMatrix}}
\index{ConstructMatrix@{ConstructMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{ConstructMatrix()}{ConstructMatrix()}}
{\footnotesize\ttfamily bool Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Construct the related Matrix data for the model. 

This operation can be used after importing/training to allocate and populate the matrix content.

this will initialize\+: char$\ast$$\ast$ edge\+Matrix -\/$>$ a 2D array of mapping left and right connections of each edge. long int $\ast$$\ast$value\+Matrix -\/$>$ a 2D array representing the edge weights. int matrix\+Size -\/$>$ Size of the matrix, aka total number of nodes. char$\ast$ matrix\+Index -\/$>$ order of nodes in the model long int $\ast$total\+Edge\+Weights -\/$>$ total edge weights of each \mbox{\hyperlink{class_markov_1_1_node}{Node}}.

\begin{DoxyReturn}{Returns}
True if constructed. False if already construced. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_matrix_8cpp_source_l00022}{22}} of file \mbox{\hyperlink{model_matrix_8cpp_source}{model\+Matrix.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00022                                           \{}
\DoxyCodeLine{00023     \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a6e6994aef7ad847300be6e158e6b3322}{ready}}) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00024     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}} = this-\/>\mbox{\hyperlink{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}{StarterNode}}()-\/>\mbox{\hyperlink{class_markov_1_1_node_ad2ac18d9abd220dfd90b9df6f92c5d59}{edgesV}}.size() + 2;}
\DoxyCodeLine{00025 }
\DoxyCodeLine{00026     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}} = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}}];}
\DoxyCodeLine{00027     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a47bab10980c3117f75909b640a4096df}{totalEdgeWeights}} = \textcolor{keyword}{new} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int}[this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}}];}
\DoxyCodeLine{00028 }
\DoxyCodeLine{00029     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}} = \textcolor{keyword}{new} \textcolor{keywordtype}{char}*[this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}}];}
\DoxyCodeLine{00030     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};i++)\{}
\DoxyCodeLine{00031         this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i] = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}}];}
\DoxyCodeLine{00032     \}}
\DoxyCodeLine{00033     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}} = \textcolor{keyword}{new} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int}*[this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}}];}
\DoxyCodeLine{00034     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};i++)\{}
\DoxyCodeLine{00035         this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}}[i] = \textcolor{keyword}{new} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int}[this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}}];}
\DoxyCodeLine{00036     \}}
\DoxyCodeLine{00037     std::map< char, Node< char > * > *\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}};}
\DoxyCodeLine{00038     \mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}} = this-\/>\mbox{\hyperlink{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}{Nodes}}();}
\DoxyCodeLine{00039     \textcolor{keywordtype}{int} i=0;}
\DoxyCodeLine{00040     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& [repr, node] : *\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}})\{}
\DoxyCodeLine{00041         \textcolor{keywordflow}{if}(repr!=0) this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i] = repr;}
\DoxyCodeLine{00042         \textcolor{keywordflow}{else} this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i] = 199;}
\DoxyCodeLine{00043         this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a47bab10980c3117f75909b640a4096df}{totalEdgeWeights}}[i] = node-\/>TotalEdgeWeights();}
\DoxyCodeLine{00044         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};j++)\{}
\DoxyCodeLine{00045             \textcolor{keywordtype}{char} val = node-\/>NodeValue();}
\DoxyCodeLine{00046             \textcolor{keywordflow}{if}(val < 0)\{}
\DoxyCodeLine{00047                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0;k<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};k++)\{}
\DoxyCodeLine{00048                     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}}[i][k] = 0;}
\DoxyCodeLine{00049                     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i][k] = 255;}
\DoxyCodeLine{00050                 \}}
\DoxyCodeLine{00051                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{00052             \}}
\DoxyCodeLine{00053             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(node-\/>NodeValue() == 0 \&\& j>(this-\/>matrixSize-\/3))\{}
\DoxyCodeLine{00054                 this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}}[i][j] = 0;}
\DoxyCodeLine{00055                 this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i][j] = 255;}
\DoxyCodeLine{00056             \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(j==(this-\/>matrixSize-\/1)) \{}
\DoxyCodeLine{00057                 this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}}[i][j] = 0;}
\DoxyCodeLine{00058                 this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i][j] = 255;}
\DoxyCodeLine{00059             \}\textcolor{keywordflow}{else}\{}
\DoxyCodeLine{00060                 this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}}[i][j] = node-\/>edgesV[j]-\/>EdgeWeight();}
\DoxyCodeLine{00061                 this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i][j]  = node-\/>edgesV[j]-\/>RightNode()-\/>NodeValue();}
\DoxyCodeLine{00062             \}}
\DoxyCodeLine{00063 }
\DoxyCodeLine{00064         \}}
\DoxyCodeLine{00065         i++;}
\DoxyCodeLine{00066     \}}
\DoxyCodeLine{00067     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a6e6994aef7ad847300be6e158e6b3322}{ready}} = \textcolor{keyword}{true};}
\DoxyCodeLine{00068     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00069     \textcolor{comment}{//this-\/>DumpJSON();}}
\DoxyCodeLine{00070 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_matrix_8h_source_l00136}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::edge\+Matrix}}, \mbox{\hyperlink{edge_8h_source_l00153}{Markov\+::\+Edge$<$ Node\+Storage\+Type $>$\+::\+Edge\+Weight()}}, \mbox{\hyperlink{model_matrix_8h_source_l00151}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Index}}, \mbox{\hyperlink{model_matrix_8h_source_l00146}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Size}}, \mbox{\hyperlink{model_8h_source_l00177}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Nodes()}}, \mbox{\hyperlink{node_8h_source_l00207}{Markov\+::\+Node$<$ storage\+Type $>$\+::\+Node\+Value()}}, \mbox{\hyperlink{model_matrix_8h_source_l00161}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::ready}}, \mbox{\hyperlink{edge_8h_source_l00163}{Markov\+::\+Edge$<$ Node\+Storage\+Type $>$\+::\+Right\+Node()}}, \mbox{\hyperlink{model_8h_source_l00167}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Starter\+Node()}}, \mbox{\hyperlink{model_matrix_8h_source_l00156}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::total\+Edge\+Weights}}, \mbox{\hyperlink{node_8h_source_l00269}{Markov\+::\+Node$<$ storage\+Type $>$\+::\+Total\+Edge\+Weights()}}, and \mbox{\hyperlink{model_matrix_8h_source_l00141}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::value\+Matrix}}.



Referenced by \mbox{\hyperlink{markopy_8cpp_source_l00012}{Markov\+::\+Markopy\+::\+B\+O\+O\+S\+T\+\_\+\+P\+Y\+T\+H\+O\+N\+\_\+\+M\+O\+D\+U\+L\+E()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00010}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Import()}}, and \mbox{\hyperlink{model_matrix_8cpp_source_l00016}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Train()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_aafb5809808b9b0450a0bc98740121b5f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_aafb5809808b9b0450a0bc98740121b5f_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!CudaCheckNotifyErr@{CudaCheckNotifyErr}}
\index{CudaCheckNotifyErr@{CudaCheckNotifyErr}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{CudaCheckNotifyErr()}{CudaCheckNotifyErr()}}
{\footnotesize\ttfamily static \+\_\+\+\_\+host\+\_\+\+\_\+ int Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Check\+Notify\+Err (\begin{DoxyParamCaption}\item[{cuda\+Error\+\_\+t}]{\+\_\+status,  }\item[{const char $\ast$}]{msg,  }\item[{bool}]{b\+Exit = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}, {\ttfamily [inherited]}}



Check results of the last operation on G\+PU. 

Check the status returned from cuda\+Malloc/cuda\+Memcpy to find failures.

If a failure occurs, its assumed beyond redemption, and exited. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+status} & Cuda error status to check \\
\hline
{\em msg} & Message to print in case of a failure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if successful, 1 if failure. {\bfseries{Example}} {\bfseries{output\+:}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{char} *da, a = \textcolor{stringliteral}{"test"};}
\DoxyCodeLine{cudastatus = cudaMalloc((\textcolor{keywordtype}{char} **)\&da, 5*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}*));}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}{CudaCheckNotifyErr}}(cudastatus, \textcolor{stringliteral}{"Failed to allocate VRAM for *da.\(\backslash\)n"});}
\end{DoxyCode}
 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a506aa9d676544d166a21d017ab0aeea2}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a506aa9d676544d166a21d017ab0aeea2}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!CudaMalloc2DToFlat@{CudaMalloc2DToFlat}}
\index{CudaMalloc2DToFlat@{CudaMalloc2DToFlat}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{CudaMalloc2DToFlat()}{CudaMalloc2DToFlat()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
static \+\_\+\+\_\+host\+\_\+\+\_\+ cuda\+Error\+\_\+t Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Malloc2\+D\+To\+Flat (\begin{DoxyParamCaption}\item[{T $\ast$$\ast$}]{dst,  }\item[{int}]{row,  }\item[{int}]{col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}, {\ttfamily [inherited]}}



Malloc a 2D array in device space. 

This function will allocate enough space on V\+R\+AM for flattened 2D array.


\begin{DoxyParams}{Parameters}
{\em dst} & destination pointer \\
\hline
{\em row} & row size of the 2d array \\
\hline
{\em col} & column size of the 2d array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cuda\+Error\+\_\+t status of the cuda\+Malloc operation
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{output\+:}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{cudaError\_t cudastatus;}
\DoxyCodeLine{\textcolor{keywordtype}{char}* dst;}
\DoxyCodeLine{cudastatus = CudaMalloc2DToFlat<char>(\&dst, 5, 15);}
\DoxyCodeLine{\textcolor{keywordflow}{if}(cudastatus!=cudaSuccess)\{}
\DoxyCodeLine{    \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}{CudaCheckNotifyErr}}(cudastatus, \textcolor{stringliteral}{"  CudaMalloc2DToFlat Failed."}, \textcolor{keyword}{false});}
\DoxyCodeLine{\}}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{cuda_device_controller_8h_source_l00073}{73}} of file \mbox{\hyperlink{cuda_device_controller_8h_source}{cuda\+Device\+Controller.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00073                                                                                  \{}
\DoxyCodeLine{00074             cudaError\_t cudastatus = cudaMalloc((T **)dst, row*col*\textcolor{keyword}{sizeof}(T));}
\DoxyCodeLine{00075             \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}{CudaCheckNotifyErr}}(cudastatus, \textcolor{stringliteral}{"cudaMalloc Failed."}, \textcolor{keyword}{false});}
\DoxyCodeLine{00076             \textcolor{keywordflow}{return} cudastatus;}
\DoxyCodeLine{00077         \}}

\end{DoxyCode}


References \mbox{\hyperlink{cuda_device_controller_8h_source_l00130}{Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Migrate2\+D\+Flat()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a506aa9d676544d166a21d017ab0aeea2_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a5bbde3a16fc7a4b8cdf07e72a31c1f54}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a5bbde3a16fc7a4b8cdf07e72a31c1f54}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!CudaMemcpy2DToFlat@{CudaMemcpy2DToFlat}}
\index{CudaMemcpy2DToFlat@{CudaMemcpy2DToFlat}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{CudaMemcpy2DToFlat()}{CudaMemcpy2DToFlat()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
static \+\_\+\+\_\+host\+\_\+\+\_\+ cuda\+Error\+\_\+t Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Memcpy2\+D\+To\+Flat (\begin{DoxyParamCaption}\item[{T $\ast$}]{dst,  }\item[{T $\ast$$\ast$}]{src,  }\item[{int}]{row,  }\item[{int}]{col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}, {\ttfamily [inherited]}}



Memcpy a 2D array in device space after flattening. 

Resulting buffer will not be true 2D array.


\begin{DoxyParams}{Parameters}
{\em dst} & destination pointer \\
\hline
{\em rc} & source pointer \\
\hline
{\em row} & row size of the 2d array \\
\hline
{\em col} & column size of the 2d array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cuda\+Error\+\_\+t status of the cuda\+Malloc operation
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{output\+:}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{cudaError\_t cudastatus;}
\DoxyCodeLine{\textcolor{keywordtype}{char}* dst;}
\DoxyCodeLine{cudastatus = CudaMalloc2DToFlat<char>(\&dst, 5, 15);}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}{CudaCheckNotifyErr}}(cudastatus, \textcolor{stringliteral}{"  CudaMalloc2DToFlat Failed."}, \textcolor{keyword}{false});}
\DoxyCodeLine{cudastatus = CudaMemcpy2DToFlat<char>(*dst,src,15,15);}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}{CudaCheckNotifyErr}}(cudastatus, \textcolor{stringliteral}{"  CudaMemcpy2DToFlat Failed."}, \textcolor{keyword}{false});}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{cuda_device_controller_8h_source_l00101}{101}} of file \mbox{\hyperlink{cuda_device_controller_8h_source}{cuda\+Device\+Controller.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00101                                                                                          \{}
\DoxyCodeLine{00102             T* tempbuf = \textcolor{keyword}{new} T[row*col];}
\DoxyCodeLine{00103             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<row;i++)\{}
\DoxyCodeLine{00104                 memcpy(\&(tempbuf[row*i]), src[i], col);}
\DoxyCodeLine{00105             \}}
\DoxyCodeLine{00106             \textcolor{keywordflow}{return} cudaMemcpy(dst, tempbuf, row*col*\textcolor{keyword}{sizeof}(T), cudaMemcpyHostToDevice);}
\DoxyCodeLine{00107             }
\DoxyCodeLine{00108         \}}

\end{DoxyCode}


References \mbox{\hyperlink{cuda_device_controller_8h_source_l00130}{Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Migrate2\+D\+Flat()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a5bbde3a16fc7a4b8cdf07e72a31c1f54_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_abb56db7c9437eb4d71c390fa2b22c738}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_abb56db7c9437eb4d71c390fa2b22c738}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!CudaMigrate2DFlat@{CudaMigrate2DFlat}}
\index{CudaMigrate2DFlat@{CudaMigrate2DFlat}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{CudaMigrate2DFlat()}{CudaMigrate2DFlat()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
static \+\_\+\+\_\+host\+\_\+\+\_\+ cuda\+Error\+\_\+t Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Migrate2\+D\+Flat (\begin{DoxyParamCaption}\item[{T $\ast$$\ast$}]{dst,  }\item[{T $\ast$$\ast$}]{src,  }\item[{int}]{row,  }\item[{int}]{col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}, {\ttfamily [inherited]}}



Both malloc and memcpy a 2D array into device V\+R\+AM. 

Resulting buffer will not be true 2D array.


\begin{DoxyParams}{Parameters}
{\em dst} & destination pointer \\
\hline
{\em rc} & source pointer \\
\hline
{\em row} & row size of the 2d array \\
\hline
{\em col} & column size of the 2d array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cuda\+Error\+\_\+t status of the cuda\+Malloc operation
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{output\+:}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{cudaError\_t cudastatus;}
\DoxyCodeLine{\textcolor{keywordtype}{char}* dst;}
\DoxyCodeLine{cudastatus = CudaMigrate2DFlat<long int>(}
\DoxyCodeLine{   \&dst, this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}}, this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}}, this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}});}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}{CudaCheckNotifyErr}}(cudastatus, \textcolor{stringliteral}{"    Cuda failed to initialize value matrix row."});}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{cuda_device_controller_8h_source_l00130}{130}} of file \mbox{\hyperlink{cuda_device_controller_8h_source}{cuda\+Device\+Controller.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00130                                                                                          \{}
\DoxyCodeLine{00131             cudaError\_t cudastatus;}
\DoxyCodeLine{00132             cudastatus = CudaMalloc2DToFlat<T>(dst, row, col);}
\DoxyCodeLine{00133             \textcolor{keywordflow}{if}(cudastatus!=cudaSuccess)\{}
\DoxyCodeLine{00134                 \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}{CudaCheckNotifyErr}}(cudastatus, \textcolor{stringliteral}{"  CudaMalloc2DToFlat Failed."}, \textcolor{keyword}{false});}
\DoxyCodeLine{00135                 \textcolor{keywordflow}{return} cudastatus;}
\DoxyCodeLine{00136             \}}
\DoxyCodeLine{00137             cudastatus = CudaMemcpy2DToFlat<T>(*dst,src,row,col);}
\DoxyCodeLine{00138             \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_a61c65866ecf7fe229c01fcc0f9c10711}{CudaCheckNotifyErr}}(cudastatus, \textcolor{stringliteral}{"  CudaMemcpy2DToFlat Failed."}, \textcolor{keyword}{false});}
\DoxyCodeLine{00139             \textcolor{keywordflow}{return} cudastatus;}
\DoxyCodeLine{00140         \}}

\end{DoxyCode}


References \mbox{\hyperlink{cuda_device_controller_8h_source_l00130}{Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Migrate2\+D\+Flat()}}.



Referenced by \mbox{\hyperlink{cuda_device_controller_8h_source_l00073}{Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Malloc2\+D\+To\+Flat()}}, \mbox{\hyperlink{cuda_device_controller_8h_source_l00101}{Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Memcpy2\+D\+To\+Flat()}}, and \mbox{\hyperlink{cuda_device_controller_8h_source_l00130}{Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+Cuda\+Migrate2\+D\+Flat()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=230pt]{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_abb56db7c9437eb4d71c390fa2b22c738_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_abb56db7c9437eb4d71c390fa2b22c738_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_a0f95257e1344225233ab49602cd9551c}\label{class_markov_1_1_a_p_i_1_1_model_matrix_a0f95257e1344225233ab49602cd9551c}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!DeallocateMatrix@{DeallocateMatrix}}
\index{DeallocateMatrix@{DeallocateMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{DeallocateMatrix()}{DeallocateMatrix()}}
{\footnotesize\ttfamily bool Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Deallocate\+Matrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}



Deallocate matrix and make it ready for re-\/construction. 

\begin{DoxyReturn}{Returns}
True if deallocated. False if matrix was not initialized 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_matrix_8cpp_source_l00072}{72}} of file \mbox{\hyperlink{model_matrix_8cpp_source}{model\+Matrix.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00072                                            \{}
\DoxyCodeLine{00073     \textcolor{keywordflow}{if}(!this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a6e6994aef7ad847300be6e158e6b3322}{ready}}) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00074     \textcolor{keyword}{delete}[] this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}};}
\DoxyCodeLine{00075     \textcolor{keyword}{delete}[] this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a47bab10980c3117f75909b640a4096df}{totalEdgeWeights}};}
\DoxyCodeLine{00076 }
\DoxyCodeLine{00077     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};i++)\{}
\DoxyCodeLine{00078         \textcolor{keyword}{delete}[] this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i];}
\DoxyCodeLine{00079     \}}
\DoxyCodeLine{00080     \textcolor{keyword}{delete}[] this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}};}
\DoxyCodeLine{00081 }
\DoxyCodeLine{00082     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};i++)\{}
\DoxyCodeLine{00083         \textcolor{keyword}{delete}[] this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}}[i];}
\DoxyCodeLine{00084     \}}
\DoxyCodeLine{00085     \textcolor{keyword}{delete}[] this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}};}
\DoxyCodeLine{00086 }
\DoxyCodeLine{00087     this-\/>matrixSize = -\/1;}
\DoxyCodeLine{00088     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a6e6994aef7ad847300be6e158e6b3322}{ready}} = \textcolor{keyword}{false};}
\DoxyCodeLine{00089     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00090 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_matrix_8h_source_l00136}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::edge\+Matrix}}, \mbox{\hyperlink{model_matrix_8h_source_l00151}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Index}}, \mbox{\hyperlink{model_matrix_8h_source_l00146}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Size}}, \mbox{\hyperlink{model_matrix_8h_source_l00161}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::ready}}, \mbox{\hyperlink{model_matrix_8h_source_l00156}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::total\+Edge\+Weights}}, and \mbox{\hyperlink{model_matrix_8h_source_l00141}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::value\+Matrix}}.



Referenced by \mbox{\hyperlink{model_matrix_8cpp_source_l00010}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Import()}}, and \mbox{\hyperlink{model_matrix_8cpp_source_l00016}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Train()}}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_a0f95257e1344225233ab49602cd9551c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_a405a1c967dfea8d829aa41ad2c14f709}\label{class_markov_1_1_a_p_i_1_1_model_matrix_a405a1c967dfea8d829aa41ad2c14f709}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!DumpJSON@{DumpJSON}}
\index{DumpJSON@{DumpJSON}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{DumpJSON()}{DumpJSON()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Dump\+J\+S\+ON (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Debug function to dump the model to a J\+S\+ON file. 

Might not work 100\%. Not meant for production use. 

Definition at line \mbox{\hyperlink{model_matrix_8cpp_source_l00092}{92}} of file \mbox{\hyperlink{model_matrix_8cpp_source}{model\+Matrix.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00092                                    \{}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094     std::cout << \textcolor{stringliteral}{"\{\(\backslash\)n   \(\backslash\)"index\(\backslash\)": \(\backslash\)""};}
\DoxyCodeLine{00095     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};i++)\{}
\DoxyCodeLine{00096         \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i]==\textcolor{charliteral}{'"'}) std::cout << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)\(\backslash\)""};}
\DoxyCodeLine{00097         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i]==\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) std::cout << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"};}
\DoxyCodeLine{00098         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i]==0) std::cout << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)x00"};}
\DoxyCodeLine{00099         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(i==0) std::cout << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)xff"};}
\DoxyCodeLine{00100         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i]==\textcolor{charliteral}{'\(\backslash\)n'}) std::cout << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)n"};}
\DoxyCodeLine{00101         \textcolor{keywordflow}{else} std::cout << this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i];}
\DoxyCodeLine{00102     \}}
\DoxyCodeLine{00103     std::cout << }
\DoxyCodeLine{00104     \textcolor{stringliteral}{"\(\backslash\)",\(\backslash\)n"}}
\DoxyCodeLine{00105     \textcolor{stringliteral}{"   \(\backslash\)"edgemap\(\backslash\)": \{\(\backslash\)n"};}
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};i++)\{}
\DoxyCodeLine{00108         \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i]==\textcolor{charliteral}{'"'}) std::cout << \textcolor{stringliteral}{"      \(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)"\(\backslash\)": ["};}
\DoxyCodeLine{00109         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i]==\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) std::cout << \textcolor{stringliteral}{"      \(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)": ["};}
\DoxyCodeLine{00110         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i]==0) std::cout << \textcolor{stringliteral}{"      \(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)x00\(\backslash\)": ["};}
\DoxyCodeLine{00111         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i]<0) std::cout << \textcolor{stringliteral}{"      \(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)xff\(\backslash\)": ["};}
\DoxyCodeLine{00112         \textcolor{keywordflow}{else} std::cout << \textcolor{stringliteral}{"      \(\backslash\)""} << this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}[i] << \textcolor{stringliteral}{"\(\backslash\)": ["};}
\DoxyCodeLine{00113         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};j++)\{}
\DoxyCodeLine{00114             \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i][j]==\textcolor{charliteral}{'"'}) std::cout << \textcolor{stringliteral}{"\(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)"\(\backslash\)""};}
\DoxyCodeLine{00115             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i][j]==\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) std::cout << \textcolor{stringliteral}{"\(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)""};}
\DoxyCodeLine{00116             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i][j]==0) std::cout << \textcolor{stringliteral}{"\(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)x00\(\backslash\)""};}
\DoxyCodeLine{00117             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i][j]<0) std::cout << \textcolor{stringliteral}{"\(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)xff\(\backslash\)""};}
\DoxyCodeLine{00118             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>matrixIndex[i]==\textcolor{charliteral}{'\(\backslash\)n'}) std::cout << \textcolor{stringliteral}{"\(\backslash\)"\(\backslash\)\(\backslash\)n\(\backslash\)""};}
\DoxyCodeLine{00119             \textcolor{keywordflow}{else} std::cout << \textcolor{stringliteral}{"\(\backslash\)""} << this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[i][j] << \textcolor{stringliteral}{"\(\backslash\)""};}
\DoxyCodeLine{00120             \textcolor{keywordflow}{if}(j!=this-\/>matrixSize-\/1) std::cout << \textcolor{stringliteral}{", "};}
\DoxyCodeLine{00121         \}}
\DoxyCodeLine{00122         std::cout << \textcolor{stringliteral}{"],\(\backslash\)n"};}
\DoxyCodeLine{00123     \}}
\DoxyCodeLine{00124     std::cout << \textcolor{stringliteral}{"\},\(\backslash\)n"};}
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126     std::cout << \textcolor{stringliteral}{"\(\backslash\)"   weightmap\(\backslash\)": \{\(\backslash\)n"};}
\DoxyCodeLine{00127     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};i++)\{}
\DoxyCodeLine{00128         \textcolor{keywordflow}{if}(this-\/>matrixIndex[i]==\textcolor{charliteral}{'"'}) std::cout << \textcolor{stringliteral}{"      \(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)"\(\backslash\)": ["};}
\DoxyCodeLine{00129         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>matrixIndex[i]==\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) std::cout << \textcolor{stringliteral}{"      \(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)": ["};}
\DoxyCodeLine{00130         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>matrixIndex[i]==0) std::cout << \textcolor{stringliteral}{"      \(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)x00\(\backslash\)": ["};}
\DoxyCodeLine{00131         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(this-\/>matrixIndex[i]<0) std::cout << \textcolor{stringliteral}{"      \(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)xff\(\backslash\)": ["};}
\DoxyCodeLine{00132         \textcolor{keywordflow}{else} std::cout << \textcolor{stringliteral}{"      \(\backslash\)""} << this-\/>matrixIndex[i] << \textcolor{stringliteral}{"\(\backslash\)": ["};}
\DoxyCodeLine{00133 }
\DoxyCodeLine{00134         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};j++)\{}
\DoxyCodeLine{00135             std::cout << this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}}[i][j];}
\DoxyCodeLine{00136             \textcolor{keywordflow}{if}(j!=this-\/>matrixSize-\/1) std::cout << \textcolor{stringliteral}{", "};}
\DoxyCodeLine{00137         \}}
\DoxyCodeLine{00138         std::cout << \textcolor{stringliteral}{"],\(\backslash\)n"};}
\DoxyCodeLine{00139     \}}
\DoxyCodeLine{00140     std::cout << \textcolor{stringliteral}{"  \}\(\backslash\)n\}\(\backslash\)n"};}
\DoxyCodeLine{00141 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_matrix_8h_source_l00136}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::edge\+Matrix}}, \mbox{\hyperlink{model_matrix_8h_source_l00151}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Index}}, \mbox{\hyperlink{model_matrix_8h_source_l00146}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Size}}, and \mbox{\hyperlink{model_matrix_8h_source_l00141}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::value\+Matrix}}.



Referenced by \mbox{\hyperlink{markopy_8cpp_source_l00012}{Markov\+::\+Markopy\+::\+B\+O\+O\+S\+T\+\_\+\+P\+Y\+T\+H\+O\+N\+\_\+\+M\+O\+D\+U\+L\+E()}}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_a405a1c967dfea8d829aa41ad2c14f709_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}\label{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!Edges@{Edges}}
\index{Edges@{Edges}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{Edges()}{Edges()}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$char $>$$\ast$$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Edges (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [inherited]}}



Return a vector of all the edges in the model. 

\begin{DoxyReturn}{Returns}
vector of edges 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_8h_source_l00172}{172}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00172 \{ \textcolor{keywordflow}{return} \&\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}};\}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}\label{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!Export@{Export}}
\index{Export@{Export}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Export (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Open a file to export with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Model\+::\+Export}} with std\+::ofstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Export file to filename 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.Export(\textcolor{stringliteral}{"test.mdl"});}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{model_8h_source_l00286}{286}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00286                                                               \{}
\DoxyCodeLine{00287     std::ofstream exportfile;}
\DoxyCodeLine{00288     exportfile.open(filename);}
\DoxyCodeLine{00289     \textcolor{keywordflow}{return} this-\/>\mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}}(\&exportfile);}
\DoxyCodeLine{00290 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}\label{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!Export@{Export}}
\index{Export@{Export}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Export (\begin{DoxyParamCaption}\item[{std\+::ofstream $\ast$}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Export a file of the model. 

File contains a list of edges. Format is\+: Left\+\_\+repr;Edge\+Weight;right\+\_\+repr. For more information on the format, check out the project wiki or github readme.

Iterate over this vertices, and their edges, and write them to file. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models.
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Export file to ofstream 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{std::ofstream file(\textcolor{stringliteral}{"test.mdl"});}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.Export(\&file);}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{model_8h_source_l00274}{274}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00274                                                         \{}
\DoxyCodeLine{00275     \mbox{\hyperlink{class_markov_1_1_edge}{Markov::Edge<NodeStorageType>}}* e;}
\DoxyCodeLine{00276     \textcolor{keywordflow}{for} (std::vector<int>::size\_type i = 0; i != this-\/>\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}}.size(); i++) \{}
\DoxyCodeLine{00277         e = this-\/>\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}}[i];}
\DoxyCodeLine{00278         \textcolor{comment}{//std::cout << e-\/>LeftNode()-\/>NodeValue() << "," << e-\/>EdgeWeight() << "," << e-\/>RightNode()-\/>NodeValue() << "\(\backslash\)n";}}
\DoxyCodeLine{00279         *\mbox{\hyperlink{namespacemodel__2gram_a2c21010331f2adf96f64d1e90d019e76}{f}} << e-\/>\mbox{\hyperlink{class_markov_1_1_edge_a3975b42a420de76e216d343dca059f88}{LeftNode}}()-\/>\mbox{\hyperlink{class_markov_1_1_node_ac7cce56376f2a00764f64a0194cbb498}{NodeValue}}() << \textcolor{stringliteral}{","} << e-\/>\mbox{\hyperlink{class_markov_1_1_edge_a2b1e5a6e6f81502cd8ac6b20ed38b677}{EdgeWeight}}() << \textcolor{stringliteral}{","} << e-\/>\mbox{\hyperlink{class_markov_1_1_edge_a2e7d14e46631c85c84f6f8f1dd2949cd}{RightNode}}()-\/>\mbox{\hyperlink{class_markov_1_1_node_ac7cce56376f2a00764f64a0194cbb498}{NodeValue}}() << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{00280     \}}
\DoxyCodeLine{00281 }
\DoxyCodeLine{00282     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00283 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_ae01dd336827730fa767863430654efe4}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_ae01dd336827730fa767863430654efe4}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!FastRandomWalk@{FastRandomWalk}}
\index{FastRandomWalk@{FastRandomWalk}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{FastRandomWalk()}{FastRandomWalk()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \+\_\+\+\_\+host\+\_\+\+\_\+ void Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::\+Fast\+Random\+Walk (\begin{DoxyParamCaption}\item[{unsigned long int}]{n,  }\item[{const char $\ast$}]{wordlist\+File\+Name,  }\item[{int}]{min\+Len,  }\item[{int}]{max\+Len,  }\item[{bool}]{b\+File\+IO }\end{DoxyParamCaption})}



\mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_random}{Random}} walk on the Matrix-\/reduced \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}. 

T\+O\+DO


\begin{DoxyParams}{Parameters}
{\em n} & -\/ Number of passwords to generate. \\
\hline
{\em wordlist\+File\+Name} & -\/ Filename to write to \\
\hline
{\em min\+Len} & -\/ Minimum password length to generate \\
\hline
{\em max\+Len} & -\/ Maximum password length to generate \\
\hline
{\em threads} & -\/ number of OS threads to spawn \\
\hline
{\em b\+File\+IO} & -\/ If false, filename will be ignored and will output to stdout.\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix}{Markov::API::ModelMatrix}} mp;}
\DoxyCodeLine{mp.\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aeba8bb79aa4dc2cfeda310f34b7c9427}{Import}}(\textcolor{stringliteral}{"models/finished.mdl"});}
\DoxyCodeLine{mp.\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a9e5a9885d48e95b9f5d1ed082d83db24}{FastRandomWalk}}(50000000,\textcolor{stringliteral}{"./wordlist.txt"},6,12,25, \textcolor{keyword}{true});}
\end{DoxyCode}
 \mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_a9e5a9885d48e95b9f5d1ed082d83db24}\label{class_markov_1_1_a_p_i_1_1_model_matrix_a9e5a9885d48e95b9f5d1ed082d83db24}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!FastRandomWalk@{FastRandomWalk}}
\index{FastRandomWalk@{FastRandomWalk}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{FastRandomWalk()}{FastRandomWalk()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk (\begin{DoxyParamCaption}\item[{unsigned long int}]{n,  }\item[{const char $\ast$}]{wordlist\+File\+Name,  }\item[{int}]{min\+Len = {\ttfamily 6},  }\item[{int}]{max\+Len = {\ttfamily 12},  }\item[{int}]{threads = {\ttfamily 20},  }\item[{bool}]{b\+File\+IO = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



\mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_random}{Random}} walk on the Matrix-\/reduced \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}. 

This has an O(\+N) Memory complexity. To limit the maximum usage, requests with n$>$50M are partitioned using \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_ad775d2e9c35e6f78c53f796df11405b5}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Partition}}.

If n$>$50M, threads are going to be synced, files are going to be flushed, and buffers will be reallocated every 50M generations. This comes at a minor performance penalty.

While it has the same functionality, this operation reduces \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39}{Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Generate}} runtime by \%96.\+5

This function has deprecated \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39}{Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Generate}}, and will eventually replace it.


\begin{DoxyParams}{Parameters}
{\em n} & -\/ Number of passwords to generate. \\
\hline
{\em wordlist\+File\+Name} & -\/ Filename to write to \\
\hline
{\em min\+Len} & -\/ Minimum password length to generate \\
\hline
{\em max\+Len} & -\/ Maximum password length to generate \\
\hline
{\em threads} & -\/ number of OS threads to spawn \\
\hline
{\em b\+File\+IO} & -\/ If false, filename will be ignored and will output to stdout.\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix}{Markov::API::ModelMatrix}} mp;}
\DoxyCodeLine{mp.\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aeba8bb79aa4dc2cfeda310f34b7c9427}{Import}}(\textcolor{stringliteral}{"models/finished.mdl"});}
\DoxyCodeLine{mp.\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a9e5a9885d48e95b9f5d1ed082d83db24}{FastRandomWalk}}(50000000,\textcolor{stringliteral}{"./wordlist.txt"},6,12,25, \textcolor{keyword}{true});}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{model_matrix_8cpp_source_l00195}{195}} of file \mbox{\hyperlink{model_matrix_8cpp_source}{model\+Matrix.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00195                                                                                                                                              \{}
\DoxyCodeLine{00196     }
\DoxyCodeLine{00197 }
\DoxyCodeLine{00198     std::ofstream wordlist; }
\DoxyCodeLine{00199     \textcolor{keywordflow}{if}(bFileIO)}
\DoxyCodeLine{00200         wordlist.open(wordlistFileName);}
\DoxyCodeLine{00201 }
\DoxyCodeLine{00202     std::mutex mlock;}
\DoxyCodeLine{00203     \textcolor{keywordflow}{if}(n<=50000000ull) \textcolor{keywordflow}{return} this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_ad775d2e9c35e6f78c53f796df11405b5}{FastRandomWalkPartition}}(\&mlock, \&wordlist, n, minLen, maxLen, bFileIO, threads);}
\DoxyCodeLine{00204     \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{00205         \textcolor{keywordtype}{int} numberOfPartitions = n/50000000ull;}
\DoxyCodeLine{00206         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<numberOfPartitions;i++)}
\DoxyCodeLine{00207             this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_ad775d2e9c35e6f78c53f796df11405b5}{FastRandomWalkPartition}}(\&mlock, \&wordlist, 50000000ull, minLen, maxLen, bFileIO, threads);}
\DoxyCodeLine{00208     \}}
\DoxyCodeLine{00209 }
\DoxyCodeLine{00210 }
\DoxyCodeLine{00211 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_matrix_8cpp_source_l00214}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Partition()}}.



Referenced by \mbox{\hyperlink{markopy_8cpp_source_l00012}{Markov\+::\+Markopy\+::\+B\+O\+O\+S\+T\+\_\+\+P\+Y\+T\+H\+O\+N\+\_\+\+M\+O\+D\+U\+L\+E()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_a9e5a9885d48e95b9f5d1ed082d83db24_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_a9e5a9885d48e95b9f5d1ed082d83db24_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_ad775d2e9c35e6f78c53f796df11405b5}\label{class_markov_1_1_a_p_i_1_1_model_matrix_ad775d2e9c35e6f78c53f796df11405b5}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!FastRandomWalkPartition@{FastRandomWalkPartition}}
\index{FastRandomWalkPartition@{FastRandomWalkPartition}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{FastRandomWalkPartition()}{FastRandomWalkPartition()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Partition (\begin{DoxyParamCaption}\item[{std\+::mutex $\ast$}]{mlock,  }\item[{std\+::ofstream $\ast$}]{wordlist,  }\item[{unsigned long int}]{n,  }\item[{int}]{min\+Len,  }\item[{int}]{max\+Len,  }\item[{bool}]{b\+File\+IO,  }\item[{int}]{threads }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}



A single partition of Fast\+Random\+Walk event. 

Since Fast\+Random\+Walk has to allocate its output buffer before operation starts and writes data in chunks, large n parameters would lead to huge memory allocations. {\bfseries{Without}} {\bfseries{Partitioning\+:}} 
\begin{DoxyItemize}
\item 50M results 12 characters max -\/$>$ 550 Mb Memory allocation
\item 5B results 12 characters max -\/$>$ 55 Gb Memory allocation
\item 50B results 12 characters max -\/$>$ 550GB Memory allocation
\end{DoxyItemize}

Instead, Fast\+Random\+Walk is partitioned per 50M generations to limit the top memory need.


\begin{DoxyParams}{Parameters}
{\em mlock} & -\/ mutex lock to distribute to child threads \\
\hline
{\em wordlist} & -\/ Reference to the wordlist file to write to \\
\hline
{\em n} & -\/ Number of passwords to generate. \\
\hline
{\em wordlist\+File\+Name} & -\/ Filename to write to \\
\hline
{\em min\+Len} & -\/ Minimum password length to generate \\
\hline
{\em max\+Len} & -\/ Maximum password length to generate \\
\hline
{\em threads} & -\/ number of OS threads to spawn \\
\hline
{\em b\+File\+IO} & -\/ If false, filename will be ignored and will output to stdout. \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{model_matrix_8cpp_source_l00214}{214}} of file \mbox{\hyperlink{model_matrix_8cpp_source}{model\+Matrix.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00214                                                                                                                                                                 \{}
\DoxyCodeLine{00215     }
\DoxyCodeLine{00216     \textcolor{keywordtype}{int} iterationsPerThread = n/threads;}
\DoxyCodeLine{00217     \textcolor{keywordtype}{int} iterationsPerThreadCarryOver = n\%threads;}
\DoxyCodeLine{00218 }
\DoxyCodeLine{00219     std::vector<std::thread*> threadsV;}
\DoxyCodeLine{00220     }
\DoxyCodeLine{00221     \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = 0;}
\DoxyCodeLine{00222     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<threads;i++)\{}
\DoxyCodeLine{00223         threadsV.push\_back(\textcolor{keyword}{new} std::thread(\&\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a96f2885aac69b49b21c66ad5a32514b9}{Markov::API::ModelMatrix::FastRandomWalkThread}}, \textcolor{keyword}{this}, mlock, wordlist, iterationsPerThread, minLen, maxLen, \textcolor{keywordtype}{id}, bFileIO));}
\DoxyCodeLine{00224         \textcolor{keywordtype}{id}++;}
\DoxyCodeLine{00225     \}}
\DoxyCodeLine{00226 }
\DoxyCodeLine{00227     threadsV.push\_back(\textcolor{keyword}{new} std::thread(\&\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a96f2885aac69b49b21c66ad5a32514b9}{Markov::API::ModelMatrix::FastRandomWalkThread}}, \textcolor{keyword}{this}, mlock, wordlist, iterationsPerThreadCarryOver, minLen, maxLen, \textcolor{keywordtype}{id}, bFileIO));}
\DoxyCodeLine{00228 }
\DoxyCodeLine{00229     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<threads;i++)\{}
\DoxyCodeLine{00230         threadsV[i]-\/>join();}
\DoxyCodeLine{00231     \}}
\DoxyCodeLine{00232 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_matrix_8cpp_source_l00144}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Thread()}}.



Referenced by \mbox{\hyperlink{model_matrix_8cpp_source_l00195}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_ad775d2e9c35e6f78c53f796df11405b5_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_ad775d2e9c35e6f78c53f796df11405b5_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_a96f2885aac69b49b21c66ad5a32514b9}\label{class_markov_1_1_a_p_i_1_1_model_matrix_a96f2885aac69b49b21c66ad5a32514b9}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!FastRandomWalkThread@{FastRandomWalkThread}}
\index{FastRandomWalkThread@{FastRandomWalkThread}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{FastRandomWalkThread()}{FastRandomWalkThread()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Thread (\begin{DoxyParamCaption}\item[{std\+::mutex $\ast$}]{mlock,  }\item[{std\+::ofstream $\ast$}]{wordlist,  }\item[{unsigned long int}]{n,  }\item[{int}]{min\+Len,  }\item[{int}]{max\+Len,  }\item[{int}]{id,  }\item[{bool}]{b\+File\+IO }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}



A single thread of a single partition of Fast\+Random\+Walk. 

A Fast\+Random\+Walk\+Partition will initiate as many of this function as requested.

This function contains the bulk of the generation algorithm.


\begin{DoxyParams}{Parameters}
{\em mlock} & -\/ mutex lock to distribute to child threads \\
\hline
{\em wordlist} & -\/ Reference to the wordlist file to write to \\
\hline
{\em n} & -\/ Number of passwords to generate. \\
\hline
{\em wordlist\+File\+Name} & -\/ Filename to write to \\
\hline
{\em min\+Len} & -\/ Minimum password length to generate \\
\hline
{\em max\+Len} & -\/ Maximum password length to generate \\
\hline
{\em id} & -\/ {\bfseries{D\+E\+P\+R\+E\+C\+A\+T\+ED}} Thread id -\/ No longer used \\
\hline
{\em b\+File\+IO} & -\/ If false, filename will be ignored and will output to stdout. \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{model_matrix_8cpp_source_l00144}{144}} of file \mbox{\hyperlink{model_matrix_8cpp_source}{model\+Matrix.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00144                                                                                                                                                         \{}
\DoxyCodeLine{00145     \textcolor{keywordflow}{if}(n==0) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00146 }
\DoxyCodeLine{00147     \mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov::Random::Marsaglia}} MarsagliaRandomEngine;}
\DoxyCodeLine{00148     \textcolor{keywordtype}{char}* e;}
\DoxyCodeLine{00149     \textcolor{keywordtype}{char} *res = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[maxLen*n];}
\DoxyCodeLine{00150     \textcolor{keywordtype}{int} index = 0;}
\DoxyCodeLine{00151     \textcolor{keywordtype}{char} next;}
\DoxyCodeLine{00152     \textcolor{keywordtype}{int} len=0;}
\DoxyCodeLine{00153     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} selection;}
\DoxyCodeLine{00154     \textcolor{keywordtype}{char} cur;}
\DoxyCodeLine{00155     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} bufferctr = 0;}
\DoxyCodeLine{00156     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++) \{}
\DoxyCodeLine{00157         cur=199;}
\DoxyCodeLine{00158         len=0;}
\DoxyCodeLine{00159         \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{}
\DoxyCodeLine{00160             e = \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_a3e74937619866dc763c1f11b923866aa}{strchr}}(this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}}, cur);}
\DoxyCodeLine{00161             index = e -\/ this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}{matrixIndex}};}
\DoxyCodeLine{00162             selection = MarsagliaRandomEngine.\mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia_a0a56da316d520b80be6b6df6c9e0b537}{random}}() \% this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a47bab10980c3117f75909b640a4096df}{totalEdgeWeights}}[index];}
\DoxyCodeLine{00163             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}{matrixSize}};j++)\{}
\DoxyCodeLine{00164                 selection -\/= this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}{valueMatrix}}[index][j];}
\DoxyCodeLine{00165                 \textcolor{keywordflow}{if} (selection < 0)\{}
\DoxyCodeLine{00166                     next = this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}{edgeMatrix}}[index][j];}
\DoxyCodeLine{00167                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{00168                 \}}
\DoxyCodeLine{00169             \}}
\DoxyCodeLine{00170 }
\DoxyCodeLine{00171             \textcolor{keywordflow}{if} (len >= maxLen)  \textcolor{keywordflow}{break};}
\DoxyCodeLine{00172             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((next < 0) \&\& (len < minLen)) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00173             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (next < 0) \textcolor{keywordflow}{break};  }
\DoxyCodeLine{00174             cur = next;}
\DoxyCodeLine{00175             res[bufferctr + len++] = cur;}
\DoxyCodeLine{00176         \}}
\DoxyCodeLine{00177         res[bufferctr + len++] = \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{00178         bufferctr+=len;}
\DoxyCodeLine{00179         }
\DoxyCodeLine{00180     \}}
\DoxyCodeLine{00181     \textcolor{keywordflow}{if}(bFileIO)\{}
\DoxyCodeLine{00182         mlock-\/>lock();}
\DoxyCodeLine{00183         *wordlist << res;}
\DoxyCodeLine{00184         mlock-\/>unlock();}
\DoxyCodeLine{00185     \}\textcolor{keywordflow}{else}\{}
\DoxyCodeLine{00186         mlock-\/>lock();}
\DoxyCodeLine{00187         std::cout << res;}
\DoxyCodeLine{00188         mlock-\/>unlock();}
\DoxyCodeLine{00189     \}}
\DoxyCodeLine{00190     \textcolor{keyword}{delete} res;}
\DoxyCodeLine{00191 }
\DoxyCodeLine{00192 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_matrix_8h_source_l00136}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::edge\+Matrix}}, \mbox{\hyperlink{model_matrix_8h_source_l00151}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Index}}, \mbox{\hyperlink{model_matrix_8h_source_l00146}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Size}}, \mbox{\hyperlink{random_8h_source_l00131}{Markov\+::\+Random\+::\+Marsaglia\+::random()}}, \mbox{\hyperlink{model_matrix_8h_source_l00156}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::total\+Edge\+Weights}}, and \mbox{\hyperlink{model_matrix_8h_source_l00141}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::value\+Matrix}}.



Referenced by \mbox{\hyperlink{model_matrix_8cpp_source_l00214}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Partition()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_a96f2885aac69b49b21c66ad5a32514b9_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_a96f2885aac69b49b21c66ad5a32514b9_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_ae40af2e90f0500e2780a017f0d39f5e5}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_ae40af2e90f0500e2780a017f0d39f5e5}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!FlattenMatrix@{FlattenMatrix}}
\index{FlattenMatrix@{FlattenMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{FlattenMatrix()}{FlattenMatrix()}}
{\footnotesize\ttfamily \+\_\+\+\_\+host\+\_\+\+\_\+ void Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::\+Flatten\+Matrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Flatten migrated matrix from 2d to 1d. 

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!Generate@{Generate}}
\index{Generate@{Generate}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{Generate()}{Generate()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Generate (\begin{DoxyParamCaption}\item[{unsigned long int}]{n,  }\item[{const char $\ast$}]{wordlist\+File\+Name,  }\item[{int}]{min\+Len = {\ttfamily 6},  }\item[{int}]{max\+Len = {\ttfamily 12},  }\item[{int}]{threads = {\ttfamily 20} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Call \mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{Markov\+::\+Model\+::\+Random\+Walk}} n times, and collect output. 

Generate from model and write results to a file. a much more performance-\/optimized method. Fast\+Random\+Walk will reduce the runtime by \%96.\+5 on average.

\begin{DoxyRefDesc}{Deprecated}
\item[\mbox{\hyperlink{deprecated__deprecated000001}{Deprecated}}]See Markov\+::\+A\+P\+I\+::\+Matrix\+Model\+::\+Fast\+Random\+Walk for more information. \end{DoxyRefDesc}

\begin{DoxyParams}{Parameters}
{\em n} & -\/ Number of passwords to generate. \\
\hline
{\em wordlist\+File\+Name} & -\/ Filename to write to \\
\hline
{\em min\+Len} & -\/ Minimum password length to generate \\
\hline
{\em max\+Len} & -\/ Maximum password length to generate \\
\hline
{\em threads} & -\/ number of OS threads to spawn \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00110}{110}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00110                                                                                                                                \{}
\DoxyCodeLine{00111     \textcolor{keywordtype}{char}* res;}
\DoxyCodeLine{00112     \textcolor{keywordtype}{char} print[100];}
\DoxyCodeLine{00113     std::ofstream wordlist; }
\DoxyCodeLine{00114     wordlist.open(wordlistFileName);}
\DoxyCodeLine{00115     std::mutex mlock;}
\DoxyCodeLine{00116     \textcolor{keywordtype}{int} iterationsPerThread = n/threads;}
\DoxyCodeLine{00117     \textcolor{keywordtype}{int} iterationsCarryOver = n\%threads;}
\DoxyCodeLine{00118     std::vector<std::thread*> threadsV;}
\DoxyCodeLine{00119     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<threads;i++)\{}
\DoxyCodeLine{00120         threadsV.push\_back(\textcolor{keyword}{new} std::thread(\&\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}{Markov::API::MarkovPasswords::GenerateThread}}, \textcolor{keyword}{this}, \&mlock, iterationsPerThread, \&wordlist, minLen, maxLen));}
\DoxyCodeLine{00121     \}}
\DoxyCodeLine{00122 }
\DoxyCodeLine{00123     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<threads;i++)\{}
\DoxyCodeLine{00124         threadsV[i]-\/>join();}
\DoxyCodeLine{00125         \textcolor{keyword}{delete} threadsV[i];}
\DoxyCodeLine{00126     \}}
\DoxyCodeLine{00127 }
\DoxyCodeLine{00128     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}{GenerateThread}}(\&mlock, iterationsCarryOver, \&wordlist, minLen, maxLen);}
\DoxyCodeLine{00129     }
\DoxyCodeLine{00130 \}}

\end{DoxyCode}


References \mbox{\hyperlink{markov_passwords_8cpp_source_l00132}{Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Generate\+Thread()}}.



Referenced by \mbox{\hyperlink{markopy_8cpp_source_l00012}{Markov\+::\+Markopy\+::\+B\+O\+O\+S\+T\+\_\+\+P\+Y\+T\+H\+O\+N\+\_\+\+M\+O\+D\+U\+L\+E()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a13886b29051abf3edeed97bd7f985f39_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!GenerateThread@{GenerateThread}}
\index{GenerateThread@{GenerateThread}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{GenerateThread()}{GenerateThread()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Generate\+Thread (\begin{DoxyParamCaption}\item[{std\+::mutex $\ast$}]{output\+Lock,  }\item[{unsigned long int}]{n,  }\item[{std\+::ofstream $\ast$}]{wordlist,  }\item[{int}]{min\+Len,  }\item[{int}]{max\+Len }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



A single thread invoked by the Generate function. 

{\bfseries{D\+E\+P\+R\+E\+C\+A\+T\+ED\+:}} See Markov\+::\+A\+P\+I\+::\+Matrix\+Model\+::\+Fast\+Random\+Walk\+Thread for more information. This has been replaced with a much more performance-\/optimized method. Fast\+Random\+Walk will reduce the runtime by \%96.\+5 on average.


\begin{DoxyParams}{Parameters}
{\em output\+Lock} & -\/ shared mutex lock to lock during output operation. Prevents race condition on write. \\
\hline
{\em n} & number of lines to be generated by this thread \\
\hline
{\em wordlist} & wordlistfile \\
\hline
{\em min\+Len} & -\/ Minimum password length to generate \\
\hline
{\em max\+Len} & -\/ Maximum password length to generate \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00132}{132}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00132                                                                                                                                        \{}
\DoxyCodeLine{00133     \textcolor{keywordtype}{char}* res = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[maxLen+5];}
\DoxyCodeLine{00134     \textcolor{keywordflow}{if}(n==0) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00135 }
\DoxyCodeLine{00136     \mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov::Random::Marsaglia}} MarsagliaRandomEngine;}
\DoxyCodeLine{00137     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++) \{}
\DoxyCodeLine{00138         this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{RandomWalk}}(\&MarsagliaRandomEngine, minLen, maxLen, res); }
\DoxyCodeLine{00139         outputLock-\/>lock();}
\DoxyCodeLine{00140         *wordlist << res << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{00141         outputLock-\/>unlock();}
\DoxyCodeLine{00142     \}}
\DoxyCodeLine{00143 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_8h_source_l00293}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Random\+Walk()}}.



Referenced by \mbox{\hyperlink{markov_passwords_8cpp_source_l00110}{Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Generate()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_ac2703ec2d5c97adaf8d205000ca34756_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_aeba8bb79aa4dc2cfeda310f34b7c9427}\label{class_markov_1_1_a_p_i_1_1_model_matrix_aeba8bb79aa4dc2cfeda310f34b7c9427}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!Import@{Import}}
\index{Import@{Import}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Import (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Open a file to import with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Model\+::\+Import}} with std\+::ifstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Import a file with filename 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.Import(\textcolor{stringliteral}{"test.mdl"});}
\end{DoxyCode}
 Construct the matrix when done. 

Definition at line \mbox{\hyperlink{model_matrix_8cpp_source_l00010}{10}} of file \mbox{\hyperlink{model_matrix_8cpp_source}{model\+Matrix.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00010                                                      \{}
\DoxyCodeLine{00011     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a0f95257e1344225233ab49602cd9551c}{DeallocateMatrix}}();}
\DoxyCodeLine{00012     this-\/>\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Markov::API::MarkovPasswords::Import}}(filename);}
\DoxyCodeLine{00013     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aafb5809808b9b0450a0bc98740121b5f}{ConstructMatrix}}();}
\DoxyCodeLine{00014 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_matrix_8cpp_source_l00022}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00072}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Deallocate\+Matrix()}}, and \mbox{\hyperlink{model_8h_source_l00266}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Import()}}.



Referenced by \mbox{\hyperlink{markopy_8cpp_source_l00012}{Markov\+::\+Markopy\+::\+B\+O\+O\+S\+T\+\_\+\+P\+Y\+T\+H\+O\+N\+\_\+\+M\+O\+D\+U\+L\+E()}}, and \mbox{\hyperlink{src_2main_8cpp_source_l00014}{main()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_aeba8bb79aa4dc2cfeda310f34b7c9427_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_aeba8bb79aa4dc2cfeda310f34b7c9427_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}\label{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!Import@{Import}}
\index{Import@{Import}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Import (\begin{DoxyParamCaption}\item[{std\+::ifstream $\ast$}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Import a file to construct the model. 

File contains a list of edges. For more info on the file format, check out the wiki and github readme pages. Format is\+: Left\+\_\+repr;Edge\+Weight;right\+\_\+repr

Iterate over this list, and construct nodes and edges accordingly. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats
\end{DoxyReturn}
{\bfseries{Example}} {\bfseries{Use\+:}} Import a file from ifstream 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{std::ifstream file(\textcolor{stringliteral}{"test.mdl"});}
\DoxyCodeLine{\mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}}.Import(\&file);}
\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{model_8h_source_l00207}{207}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00207                                                         \{}
\DoxyCodeLine{00208     std::string cell;}
\DoxyCodeLine{00209 }
\DoxyCodeLine{00210     \textcolor{keywordtype}{char} src;}
\DoxyCodeLine{00211     \textcolor{keywordtype}{char} target;}
\DoxyCodeLine{00212     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} oc;}
\DoxyCodeLine{00213 }
\DoxyCodeLine{00214     \textcolor{keywordflow}{while} (std::getline(*\mbox{\hyperlink{namespacemodel__2gram_a2c21010331f2adf96f64d1e90d019e76}{f}}, cell)) \{}
\DoxyCodeLine{00215         \textcolor{comment}{//std::cout << "cell: " << cell << std::endl;}}
\DoxyCodeLine{00216         src = cell[0];}
\DoxyCodeLine{00217         target = cell[cell.length() -\/ 1];}
\DoxyCodeLine{00218         \textcolor{keywordtype}{char}* j;}
\DoxyCodeLine{00219         oc = std::strtol(cell.substr(2, cell.length() -\/ 2).c\_str(),\&j,10);}
\DoxyCodeLine{00220         \textcolor{comment}{//std::cout << oc << "\(\backslash\)n";}}
\DoxyCodeLine{00221         \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* srcN;}
\DoxyCodeLine{00222         \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* targetN;}
\DoxyCodeLine{00223         \mbox{\hyperlink{class_markov_1_1_edge}{Markov::Edge<NodeStorageType>}}* e;}
\DoxyCodeLine{00224         \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.find(src) == this-\/>nodes.end()) \{}
\DoxyCodeLine{00225             srcN = \textcolor{keyword}{new} \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}(src);}
\DoxyCodeLine{00226             this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.insert(std::pair<\textcolor{keywordtype}{char}, \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}*>(src, srcN));}
\DoxyCodeLine{00227             \textcolor{comment}{//std::cout << "Creating new node at start.\(\backslash\)n";}}
\DoxyCodeLine{00228         \}}
\DoxyCodeLine{00229         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00230             srcN = this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.find(src)-\/>second;}
\DoxyCodeLine{00231         \}}
\DoxyCodeLine{00232 }
\DoxyCodeLine{00233         \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.find(target) == this-\/>nodes.end()) \{}
\DoxyCodeLine{00234             targetN = \textcolor{keyword}{new} \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}(target);}
\DoxyCodeLine{00235             this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.insert(std::pair<\textcolor{keywordtype}{char}, \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}*>(target, targetN));}
\DoxyCodeLine{00236             \textcolor{comment}{//std::cout << "Creating new node at end.\(\backslash\)n";}}
\DoxyCodeLine{00237         \}}
\DoxyCodeLine{00238         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00239             targetN = this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}.find(target)-\/>second;}
\DoxyCodeLine{00240         \}}
\DoxyCodeLine{00241         e = srcN-\/>\mbox{\hyperlink{class_markov_1_1_node_a0e867cddf6b8dd784c36b12aa820fee9}{Link}}(targetN);}
\DoxyCodeLine{00242         e-\/>\mbox{\hyperlink{class_markov_1_1_edge_aa9d6cc6e631f1b515b4db604c96ad4ad}{AdjustEdge}}(oc);}
\DoxyCodeLine{00243         this-\/>\mbox{\hyperlink{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}{edges}}.push\_back(e);}
\DoxyCodeLine{00244 }
\DoxyCodeLine{00245         \textcolor{comment}{//std::cout << int(srcN-\/>NodeValue()) << " -\/-\/" << e-\/>EdgeWeight() << "-\/-\/> " << int(targetN-\/>NodeValue()) << "\(\backslash\)n";}}
\DoxyCodeLine{00246 }
\DoxyCodeLine{00247 }
\DoxyCodeLine{00248     \}}
\DoxyCodeLine{00249 }
\DoxyCodeLine{00250     \textcolor{keywordflow}{for} (std::pair<\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}, \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}*> \textcolor{keyword}{const}\& x : this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}}) \{}
\DoxyCodeLine{00251         \textcolor{comment}{//std::cout << "Total edges in EdgesV: " << x.second-\/>edgesV.size() << "\(\backslash\)n"; }}
\DoxyCodeLine{00252         std::sort (x.second-\/>edgesV.begin(), x.second-\/>edgesV.end(), [](Edge<NodeStorageType> *lhs, Edge<NodeStorageType> *rhs)-\/>bool\{}
\DoxyCodeLine{00253             return lhs-\/>EdgeWeight() > rhs-\/>EdgeWeight();}
\DoxyCodeLine{00254         \});}
\DoxyCodeLine{00255         \textcolor{comment}{//for(int i=0;i<x.second-\/>edgesV.size();i++)}}
\DoxyCodeLine{00256         \textcolor{comment}{//  std::cout << x.second-\/>edgesV[i]-\/>EdgeWeight() << ", ";}}
\DoxyCodeLine{00257         \textcolor{comment}{//std::cout << "\(\backslash\)n";}}
\DoxyCodeLine{00258     \}}
\DoxyCodeLine{00259     \textcolor{comment}{//std::cout << "Total number of nodes: " << this-\/>nodes.size() << std::endl;}}
\DoxyCodeLine{00260     \textcolor{comment}{//std::cout << "Total number of edges: " << this-\/>edges.size() << std::endl;}}
\DoxyCodeLine{00261 }
\DoxyCodeLine{00262     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00263 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_ad1beeb03129fea545cfb18009d2d955f}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller_ad1beeb03129fea545cfb18009d2d955f}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!ListCudaDevices@{ListCudaDevices}}
\index{ListCudaDevices@{ListCudaDevices}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{ListCudaDevices()}{ListCudaDevices()}}
{\footnotesize\ttfamily static \+\_\+\+\_\+host\+\_\+\+\_\+ void Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Device\+Controller\+::\+List\+Cuda\+Devices (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [inherited]}}



List \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{C\+U\+DA}} devices in the system. 

This function will print details of every \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{C\+U\+DA}} capable device in the system.

{\bfseries{Example}} {\bfseries{output\+:}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{Device Number: 0}
\DoxyCodeLine{Device name: GeForce RTX 2070}
\DoxyCodeLine{Memory Clock Rate (KHz): 7001000}
\DoxyCodeLine{Memory Bus Width (bits): 256}
\DoxyCodeLine{Peak Memory Bandwidth (GB/s): 448.064}
\DoxyCodeLine{Max Linear Threads: 1024}
\end{DoxyCode}
 \mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a5dd552997a32c0cabf3a6cca6fb07b73}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a5dd552997a32c0cabf3a6cca6fb07b73}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!MigrateMatrix@{MigrateMatrix}}
\index{MigrateMatrix@{MigrateMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{MigrateMatrix()}{MigrateMatrix()}}
{\footnotesize\ttfamily \+\_\+\+\_\+host\+\_\+\+\_\+ void Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::\+Migrate\+Matrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Migrate the class members to the V\+R\+AM. 

Cannot be used without calling \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aafb5809808b9b0450a0bc98740121b5f}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix}} at least once. This function will manage the memory allocation and data transfer from C\+PU R\+AM to G\+PU V\+R\+AM.

Newly allocated V\+R\+AM pointers are set in the class member variables. \mbox{\Hypertarget{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}\label{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!Nodes@{Nodes}}
\index{Nodes@{Nodes}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{Nodes()}{Nodes()}}
{\footnotesize\ttfamily std\+::map$<$char , \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$char $>$$\ast$$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Nodes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [inherited]}}



Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. 

\begin{DoxyReturn}{Returns}
starter node with 00 Node\+Value 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_8h_source_l00177}{177}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00177 \{ \textcolor{keywordflow}{return} \&\mbox{\hyperlink{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}{nodes}};\}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_ac3fb665ee48937ca845d930e72e07917}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_ac3fb665ee48937ca845d930e72e07917}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!OpenDatasetFile@{OpenDatasetFile}}
\index{OpenDatasetFile@{OpenDatasetFile}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{OpenDatasetFile()}{OpenDatasetFile()}}
{\footnotesize\ttfamily std\+::ifstream $\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Open\+Dataset\+File (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Open dataset file and return the ifstream pointer. 


\begin{DoxyParams}{Parameters}
{\em filename} & -\/ Filename to open \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
ifstream$\ast$ to the the dataset file 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00043}{43}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00043                                                                           \{}
\DoxyCodeLine{00044 }
\DoxyCodeLine{00045     std::ifstream* \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}{datasetFile}};}
\DoxyCodeLine{00046 }
\DoxyCodeLine{00047     std::ifstream newFile(filename);}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049     \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}{datasetFile}} = \&newFile;}
\DoxyCodeLine{00050 }
\DoxyCodeLine{00051     this-\/>\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(datasetFile);}
\DoxyCodeLine{00052     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}{datasetFile}};}
\DoxyCodeLine{00053 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_8h_source_l00207}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Import()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_ac3fb665ee48937ca845d930e72e07917_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}\label{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!RandomWalk@{RandomWalk}}
\index{RandomWalk@{RandomWalk}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{RandomWalk()}{RandomWalk()}}
{\footnotesize\ttfamily char  $\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Random\+Walk (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{Markov\+::\+Random\+::\+Random\+Engine}} $\ast$}]{random\+Engine,  }\item[{int}]{min\+Setting,  }\item[{int}]{max\+Setting,  }\item[{Node\+Storage\+Type $\ast$}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Do a random walk on this model. 

Start from the starter node, on each node, invoke Random\+Next using the random engine on current node, until terminator node is reached. If terminator node is reached before minimum length criateria is reached, ignore the last selection and re-\/invoke random\+Next

If maximum length criteria is reached but final node is not, cut off the generation and proceed to the final node. This function takes \mbox{\hyperlink{class_markov_1_1_random_1_1_random_engine}{Markov\+::\+Random\+::\+Random\+Engine}} as a parameter to generate pseudo random numbers from

This library is shipped with two random engines, Marsaglia and Mersenne. While mersenne output is higher in entropy, most use cases don\textquotesingle{}t really need super high entropy output, so \mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov\+::\+Random\+::\+Marsaglia}} is preferable for better performance.

This function W\+I\+LL N\+OT reallocate buffer. Make sure no out of bound writes are happening via maximum length criteria.

{\bfseries{Example}} {\bfseries{Use\+:}} Generate 10 lines, with 5 to 10 characters, and print the output. Use Marsaglia 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model}{Markov::Model<char>}} \mbox{\hyperlink{namespacemarkopy__cli_a573dcc41f3a527edb70e831cd8108c78}{model}};}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}{Model}}.import(\textcolor{stringliteral}{"model.mdl"});}
\DoxyCodeLine{\textcolor{keywordtype}{char}* res = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[11];}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov::Random::Marsaglia}} MarsagliaRandomEngine;}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 10; i++) \{}
\DoxyCodeLine{    this-\/>\mbox{\hyperlink{class_markov_1_1_model_aa4a11c6679c998936332f8409ae95375}{RandomWalk}}(\&MarsagliaRandomEngine, 5, 10, res); }
\DoxyCodeLine{    std::cout << res << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{ \}}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em random\+Engine} & \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_random}{Random}} Engine to use for the random walks. For examples, see \mbox{\hyperlink{class_markov_1_1_random_1_1_mersenne}{Markov\+::\+Random\+::\+Mersenne}} and \mbox{\hyperlink{class_markov_1_1_random_1_1_marsaglia}{Markov\+::\+Random\+::\+Marsaglia}} \\
\hline
{\em min\+Setting} & Minimum number of characters to generate \\
\hline
{\em max\+Setting} & Maximum number of character to generate \\
\hline
{\em buffer} & buffer to write the result to \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Null terminated string that was generated. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_8h_source_l00293}{293}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00293                                                                                                                                                          \{}
\DoxyCodeLine{00294     \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* n = this-\/>\mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starterNode}};}
\DoxyCodeLine{00295     \textcolor{keywordtype}{int} len = 0;}
\DoxyCodeLine{00296     \mbox{\hyperlink{class_markov_1_1_node}{Markov::Node<NodeStorageType>}}* temp\_node;}
\DoxyCodeLine{00297     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{}
\DoxyCodeLine{00298         temp\_node = n-\/>\mbox{\hyperlink{class_markov_1_1_node_a87224bed22e5da09e0ddb91c681a6b2c}{RandomNext}}(randomEngine);}
\DoxyCodeLine{00299         \textcolor{keywordflow}{if} (len >= maxSetting) \{}
\DoxyCodeLine{00300             \textcolor{keywordflow}{break};}
\DoxyCodeLine{00301         \}}
\DoxyCodeLine{00302         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((temp\_node == NULL) \&\& (len < minSetting)) \{}
\DoxyCodeLine{00303             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{00304         \}}
\DoxyCodeLine{00305 }
\DoxyCodeLine{00306         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (temp\_node == NULL)\{}
\DoxyCodeLine{00307             \textcolor{keywordflow}{break};}
\DoxyCodeLine{00308         \}}
\DoxyCodeLine{00309             }
\DoxyCodeLine{00310         n = temp\_node;}
\DoxyCodeLine{00311 }
\DoxyCodeLine{00312         buffer[len++] = n-\/>\mbox{\hyperlink{class_markov_1_1_node_ac7cce56376f2a00764f64a0194cbb498}{NodeValue}}();}
\DoxyCodeLine{00313     \}}
\DoxyCodeLine{00314 }
\DoxyCodeLine{00315     \textcolor{comment}{//null terminate the string}}
\DoxyCodeLine{00316     buffer[len] = 0x00;}
\DoxyCodeLine{00317 }
\DoxyCodeLine{00318     \textcolor{comment}{//do something with the generated string}}
\DoxyCodeLine{00319     \textcolor{keywordflow}{return} buffer; \textcolor{comment}{//for now}}
\DoxyCodeLine{00320 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_a4f4997da3a6cd3bd2717ce9759736660}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_a4f4997da3a6cd3bd2717ce9759736660}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!Save@{Save}}
\index{Save@{Save}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{Save()}{Save()}}
{\footnotesize\ttfamily std\+::ofstream $\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Save (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Export model to file. 


\begin{DoxyParams}{Parameters}
{\em filename} & -\/ Export filename. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::ofstream$\ast$ of the exported file. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00098}{98}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00098                                                                 \{}
\DoxyCodeLine{00099     std::ofstream* exportFile;}
\DoxyCodeLine{00100 }
\DoxyCodeLine{00101     std::ofstream newFile(filename);}
\DoxyCodeLine{00102 }
\DoxyCodeLine{00103     exportFile = \&newFile;}
\DoxyCodeLine{00104     }
\DoxyCodeLine{00105     this-\/>\mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}}(exportFile);}
\DoxyCodeLine{00106     \textcolor{keywordflow}{return} exportFile;}
\DoxyCodeLine{00107 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_8h_source_l00274}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Export()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a4f4997da3a6cd3bd2717ce9759736660_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}\label{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!StarterNode@{StarterNode}}
\index{StarterNode@{StarterNode}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{StarterNode()}{StarterNode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$char $>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::Starter\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [inherited]}}



Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. 

\begin{DoxyReturn}{Returns}
starter node with 00 Node\+Value 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{model_8h_source_l00167}{167}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00167 \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}{starterNode}};\}}

\end{DoxyCode}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_af42d40d7a5c80f0dfe126a574a17f423}\label{class_markov_1_1_a_p_i_1_1_model_matrix_af42d40d7a5c80f0dfe126a574a17f423}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!Train@{Train}}
\index{Train@{Train}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{Train()}{Train()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Train (\begin{DoxyParamCaption}\item[{const char $\ast$}]{dataset\+File\+Name,  }\item[{char}]{delimiter,  }\item[{int}]{threads }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inherited]}}



Train the model with the dataset file. 


\begin{DoxyParams}{Parameters}
{\em dataset\+File\+Name} & -\/ Ifstream$\ast$ to the dataset. If null, use class member \\
\hline
{\em delimiter} & -\/ a character, same as the delimiter in dataset content \\
\hline
{\em threads} & -\/ number of OS threads to spawn\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords}{Markov::API::MarkovPasswords}} mp;}
\DoxyCodeLine{mp.\mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}}(\textcolor{stringliteral}{"models/2gram.mdl"});}
\DoxyCodeLine{mp.\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2}{Train}}(\textcolor{stringliteral}{"password.corpus"});}
\end{DoxyCode}
 Construct the matrix when done. 

Definition at line \mbox{\hyperlink{model_matrix_8cpp_source_l00016}{16}} of file \mbox{\hyperlink{model_matrix_8cpp_source}{model\+Matrix.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00016                                                                                         \{}
\DoxyCodeLine{00017     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_a0f95257e1344225233ab49602cd9551c}{DeallocateMatrix}}();}
\DoxyCodeLine{00018     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_markov_passwords_a2fd4423ae3850e258dcb6b11a7feb9b2}{Markov::API::MarkovPasswords::Train}}(datasetFileName,delimiter,threads);}
\DoxyCodeLine{00019     this-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix_aafb5809808b9b0450a0bc98740121b5f}{ConstructMatrix}}();}
\DoxyCodeLine{00020 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_matrix_8cpp_source_l00022}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00072}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Deallocate\+Matrix()}}, and \mbox{\hyperlink{markov_passwords_8cpp_source_l00057}{Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Train()}}.



Referenced by \mbox{\hyperlink{markopy_8cpp_source_l00012}{Markov\+::\+Markopy\+::\+B\+O\+O\+S\+T\+\_\+\+P\+Y\+T\+H\+O\+N\+\_\+\+M\+O\+D\+U\+L\+E()}}, and \mbox{\hyperlink{src_2main_8cpp_source_l00014}{main()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_af42d40d7a5c80f0dfe126a574a17f423_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_model_matrix_af42d40d7a5c80f0dfe126a574a17f423_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!TrainThread@{TrainThread}}
\index{TrainThread@{TrainThread}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{TrainThread()}{TrainThread()}}
{\footnotesize\ttfamily void Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Train\+Thread (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler}{Markov\+::\+A\+P\+I\+::\+Concurrency\+::\+Thread\+Shared\+List\+Handler}} $\ast$}]{listhandler,  }\item[{char}]{delimiter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



A single thread invoked by the Train function. 


\begin{DoxyParams}{Parameters}
{\em listhandler} & -\/ Listhandler class to read corpus from \\
\hline
{\em delimiter} & -\/ a character, same as the delimiter in dataset content \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{markov_passwords_8cpp_source_l00077}{77}} of file \mbox{\hyperlink{markov_passwords_8cpp_source}{markov\+Passwords.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00077                                                                                                                   \{}
\DoxyCodeLine{00078     \textcolor{keywordtype}{char} format\_str[] =\textcolor{stringliteral}{"\%ld,\%s"};}
\DoxyCodeLine{00079     format\_str[3]=delimiter;}
\DoxyCodeLine{00080     std::string line;}
\DoxyCodeLine{00081     \textcolor{keywordflow}{while} (listhandler-\/>\mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_concurrency_1_1_thread_shared_list_handler_a068e1a9ff477de23a44c10230df416a5}{next}}(\&line) \&\& \mbox{\hyperlink{markov_passwords_8cpp_a8e56c23aec0c3ae06851ab864c1f67e5}{keepRunning}}) \{}
\DoxyCodeLine{00082         \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} oc;}
\DoxyCodeLine{00083         \textcolor{keywordflow}{if} (line.size() > 100) \{}
\DoxyCodeLine{00084             line = line.substr(0, 100);}
\DoxyCodeLine{00085         \}}
\DoxyCodeLine{00086         \textcolor{keywordtype}{char}* linebuf = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[line.length()+5];}
\DoxyCodeLine{00087 \textcolor{preprocessor}{\#ifdef \_WIN32}}
\DoxyCodeLine{00088         sscanf\_s(line.c\_str(), \textcolor{stringliteral}{"\%ld,\%s"}, \&oc, linebuf, line.length()+5); \textcolor{comment}{//<== changed format\_str to-\/> "\%ld,\%s"}}
\DoxyCodeLine{00089 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00090         sscanf(line.c\_str(), format\_str, \&oc, linebuf);}
\DoxyCodeLine{00091 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00092         this-\/>\mbox{\hyperlink{class_markov_1_1_model_ad252913f83fa3eb14cc3f9f92c5ee37a}{AdjustEdge}}((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)linebuf, oc); }
\DoxyCodeLine{00093         \textcolor{keyword}{delete} linebuf;}
\DoxyCodeLine{00094     \}}
\DoxyCodeLine{00095 \}}

\end{DoxyCode}


References \mbox{\hyperlink{model_8h_source_l00323}{Markov\+::\+Model$<$ Node\+Storage\+Type $>$\+::\+Adjust\+Edge()}}, \mbox{\hyperlink{markov_passwords_8cpp_source_l00016}{keep\+Running}}, and \mbox{\hyperlink{thread_shared_list_handler_8cpp_source_l00010}{Markov\+::\+A\+P\+I\+::\+Concurrency\+::\+Thread\+Shared\+List\+Handler\+::next()}}.



Referenced by \mbox{\hyperlink{markov_passwords_8cpp_source_l00057}{Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::\+Train()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_markov_1_1_a_p_i_1_1_markov_passwords_a5f51b0fdb75101b797f38b08da84848e_icgraph}
\end{center}
\end{figure}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_ab4794af67fd4513921fee8ae669f2dd4}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!datasetFile@{datasetFile}}
\index{datasetFile@{datasetFile}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{datasetFile}{datasetFile}}
{\footnotesize\ttfamily std\+::ifstream$\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::dataset\+File\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



Definition at line \mbox{\hyperlink{markov_passwords_8h_source_l00106}{106}} of file \mbox{\hyperlink{markov_passwords_8h_source}{markov\+Passwords.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a06672c27d6c96e9f8808f61c6648f191}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a06672c27d6c96e9f8808f61c6648f191}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!device\_edgeMatrix@{device\_edgeMatrix}}
\index{device\_edgeMatrix@{device\_edgeMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{device\_edgeMatrix}{device\_edgeMatrix}}
{\footnotesize\ttfamily char$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::device\+\_\+edge\+Matrix\hspace{0.3cm}{\ttfamily [private]}}



V\+R\+AM Address pointer of edge matrix (from \mbox{\hyperlink{model_matrix_8h}{model\+Matrix.\+h}}) 



Definition at line \mbox{\hyperlink{cuda_model_matrix_8h_source_l00073}{73}} of file \mbox{\hyperlink{cuda_model_matrix_8h_source}{cuda\+Model\+Matrix.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a6a252a7c965c218114ad3d1663c4e840}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a6a252a7c965c218114ad3d1663c4e840}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!device\_matrixIndex@{device\_matrixIndex}}
\index{device\_matrixIndex@{device\_matrixIndex}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{device\_matrixIndex}{device\_matrixIndex}}
{\footnotesize\ttfamily char$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::device\+\_\+matrix\+Index\hspace{0.3cm}{\ttfamily [private]}}



V\+R\+AM Address pointer of matrix\+Index (from \mbox{\hyperlink{model_matrix_8h}{model\+Matrix.\+h}}) 



Definition at line \mbox{\hyperlink{cuda_model_matrix_8h_source_l00083}{83}} of file \mbox{\hyperlink{cuda_model_matrix_8h_source}{cuda\+Model\+Matrix.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a1ec34676837c3cdd5ec2f18a77faec12}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a1ec34676837c3cdd5ec2f18a77faec12}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!device\_outputBuffer@{device\_outputBuffer}}
\index{device\_outputBuffer@{device\_outputBuffer}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{device\_outputBuffer}{device\_outputBuffer}}
{\footnotesize\ttfamily char$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::device\+\_\+output\+Buffer\hspace{0.3cm}{\ttfamily [private]}}



Random\+Walk results in device. 



Definition at line \mbox{\hyperlink{cuda_model_matrix_8h_source_l00094}{94}} of file \mbox{\hyperlink{cuda_model_matrix_8h_source}{cuda\+Model\+Matrix.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_aae5fdd4bdffc7eb2561fb923024d2615}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_aae5fdd4bdffc7eb2561fb923024d2615}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!device\_totalEdgeWeights@{device\_totalEdgeWeights}}
\index{device\_totalEdgeWeights@{device\_totalEdgeWeights}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{device\_totalEdgeWeights}{device\_totalEdgeWeights}}
{\footnotesize\ttfamily long int$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::device\+\_\+total\+Edge\+Weights\hspace{0.3cm}{\ttfamily [private]}}



V\+R\+AM Address pointer of total edge weights (from \mbox{\hyperlink{model_matrix_8h}{model\+Matrix.\+h}}) 



Definition at line \mbox{\hyperlink{cuda_model_matrix_8h_source_l00088}{88}} of file \mbox{\hyperlink{cuda_model_matrix_8h_source}{cuda\+Model\+Matrix.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a81e3be9eac6dab929de3b118d9343b27}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a81e3be9eac6dab929de3b118d9343b27}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!device\_valueMatrix@{device\_valueMatrix}}
\index{device\_valueMatrix@{device\_valueMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{device\_valueMatrix}{device\_valueMatrix}}
{\footnotesize\ttfamily long int$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::device\+\_\+value\+Matrix\hspace{0.3cm}{\ttfamily [private]}}



V\+R\+AM Address pointer of value matrix (from \mbox{\hyperlink{model_matrix_8h}{model\+Matrix.\+h}}) 



Definition at line \mbox{\hyperlink{cuda_model_matrix_8h_source_l00078}{78}} of file \mbox{\hyperlink{cuda_model_matrix_8h_source}{cuda\+Model\+Matrix.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}\label{class_markov_1_1_a_p_i_1_1_model_matrix_aa05bf3d2838be25198557b9f023d2980}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!edgeMatrix@{edgeMatrix}}
\index{edgeMatrix@{edgeMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{edgeMatrix}{edgeMatrix}}
{\footnotesize\ttfamily char$\ast$$\ast$ Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::edge\+Matrix\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}



2-\/D Character array for the edge Matrix (The characters of Nodes) 



Definition at line \mbox{\hyperlink{model_matrix_8h_source_l00136}{136}} of file \mbox{\hyperlink{model_matrix_8h_source}{model\+Matrix.\+h}}.



Referenced by \mbox{\hyperlink{model_matrix_8cpp_source_l00022}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00072}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Deallocate\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00092}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Dump\+J\+S\+O\+N()}}, and \mbox{\hyperlink{model_matrix_8cpp_source_l00144}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Thread()}}.

\mbox{\Hypertarget{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}\label{class_markov_1_1_model_a06d54b6e00a7e92b2c3bf72e1bfa560a}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!edges@{edges}}
\index{edges@{edges}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{edges}{edges}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$char $>$$\ast$$>$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::edges\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



A list of all edges in this model. 



Definition at line \mbox{\hyperlink{model_8h_source_l00195}{195}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a6345ea79ce015e2a97d1be91a661449a}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a6345ea79ce015e2a97d1be91a661449a}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!flatEdgeMatrix@{flatEdgeMatrix}}
\index{flatEdgeMatrix@{flatEdgeMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{flatEdgeMatrix}{flatEdgeMatrix}}
{\footnotesize\ttfamily char$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::flat\+Edge\+Matrix\hspace{0.3cm}{\ttfamily [private]}}



Adding \mbox{\hyperlink{class_markov_1_1_edge}{Edge}} matrix end-\/to-\/end and resize to 1-\/D array for better perfomance on traversing. 



Definition at line \mbox{\hyperlink{cuda_model_matrix_8h_source_l00104}{104}} of file \mbox{\hyperlink{cuda_model_matrix_8h_source}{cuda\+Model\+Matrix.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_abb65a788e9039a3b46cc5cdc76a11130}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_abb65a788e9039a3b46cc5cdc76a11130}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!flatValueMatrix@{flatValueMatrix}}
\index{flatValueMatrix@{flatValueMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{flatValueMatrix}{flatValueMatrix}}
{\footnotesize\ttfamily long int$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::flat\+Value\+Matrix\hspace{0.3cm}{\ttfamily [private]}}



Adding Value matrix end-\/to-\/end and resize to 1-\/D array for better perfomance on traversing. 



Definition at line \mbox{\hyperlink{cuda_model_matrix_8h_source_l00109}{109}} of file \mbox{\hyperlink{cuda_model_matrix_8h_source}{cuda\+Model\+Matrix.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}\label{class_markov_1_1_a_p_i_1_1_model_matrix_af01f1dbb05b7b25a69a0c95518549f32}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!matrixIndex@{matrixIndex}}
\index{matrixIndex@{matrixIndex}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{matrixIndex}{matrixIndex}}
{\footnotesize\ttfamily char$\ast$ Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Index\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}



to hold the Matrix index (To hold the orders of 2-\/D arrays\textquotesingle{}) 



Definition at line \mbox{\hyperlink{model_matrix_8h_source_l00151}{151}} of file \mbox{\hyperlink{model_matrix_8h_source}{model\+Matrix.\+h}}.



Referenced by \mbox{\hyperlink{model_matrix_8cpp_source_l00022}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00072}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Deallocate\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00092}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Dump\+J\+S\+O\+N()}}, and \mbox{\hyperlink{model_matrix_8cpp_source_l00144}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Thread()}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}\label{class_markov_1_1_a_p_i_1_1_model_matrix_a14f867fab1a47f06e59c8679ba4d1207}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!matrixSize@{matrixSize}}
\index{matrixSize@{matrixSize}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{matrixSize}{matrixSize}}
{\footnotesize\ttfamily int Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::matrix\+Size\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}



to hold Matrix size 



Definition at line \mbox{\hyperlink{model_matrix_8h_source_l00146}{146}} of file \mbox{\hyperlink{model_matrix_8h_source}{model\+Matrix.\+h}}.



Referenced by \mbox{\hyperlink{model_matrix_8cpp_source_l00022}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00072}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Deallocate\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00092}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Dump\+J\+S\+O\+N()}}, and \mbox{\hyperlink{model_matrix_8cpp_source_l00144}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Thread()}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_af5f012dcc495dbe769e663d6cb161d6a}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_af5f012dcc495dbe769e663d6cb161d6a}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!modelSavefile@{modelSavefile}}
\index{modelSavefile@{modelSavefile}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{modelSavefile}{modelSavefile}}
{\footnotesize\ttfamily std\+::ofstream$\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::model\+Savefile\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



Dataset file input of our system ~\newline
 



Definition at line \mbox{\hyperlink{markov_passwords_8h_source_l00107}{107}} of file \mbox{\hyperlink{markov_passwords_8h_source}{markov\+Passwords.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}\label{class_markov_1_1_model_aa772f79f444c2971f615df7be5e28bca}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!nodes@{nodes}}
\index{nodes@{nodes}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{nodes}{nodes}}
{\footnotesize\ttfamily std\+::map$<$char , \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$char $>$$\ast$$>$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::nodes\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



Map Left\+Node is the Nodes Node\+Value Map Right\+Node is the node pointer. 



Definition at line \mbox{\hyperlink{model_8h_source_l00184}{184}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a26d0692f6a494ab4a2871142b39ce066}\label{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix_a26d0692f6a494ab4a2871142b39ce066}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!outputBuffer@{outputBuffer}}
\index{outputBuffer@{outputBuffer}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{outputBuffer}{outputBuffer}}
{\footnotesize\ttfamily char$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+C\+U\+D\+A\+Model\+Matrix\+::output\+Buffer\hspace{0.3cm}{\ttfamily [private]}}



Random\+Walk results in host. 



Definition at line \mbox{\hyperlink{cuda_model_matrix_8h_source_l00099}{99}} of file \mbox{\hyperlink{cuda_model_matrix_8h_source}{cuda\+Model\+Matrix.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_markov_passwords_ac05e60de64e866027410d4fa1cd03248}\label{class_markov_1_1_a_p_i_1_1_markov_passwords_ac05e60de64e866027410d4fa1cd03248}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!outputFile@{outputFile}}
\index{outputFile@{outputFile}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{outputFile}{outputFile}}
{\footnotesize\ttfamily std\+::ofstream$\ast$ Markov\+::\+A\+P\+I\+::\+Markov\+Passwords\+::output\+File\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



File to save model of our system ~\newline
 



Definition at line \mbox{\hyperlink{markov_passwords_8h_source_l00108}{108}} of file \mbox{\hyperlink{markov_passwords_8h_source}{markov\+Passwords.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_a6e6994aef7ad847300be6e158e6b3322}\label{class_markov_1_1_a_p_i_1_1_model_matrix_a6e6994aef7ad847300be6e158e6b3322}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!ready@{ready}}
\index{ready@{ready}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{ready}{ready}}
{\footnotesize\ttfamily bool Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::ready\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}



True when matrix is constructed. False if not. 



Definition at line \mbox{\hyperlink{model_matrix_8h_source_l00161}{161}} of file \mbox{\hyperlink{model_matrix_8h_source}{model\+Matrix.\+h}}.



Referenced by \mbox{\hyperlink{model_matrix_8cpp_source_l00022}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00072}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Deallocate\+Matrix()}}, and \mbox{\hyperlink{model_matrix_8cpp_source_l00006}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Model\+Matrix()}}.

\mbox{\Hypertarget{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}\label{class_markov_1_1_model_ad2d9bf601df78f80076f5d3fbb65fe28}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!starterNode@{starterNode}}
\index{starterNode@{starterNode}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{starterNode}{starterNode}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$char $>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ char  $>$\+::starter\+Node\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [inherited]}}



Starter \mbox{\hyperlink{class_markov_1_1_node}{Node}} of this model. 



Definition at line \mbox{\hyperlink{model_8h_source_l00189}{189}} of file \mbox{\hyperlink{model_8h_source}{model.\+h}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_a47bab10980c3117f75909b640a4096df}\label{class_markov_1_1_a_p_i_1_1_model_matrix_a47bab10980c3117f75909b640a4096df}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!totalEdgeWeights@{totalEdgeWeights}}
\index{totalEdgeWeights@{totalEdgeWeights}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{totalEdgeWeights}{totalEdgeWeights}}
{\footnotesize\ttfamily long int$\ast$ Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::total\+Edge\+Weights\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}



Array of the Total \mbox{\hyperlink{class_markov_1_1_edge}{Edge}} Weights. 



Definition at line \mbox{\hyperlink{model_matrix_8h_source_l00156}{156}} of file \mbox{\hyperlink{model_matrix_8h_source}{model\+Matrix.\+h}}.



Referenced by \mbox{\hyperlink{model_matrix_8cpp_source_l00022}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00072}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Deallocate\+Matrix()}}, and \mbox{\hyperlink{model_matrix_8cpp_source_l00144}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Thread()}}.

\mbox{\Hypertarget{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}\label{class_markov_1_1_a_p_i_1_1_model_matrix_a13399cfee212b026d2ad40af5137f328}} 
\index{Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}!valueMatrix@{valueMatrix}}
\index{valueMatrix@{valueMatrix}!Markov::API::CUDA::CUDAModelMatrix@{Markov::API::CUDA::CUDAModelMatrix}}
\doxysubsubsection{\texorpdfstring{valueMatrix}{valueMatrix}}
{\footnotesize\ttfamily long int$\ast$$\ast$ Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::value\+Matrix\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [inherited]}}



2-\/d Integer array for the value Matrix (For the weights of Edges) 



Definition at line \mbox{\hyperlink{model_matrix_8h_source_l00141}{141}} of file \mbox{\hyperlink{model_matrix_8h_source}{model\+Matrix.\+h}}.



Referenced by \mbox{\hyperlink{model_matrix_8cpp_source_l00022}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Construct\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00072}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Deallocate\+Matrix()}}, \mbox{\hyperlink{model_matrix_8cpp_source_l00092}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Dump\+J\+S\+O\+N()}}, and \mbox{\hyperlink{model_matrix_8cpp_source_l00144}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix\+::\+Fast\+Random\+Walk\+Thread()}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{cuda_model_matrix_8h}{cuda\+Model\+Matrix.\+h}}\end{DoxyCompactItemize}
