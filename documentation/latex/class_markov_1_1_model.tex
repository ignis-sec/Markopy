\hypertarget{class_markov_1_1_model}{}\doxysection{Markov\+::Model$<$ Node\+Storage\+Type $>$ Class Template Reference}
\label{class_markov_1_1_model}\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}


class for the final \mbox{\hyperlink{namespace_markov}{Markov}} \mbox{\hyperlink{class_markov_1_1_model}{Model}}, constructed from nodes and edges.  


\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}\label{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}} 
\mbox{\hyperlink{class_markov_1_1_model_ae1d564c132cbf681f10f8ed0dfc772df}{Model}} ()
\begin{DoxyCompactList}\small\item\em Initialize a model with only start and end nodes. \end{DoxyCompactList}\item 
Node\+Storage\+Type $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a2e0249e4630353a260e06b8f3a72f5bb}{Random\+Walk}} ()
\begin{DoxyCompactList}\small\item\em Do a random walk on this model. Start from the starter node, invoke Random\+Next on current node until terminator node is reached. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_markov_1_1_model_abb14649eb59af2b60d17400e3c1d827b}{adjust}} (Node\+Storage\+Type $\ast$payload, long int occurrence)
\begin{DoxyCompactList}\small\item\em Adjust the model with a single string. Start from the starter node, and for each character, adjust the edge weight from current node to the next, until N\+U\+LL character is reached. Then, update the edge weight from current node, to the terminator node. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Import}} (std\+::ifstream $\ast$)
\begin{DoxyCompactList}\small\item\em Import a file to construct the model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}{Import}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to import with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Model\+::\+Import}} with std\+::ifstream. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Export}} (std\+::ofstream $\ast$)
\begin{DoxyCompactList}\small\item\em Export a file of the model. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}{Export}} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Open a file to export with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Model\+::\+Export}} with std\+::ofstream. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ Node\+Storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}{Starter\+Node}} ()
\begin{DoxyCompactList}\small\item\em Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}\label{class_markov_1_1_model_a2e08608905d7b042627ea844b08045fe}} 
std\+::vector$<$ \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ Node\+Storage\+Type $>$ $\ast$ $>$ $\ast$ {\bfseries Edges} ()
\item 
\mbox{\Hypertarget{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}\label{class_markov_1_1_model_a71f6df805e340ce96e9dc4ee4ebc6537}} 
std\+::map$<$ Node\+Storage\+Type, \mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ Node\+Storage\+Type $>$ $\ast$ $>$ $\ast$ {\bfseries Nodes} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Node\+Storage\+Type$>$\newline
class Markov\+::\+Model$<$ Node\+Storage\+Type $>$}

class for the final \mbox{\hyperlink{namespace_markov}{Markov}} \mbox{\hyperlink{class_markov_1_1_model}{Model}}, constructed from nodes and edges. 

This class will be {\itshape templated later to work with other data types than char}. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_markov_1_1_model_abb14649eb59af2b60d17400e3c1d827b}\label{class_markov_1_1_model_abb14649eb59af2b60d17400e3c1d827b}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!adjust@{adjust}}
\index{adjust@{adjust}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{adjust()}{adjust()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
void \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::adjust (\begin{DoxyParamCaption}\item[{Node\+Storage\+Type $\ast$}]{payload,  }\item[{long int}]{occurrence }\end{DoxyParamCaption})}



Adjust the model with a single string. Start from the starter node, and for each character, adjust the edge weight from current node to the next, until N\+U\+LL character is reached. Then, update the edge weight from current node, to the terminator node. 


\begin{DoxyParams}{Parameters}
{\em string} & -\/ String that is passed from the training, and will be used to adjust the model with \\
\hline
{\em occurrence} & -\/ Occurrence of this string. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}\label{class_markov_1_1_model_af788426a3c41a7838a2aae199e8aef5b}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Export@{Export}}
\index{Export@{Export}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Export (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Open a file to export with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}{Model\+::\+Export}} with std\+::ofstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}\label{class_markov_1_1_model_ae16027a94235d2988ac4be35ea07d939}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Export@{Export}}
\index{Export@{Export}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Export()}{Export()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Export (\begin{DoxyParamCaption}\item[{std\+::ofstream $\ast$}]{f }\end{DoxyParamCaption})}



Export a file of the model. 

File contains a list of edges. Format is\+: Left\+\_\+repr;weight;right\+\_\+repr Iterate over this vertices, and their edges, and write them to file. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}\label{class_markov_1_1_model_a3f872a3af96a91d4627c1a5d5e66b19a}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Import@{Import}}
\index{Import@{Import}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Import (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Open a file to import with filename, and call bool \mbox{\hyperlink{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}{Model\+::\+Import}} with std\+::ifstream. 

\begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}\label{class_markov_1_1_model_a379ea9943f9d4c212e1140d4a9af64f5}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!Import@{Import}}
\index{Import@{Import}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{Import()}{Import()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Import (\begin{DoxyParamCaption}\item[{std\+::ifstream $\ast$}]{f }\end{DoxyParamCaption})}



Import a file to construct the model. 

File contains a list of edges. Format is\+: Left\+\_\+repr;weight;right\+\_\+repr Iterate over this list, and construct nodes and edges accordingly. \begin{DoxyReturn}{Returns}
True if successful, False for incomplete models or corrupt file formats 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_a2e0249e4630353a260e06b8f3a72f5bb}\label{class_markov_1_1_model_a2e0249e4630353a260e06b8f3a72f5bb}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!RandomWalk@{RandomWalk}}
\index{RandomWalk@{RandomWalk}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{RandomWalk()}{RandomWalk()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
Node\+Storage\+Type $\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Random\+Walk}



Do a random walk on this model. Start from the starter node, invoke Random\+Next on current node until terminator node is reached. 

\begin{DoxyReturn}{Returns}
Null terminated string that was generated. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}\label{class_markov_1_1_model_a35cb15a14d034f3365b9d2d3efa1ffc0}} 
\index{Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}!StarterNode@{StarterNode}}
\index{StarterNode@{StarterNode}!Markov::Model$<$ NodeStorageType $>$@{Markov::Model$<$ NodeStorageType $>$}}
\doxysubsubsection{\texorpdfstring{StarterNode()}{StarterNode()}}
{\footnotesize\ttfamily template$<$typename Node\+Storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$Node\+Storage\+Type$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_model}{Markov\+::\+Model}}$<$ Node\+Storage\+Type $>$\+::Starter\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return starter \mbox{\hyperlink{class_markov_1_1_node}{Node}}. 

\begin{DoxyReturn}{Returns}
starter node with 00 value 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/media/ignis/\+H\+D\+D/\+Repositories/\+Markov\+Passwords/\+Markov\+Model/src/model.\+h\item 
/media/ignis/\+H\+D\+D/\+Repositories/\+Markov\+Passwords/\+Markov\+Model/src/model.\+cpp\end{DoxyCompactItemize}
