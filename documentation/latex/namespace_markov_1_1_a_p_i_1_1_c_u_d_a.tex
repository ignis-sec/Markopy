\hypertarget{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{}\doxysection{Markov\+::A\+PI\+::C\+U\+DA Namespace Reference}
\label{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}\index{Markov::API::CUDA@{Markov::API::CUDA}}


Namespace for objects requiring \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{C\+U\+DA}} libraries.  


\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_random}{Random}}
\begin{DoxyCompactList}\small\item\em Namespace for \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_random}{Random}} engines operable under {\bfseries{device}} space. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_device_controller}{C\+U\+D\+A\+Device\+Controller}}
\begin{DoxyCompactList}\small\item\em Controller class for \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{C\+U\+DA}} device. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_c_u_d_a_1_1_c_u_d_a_model_matrix}{C\+U\+D\+A\+Model\+Matrix}}
\begin{DoxyCompactList}\small\item\em Extension of \mbox{\hyperlink{class_markov_1_1_a_p_i_1_1_model_matrix}{Markov\+::\+A\+P\+I\+::\+Model\+Matrix}} which is modified to run on G\+PU devices. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\+\_\+\+\_\+global\+\_\+\+\_\+ void \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_a67e8dd9b192bc5a7f35b8187f376dccc}{Fast\+Random\+Walk\+C\+U\+D\+A\+Kernel}} (unsigned long int n, int min\+Len, int max\+Len, char $\ast$output\+Buffer, char $\ast$matrix\+Index, long int $\ast$total\+Edge\+Weights, long int $\ast$value\+Matrix, char $\ast$edge\+Matrix, int matrix\+Size, int memory\+Per\+Kernel\+Grid, unsigned long $\ast$seed)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{C\+U\+DA}} kernel for the Fast\+Random\+Walk operation. \end{DoxyCompactList}\item 
\+\_\+\+\_\+device\+\_\+\+\_\+ char $\ast$ \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_a3e74937619866dc763c1f11b923866aa}{strchr}} (char $\ast$p, char c, int s\+\_\+len)
\begin{DoxyCompactList}\small\item\em srtchr implementation on {\bfseries{device}} space \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Namespace for objects requiring \mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{C\+U\+DA}} libraries. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_a67e8dd9b192bc5a7f35b8187f376dccc}\label{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_a67e8dd9b192bc5a7f35b8187f376dccc}} 
\index{Markov::API::CUDA@{Markov::API::CUDA}!FastRandomWalkCUDAKernel@{FastRandomWalkCUDAKernel}}
\index{FastRandomWalkCUDAKernel@{FastRandomWalkCUDAKernel}!Markov::API::CUDA@{Markov::API::CUDA}}
\doxysubsubsection{\texorpdfstring{FastRandomWalkCUDAKernel()}{FastRandomWalkCUDAKernel()}}
{\footnotesize\ttfamily \+\_\+\+\_\+global\+\_\+\+\_\+ void Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::\+Fast\+Random\+Walk\+C\+U\+D\+A\+Kernel (\begin{DoxyParamCaption}\item[{unsigned long int}]{n,  }\item[{int}]{min\+Len,  }\item[{int}]{max\+Len,  }\item[{char $\ast$}]{output\+Buffer,  }\item[{char $\ast$}]{matrix\+Index,  }\item[{long int $\ast$}]{total\+Edge\+Weights,  }\item[{long int $\ast$}]{value\+Matrix,  }\item[{char $\ast$}]{edge\+Matrix,  }\item[{int}]{matrix\+Size,  }\item[{int}]{memory\+Per\+Kernel\+Grid,  }\item[{unsigned long $\ast$}]{seed }\end{DoxyParamCaption})}



\mbox{\hyperlink{namespace_markov_1_1_a_p_i_1_1_c_u_d_a}{C\+U\+DA}} kernel for the Fast\+Random\+Walk operation. 

Will be initiated by C\+PU and continued by G\+PU ({\bfseries{global}} tag)


\begin{DoxyParams}{Parameters}
{\em n} & -\/ Number of passwords to generate. \\
\hline
{\em minlen} & -\/ minimum string length for a single generation \\
\hline
{\em max\+Len} & -\/ maximum string length for a single generation \\
\hline
{\em output\+Buffer} & -\/ V\+R\+AM ptr to the output buffer \\
\hline
{\em matrix\+Index} & -\/ V\+R\+AM ptr to the matrix indices \\
\hline
{\em total\+Edge\+Weights} & -\/ V\+R\+AM ptr to the total\+Edge\+Weights array \\
\hline
{\em value\+Matrix} & -\/ V\+R\+AM ptr to the edge weights array \\
\hline
{\em edge\+Matrix} & -\/ V\+R\+AM ptr to the edge representations array \\
\hline
{\em matrix\+Size} & -\/ Size of the matrix dimensions \\
\hline
{\em memory\+Per\+Kernel\+Grid} & -\/ Maximum memory usage per kernel grid \\
\hline
{\em seed} & -\/ seed chunk to generate the random from (generated \& used by Marsaglia) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_a3e74937619866dc763c1f11b923866aa}\label{namespace_markov_1_1_a_p_i_1_1_c_u_d_a_a3e74937619866dc763c1f11b923866aa}} 
\index{Markov::API::CUDA@{Markov::API::CUDA}!strchr@{strchr}}
\index{strchr@{strchr}!Markov::API::CUDA@{Markov::API::CUDA}}
\doxysubsubsection{\texorpdfstring{strchr()}{strchr()}}
{\footnotesize\ttfamily \+\_\+\+\_\+device\+\_\+\+\_\+ char$\ast$ Markov\+::\+A\+P\+I\+::\+C\+U\+D\+A\+::strchr (\begin{DoxyParamCaption}\item[{char $\ast$}]{p,  }\item[{char}]{c,  }\item[{int}]{s\+\_\+len }\end{DoxyParamCaption})}



srtchr implementation on {\bfseries{device}} space 

Fint the first matching index of a string


\begin{DoxyParams}{Parameters}
{\em p} & -\/ string to check \\
\hline
{\em c} & -\/ character to match \\
\hline
{\em s\+\_\+len} & -\/ maximum string length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the match 
\end{DoxyReturn}
