\hypertarget{class_markov_1_1_node}{}\doxysection{Markov\+::Node$<$ storage\+Type $>$ Class Template Reference}
\label{class_markov_1_1_node}\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}


A node class that for the vertices of model. Connected with eachother using \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}.  


\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_markov_1_1_node_a29468e9baf4e7cec86116ef3cbcfcb47}\label{class_markov_1_1_node_a29468e9baf4e7cec86116ef3cbcfcb47}} 
\mbox{\hyperlink{class_markov_1_1_node_a29468e9baf4e7cec86116ef3cbcfcb47}{Node}} ()
\begin{DoxyCompactList}\small\item\em Default constructor. Creates an empty \mbox{\hyperlink{class_markov_1_1_node}{Node}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node_ae89b442197e67a84948ba251f6824ad0}{Node}} (storage\+Type \+\_\+value)
\begin{DoxyCompactList}\small\item\em Constructor. Creates a \mbox{\hyperlink{class_markov_1_1_node}{Node}} with no edges and with given Node\+Value. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_a0e867cddf6b8dd784c36b12aa820fee9}{Link}} (\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ storage\+Type $>$ $\ast$)
\begin{DoxyCompactList}\small\item\em Link this node with another, with this node as its source. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_a1db7cba480ab9fb41ef8ab53d1eac0f2}{Link}} (\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$)
\begin{DoxyCompactList}\small\item\em Link this node with another, with this node as its source. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_aaed7c8987e805fca2b56d50c7f25d9d1}{Random\+Next}} ()
\begin{DoxyCompactList}\small\item\em Chose a random node from the list of edges, with regards to its Edge\+Weight, and Traverse\+Node to that. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_node_a77dbb90420f6199790a4fa986b93f85c}{Update\+Edges}} (\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$)
\begin{DoxyCompactList}\small\item\em Insert a new edge to the this.\+edges. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_ad836573fbdec1c6d7e72945f48ed081c}{Find\+Edge}} (storage\+Type repr)
\begin{DoxyCompactList}\small\item\em Find an edge with its character representation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_adec94acba3fc021a2bbaded53d9e9730}{Find\+Edge}} (\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ storage\+Type $>$ $\ast$target)
\begin{DoxyCompactList}\small\item\em Find an edge with its pointer. Avoid unless neccessary because comptutational cost of find by character is cheaper (because of std\+::map) \end{DoxyCompactList}\item 
unsigned char \mbox{\hyperlink{class_markov_1_1_node_ac7cce56376f2a00764f64a0194cbb498}{Node\+Value}} ()
\begin{DoxyCompactList}\small\item\em Return character representation of this node. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_markov_1_1_node_ab254a9c976195fcb1cac4d463d030d3c}\label{class_markov_1_1_node_ab254a9c976195fcb1cac4d463d030d3c}} 
void \mbox{\hyperlink{class_markov_1_1_node_ab254a9c976195fcb1cac4d463d030d3c}{Update\+Total\+Vertice\+Weight}} (long int offset)
\begin{DoxyCompactList}\small\item\em Change total weights with offset. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_markov_1_1_node_ad404ccc317ef8413881b8d7b72b4f4f0}\label{class_markov_1_1_node_ad404ccc317ef8413881b8d7b72b4f4f0}} 
std\+::map$<$ storage\+Type, \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_ad404ccc317ef8413881b8d7b72b4f4f0}{Edges}} ()
\begin{DoxyCompactList}\small\item\em return edges \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_markov_1_1_node_af5e5e29a5027651b4f3a4d1dd6883f60}\label{class_markov_1_1_node_af5e5e29a5027651b4f3a4d1dd6883f60}} 
uint64\+\_\+t \mbox{\hyperlink{class_markov_1_1_node_af5e5e29a5027651b4f3a4d1dd6883f60}{Total\+Edge\+Weights}} ()
\begin{DoxyCompactList}\small\item\em return total edge weights \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename storage\+Type$>$\newline
class Markov\+::\+Node$<$ storage\+Type $>$}

A node class that for the vertices of model. Connected with eachother using \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}. 

This class will {\itshape later be templated to accept other data types than char}. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_markov_1_1_node_ae89b442197e67a84948ba251f6824ad0}\label{class_markov_1_1_node_ae89b442197e67a84948ba251f6824ad0}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!Node@{Node}}
\index{Node@{Node}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{Node()}{Node()}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::\mbox{\hyperlink{class_markov_1_1_node}{Node}} (\begin{DoxyParamCaption}\item[{storage\+Type}]{\+\_\+value }\end{DoxyParamCaption})}



Constructor. Creates a \mbox{\hyperlink{class_markov_1_1_node}{Node}} with no edges and with given Node\+Value. 


\begin{DoxyParams}{Parameters}
{\em Node\+Value} & -\/ Nodes character representation. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_markov_1_1_node_adec94acba3fc021a2bbaded53d9e9730}\label{class_markov_1_1_node_adec94acba3fc021a2bbaded53d9e9730}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!FindEdge@{FindEdge}}
\index{FindEdge@{FindEdge}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{FindEdge()}{FindEdge()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$storage\+Type$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Find\+Edge (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ storage\+Type $>$ $\ast$}]{target }\end{DoxyParamCaption})}



Find an edge with its pointer. Avoid unless neccessary because comptutational cost of find by character is cheaper (because of std\+::map) 


\begin{DoxyParams}{Parameters}
{\em target} & -\/ target node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}} that is connected between this node, and the target node. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_ad836573fbdec1c6d7e72945f48ed081c}\label{class_markov_1_1_node_ad836573fbdec1c6d7e72945f48ed081c}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!FindEdge@{FindEdge}}
\index{FindEdge@{FindEdge}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{FindEdge()}{FindEdge()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Find\+Edge (\begin{DoxyParamCaption}\item[{storage\+Type}]{repr }\end{DoxyParamCaption})}



Find an edge with its character representation. 


\begin{DoxyParams}{Parameters}
{\em repr} & -\/ character Node\+Value of the target node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}} that is connected between this node, and the target node. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_a1db7cba480ab9fb41ef8ab53d1eac0f2}\label{class_markov_1_1_node_a1db7cba480ab9fb41ef8ab53d1eac0f2}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!Link@{Link}}
\index{Link@{Link}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{Link()}{Link()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Link (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$}]{v }\end{DoxyParamCaption})}



Link this node with another, with this node as its source. 

{\itshape D\+O\+ES N\+OT} create a new \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}. 
\begin{DoxyParams}{Parameters}
{\em \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}} & -\/ \mbox{\hyperlink{class_markov_1_1_edge}{Edge}} that will accept this node as its Left\+Node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the same edge as parameter target. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_a0e867cddf6b8dd784c36b12aa820fee9}\label{class_markov_1_1_node_a0e867cddf6b8dd784c36b12aa820fee9}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!Link@{Link}}
\index{Link@{Link}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{Link()}{Link()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Link (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$ $\ast$}]{n }\end{DoxyParamCaption})}



Link this node with another, with this node as its source. 

Creates a new \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}. 
\begin{DoxyParams}{Parameters}
{\em target} & -\/ Target node which will be the Right\+Node() of new edge. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new node with Left\+Node as this, and Right\+Node as parameter target. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_ac7cce56376f2a00764f64a0194cbb498}\label{class_markov_1_1_node_ac7cce56376f2a00764f64a0194cbb498}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!NodeValue@{NodeValue}}
\index{NodeValue@{NodeValue}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{NodeValue()}{NodeValue()}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
unsigned char \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Node\+Value}



Return character representation of this node. 

\begin{DoxyReturn}{Returns}
character representation at \+\_\+value. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_aaed7c8987e805fca2b56d50c7f25d9d1}\label{class_markov_1_1_node_aaed7c8987e805fca2b56d50c7f25d9d1}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!RandomNext@{RandomNext}}
\index{RandomNext@{RandomNext}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{RandomNext()}{RandomNext()}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Random\+Next}



Chose a random node from the list of edges, with regards to its Edge\+Weight, and Traverse\+Node to that. 

This operation is done by generating a random number in range of 0-\/this.\+total\+\_\+edge\+\_\+weights, and then iterating over the list of edges. At each step, Edge\+Weight of the edge is subtracted from the random number, and once it is 0, next node is selected. \begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_markov_1_1_node}{Node}} that was chosen at Edge\+Weight biased random. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_a77dbb90420f6199790a4fa986b93f85c}\label{class_markov_1_1_node_a77dbb90420f6199790a4fa986b93f85c}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!UpdateEdges@{UpdateEdges}}
\index{UpdateEdges@{UpdateEdges}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{UpdateEdges()}{UpdateEdges()}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Update\+Edges (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$}]{v }\end{DoxyParamCaption})}



Insert a new edge to the this.\+edges. 


\begin{DoxyParams}{Parameters}
{\em edge} & -\/ New edge that will be inserted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if insertion was successful, false if it fails. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/media/ignis/\+H\+D\+D/\+Repositories/\+Markov\+Passwords/\+Markov\+Model/src/edge.\+h\item 
/media/ignis/\+H\+D\+D/\+Repositories/\+Markov\+Passwords/\+Markov\+Model/src/node.\+h\item 
/media/ignis/\+H\+D\+D/\+Repositories/\+Markov\+Passwords/\+Markov\+Model/src/node.\+cpp\end{DoxyCompactItemize}
