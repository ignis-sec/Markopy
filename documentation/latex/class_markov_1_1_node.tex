\hypertarget{class_markov_1_1_node}{}\doxysection{Markov\+::Node$<$ storage\+Type $>$ Class Template Reference}
\label{class_markov_1_1_node}\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}


A node class that for the vertices of model. Connected with eachother using \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}.  


\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_markov_1_1_node_a29468e9baf4e7cec86116ef3cbcfcb47}\label{class_markov_1_1_node_a29468e9baf4e7cec86116ef3cbcfcb47}} 
\mbox{\hyperlink{class_markov_1_1_node_a29468e9baf4e7cec86116ef3cbcfcb47}{Node}} ()
\begin{DoxyCompactList}\small\item\em Default constructor. Creates an empty \mbox{\hyperlink{class_markov_1_1_node}{Node}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node_ae89b442197e67a84948ba251f6824ad0}{Node}} (storage\+Type \+\_\+value)
\begin{DoxyCompactList}\small\item\em Constructor. Creates a \mbox{\hyperlink{class_markov_1_1_node}{Node}} with no edges and with given value. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_a0e867cddf6b8dd784c36b12aa820fee9}{Link}} (\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ storage\+Type $>$ $\ast$)
\begin{DoxyCompactList}\small\item\em Link this node with another, with this node as its source. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_a1db7cba480ab9fb41ef8ab53d1eac0f2}{Link}} (\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$)
\begin{DoxyCompactList}\small\item\em Link this node with another, with this node as its source. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_aaed7c8987e805fca2b56d50c7f25d9d1}{Random\+Next}} ()
\begin{DoxyCompactList}\small\item\em Chose a random node from the list of edges, with regards to its weight, and traverse to that. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_markov_1_1_node_a77dbb90420f6199790a4fa986b93f85c}{Update\+Edges}} (\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$)
\begin{DoxyCompactList}\small\item\em Insert a new edge to the this.\+edges. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_aa1768fa91e88a190f7d4cb7bc3cdd82e}{find\+Edge}} (storage\+Type repr)
\begin{DoxyCompactList}\small\item\em Find an edge with its character representation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_ab8bcc5b76df497f5cb6800399a26a87a}{find\+Edge}} (\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ storage\+Type $>$ $\ast$target)
\begin{DoxyCompactList}\small\item\em Find an edge with its pointer. Avoid unless neccessary because comptutational cost of find by character is cheaper (because of std\+::map) \end{DoxyCompactList}\item 
unsigned char \mbox{\hyperlink{class_markov_1_1_node_ada4486380ae3e196fb1c24e2ec8325f3}{value}} ()
\begin{DoxyCompactList}\small\item\em Return character representation of this node. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_markov_1_1_node_a19a448f859ac81d65b8c4ebf8ac6fbd2}\label{class_markov_1_1_node_a19a448f859ac81d65b8c4ebf8ac6fbd2}} 
void \mbox{\hyperlink{class_markov_1_1_node_a19a448f859ac81d65b8c4ebf8ac6fbd2}{update\+Total\+Vertice\+Weight}} (long int offset)
\begin{DoxyCompactList}\small\item\em Change total weights with offset. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_markov_1_1_node_ad404ccc317ef8413881b8d7b72b4f4f0}\label{class_markov_1_1_node_ad404ccc317ef8413881b8d7b72b4f4f0}} 
std\+::map$<$ storage\+Type, \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$ storage\+Type $>$ $\ast$ $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node_ad404ccc317ef8413881b8d7b72b4f4f0}{Edges}} ()
\begin{DoxyCompactList}\small\item\em return edges \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_markov_1_1_node_af5e5e29a5027651b4f3a4d1dd6883f60}\label{class_markov_1_1_node_af5e5e29a5027651b4f3a4d1dd6883f60}} 
uint64\+\_\+t \mbox{\hyperlink{class_markov_1_1_node_af5e5e29a5027651b4f3a4d1dd6883f60}{Total\+Edge\+Weights}} ()
\begin{DoxyCompactList}\small\item\em return total edge weights \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename storage\+Type$>$\newline
class Markov\+::\+Node$<$ storage\+Type $>$}

A node class that for the vertices of model. Connected with eachother using \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}. 

This class will {\itshape later be templated to accept other data types than char}. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_markov_1_1_node_ae89b442197e67a84948ba251f6824ad0}\label{class_markov_1_1_node_ae89b442197e67a84948ba251f6824ad0}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!Node@{Node}}
\index{Node@{Node}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{Node()}{Node()}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::\mbox{\hyperlink{class_markov_1_1_node}{Node}} (\begin{DoxyParamCaption}\item[{storage\+Type}]{\+\_\+value }\end{DoxyParamCaption})}



Constructor. Creates a \mbox{\hyperlink{class_markov_1_1_node}{Node}} with no edges and with given value. 


\begin{DoxyParams}{Parameters}
{\em value} & -\/ Nodes character representation. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_markov_1_1_node_ab8bcc5b76df497f5cb6800399a26a87a}\label{class_markov_1_1_node_ab8bcc5b76df497f5cb6800399a26a87a}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!findEdge@{findEdge}}
\index{findEdge@{findEdge}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{findEdge()}{findEdge()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}}$<$storage\+Type$>$$\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::find\+Edge (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_node}{Node}}$<$ storage\+Type $>$ $\ast$}]{target }\end{DoxyParamCaption})}



Find an edge with its pointer. Avoid unless neccessary because comptutational cost of find by character is cheaper (because of std\+::map) 


\begin{DoxyParams}{Parameters}
{\em target} & -\/ target node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}} that is connected between this node, and the target node. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_aa1768fa91e88a190f7d4cb7bc3cdd82e}\label{class_markov_1_1_node_aa1768fa91e88a190f7d4cb7bc3cdd82e}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!findEdge@{findEdge}}
\index{findEdge@{findEdge}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{findEdge()}{findEdge()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::find\+Edge (\begin{DoxyParamCaption}\item[{storage\+Type}]{repr }\end{DoxyParamCaption})}



Find an edge with its character representation. 


\begin{DoxyParams}{Parameters}
{\em repr} & -\/ character value of the target node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_markov_1_1_edge}{Edge}} that is connected between this node, and the target node. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_a1db7cba480ab9fb41ef8ab53d1eac0f2}\label{class_markov_1_1_node_a1db7cba480ab9fb41ef8ab53d1eac0f2}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!Link@{Link}}
\index{Link@{Link}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{Link()}{Link()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Link (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$}]{v }\end{DoxyParamCaption})}



Link this node with another, with this node as its source. 

{\itshape D\+O\+ES N\+OT} create a new \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}. 
\begin{DoxyParams}{Parameters}
{\em \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}} & -\/ \mbox{\hyperlink{class_markov_1_1_edge}{Edge}} that will accept this node as its left. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the same edge as parameter target. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_a0e867cddf6b8dd784c36b12aa820fee9}\label{class_markov_1_1_node_a0e867cddf6b8dd784c36b12aa820fee9}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!Link@{Link}}
\index{Link@{Link}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{Link()}{Link()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Link (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$ $\ast$}]{n }\end{DoxyParamCaption})}



Link this node with another, with this node as its source. 

Creates a new \mbox{\hyperlink{class_markov_1_1_edge}{Edge}}. 
\begin{DoxyParams}{Parameters}
{\em target} & -\/ Target node which will be the right() of new edge. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new node with left as this, and right as parameter target. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_aaed7c8987e805fca2b56d50c7f25d9d1}\label{class_markov_1_1_node_aaed7c8987e805fca2b56d50c7f25d9d1}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!RandomNext@{RandomNext}}
\index{RandomNext@{RandomNext}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{RandomNext()}{RandomNext()}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
\mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$ $\ast$ \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Random\+Next}



Chose a random node from the list of edges, with regards to its weight, and traverse to that. 

This operation is done by generating a random number in range of 0-\/this.\+total\+\_\+edge\+\_\+weights, and then iterating over the list of edges. At each step, weight of the edge is subtracted from the random number, and once it is 0, next node is selected. \begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_markov_1_1_node}{Node}} that was chosen at weight biased random. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_a77dbb90420f6199790a4fa986b93f85c}\label{class_markov_1_1_node_a77dbb90420f6199790a4fa986b93f85c}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!UpdateEdges@{UpdateEdges}}
\index{UpdateEdges@{UpdateEdges}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{UpdateEdges()}{UpdateEdges()}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
bool \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::Update\+Edges (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_markov_1_1_edge}{Markov\+::\+Edge}}$<$ storage\+Type $>$ $\ast$}]{v }\end{DoxyParamCaption})}



Insert a new edge to the this.\+edges. 


\begin{DoxyParams}{Parameters}
{\em edge} & -\/ New edge that will be inserted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if insertion was successful, false if it fails. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_markov_1_1_node_ada4486380ae3e196fb1c24e2ec8325f3}\label{class_markov_1_1_node_ada4486380ae3e196fb1c24e2ec8325f3}} 
\index{Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}!value@{value}}
\index{value@{value}!Markov::Node$<$ storageType $>$@{Markov::Node$<$ storageType $>$}}
\doxysubsubsection{\texorpdfstring{value()}{value()}}
{\footnotesize\ttfamily template$<$typename storage\+Type $>$ \\
unsigned char \mbox{\hyperlink{class_markov_1_1_node}{Markov\+::\+Node}}$<$ storage\+Type $>$\+::value}



Return character representation of this node. 

\begin{DoxyReturn}{Returns}
character representation at \+\_\+value. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/media/ignis/\+H\+D\+D/\+Repositories/\+Markov\+Passwords/\+Markov\+Model/src/edge.\+h\item 
/media/ignis/\+H\+D\+D/\+Repositories/\+Markov\+Passwords/\+Markov\+Model/src/node.\+h\item 
/media/ignis/\+H\+D\+D/\+Repositories/\+Markov\+Passwords/\+Markov\+Model/src/node.\+cpp\end{DoxyCompactItemize}
